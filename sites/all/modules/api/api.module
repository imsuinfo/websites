<?php

/**
 * @file
 * Generates and displays API documentation pages.
 *
 * This is an implementation of a subset of the Doxygen documentation generator
 * specification, tuned to produce output that best benefits the Drupal code
 * base. It is designed to assume the code it documents follows Drupal coding
 * conventions, and supports documentation blocks in formats described on
 * http://drupal.org/node/1354
 */

/**
 * Regular expression for matching file names.
 */
define('API_RE_FILENAME', '([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)+)');

/**
 * Regular expression for matching PHP functions and methods in text.
 *
 * These are patterns like ClassName::methodName(), or just function_name().
 */
define('API_RE_FUNCTION_IN_TEXT', '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff:]*');

/**
 * Regular expression for matching hook names.
 *
 * Since the actual PHP function name already has a prefix, these can
 * technically start with a number, although it's unlikely.
 */
define('API_RE_HOOK_NAME', '[a-zA-Z0-9_\x7f-\xff]+');

/**
 * Regular expression for matching class names in text.
 *
 * Although class names can technically be just like function names, we
 * only want to match class names if they include a capital letter, so as
 * not to be too overly aggressive.
 */
define('API_RE_CLASS_NAME_TEXT', '[a-zA-Z0-9_\x7f-\xff]*[A-Z][a-zA-Z0-9_\x7f-\xff]*');

/**
 * Regular expression for starting inline \@tags.
 */
define('API_RE_TAG_START', '(?<!\\\)@');

/**
 * File path separator.
 */
define('API_FILEPATH_SEPARATOR', '/');

/**
 * File path separator replacement.
 */
define('API_FILEPATH_SEPARATOR_REPLACEMENT', '!');

/**
 * File path separator replacement for API v 1.3.
 */
define('API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT', '--');

/**
 * Implements hook_help().
 */
function api_help($path, $arg) {
  switch ($path) {
    case 'admin/help#api':
      return t('
<p>This is an implementation of a subset of the Doxygen documentation generator specification, tuned to produce output that best benefits the Drupal code base. It is designed to assume the code it documents follows Drupal coding conventions, and supports documentation blocks in formats described on !doxygen_link.</p>

<h3>Set up</h3>

<p>Visit the !api_settings_page to configure the module. You must have the relevant Drupal code base on the same machine as the site hosting the API module. Follow the descriptions in the \'Branches to index\' section to set up the code base for indexing.</p>

<p>Indexing of PHP functions is also supported. If the site has internet access, then the default settings for the \'PHP Manual\' section should work fine. For local development environments that have a PHP manual installed, you can edit the paths to point to the appropriate locations.</p>

<p>The module indexes code branches during cron runs, so make sure the site has cron functionality set up properly.</p>
', array('!api_settings_page' => l(t('API settings page'), 'admin/config/development/api'), '!doxygen_link' => l('http://drupal.org/node/1354', 'http://drupal.org/node/1354')));
  }
}

/**
 * Returns a list of all defined branches.
 *
 * @param $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return
 *   Array of branch objects, in order by branch weight.
 */
function api_get_branches($_reset = FALSE) {
  static $branches;

  if (!isset($branches) || $_reset) {
    $result = db_select('api_branch', 'b')
      ->fields('b')
      ->orderBy('weight', 'ASC')
      ->execute();
    $branches = array();
    foreach($result as $branch) {
      drupal_unpack($branch);
      $branches[$branch->branch_id] = $branch;
    }
  }

  return $branches;
}

/**
 * Returns a branch, given a branch ID number.
 *
 * @param $id
 *   Branch ID number.
 *
 * @return
 *   Branch object for the given branch ID. If $id is not set, the default
 *   branch is returned. If the requested branch does not exist, NULL.
 */
function api_get_branch_by_id($id = NULL) {
  $branches = api_get_branches();
  if (!isset($id)) {
    $id = variable_get('api_default_branch', NULL);
  }
  if (isset($branches[$id])) {
    return $branches[$id];
  }

  return NULL;
}

/**
 * Returns the list of currently-used branch names across all projects.
 *
 * @param $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return
 *   Array of branch names in use.
 */
function api_get_branch_names($_reset = FALSE) {
  static $branch_names;

  if (!isset($branch_names) || $_reset) {
    $result = db_select('api_branch', 'b')
      ->fields('b', array('branch_name'))
      ->condition('status', 1)
      ->execute();
    $branch_names = array();
    foreach($result as $branch) {
      $branch_names[$branch->branch_name] = $branch->branch_name;
    }
  }

  return $branch_names;
}

/**
 * Implements hook_menu().
 */
function api_menu() {
  $items = array();
  $branches = api_get_branches();
  if (count($branches)) {
    $default_branch = api_get_branch_by_id();
    $projects = _api_make_menu_projects();

    // Part 1: No object, Default branch
    $items['api/search'] = array(
      'title' => 'API Search',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('api_search_form', $default_branch),
      'access arguments' => array('access API reference'),
      'type' => MENU_SUGGESTED_ITEM,
    );
    $items['apis'] = array(
      'title' => 'API search',
      'page callback' => 'api_search_redirect',
      'access arguments' => array('access API reference'),
      'type' => MENU_CALLBACK,
      'file' => 'api.pages.inc',
    );
  }

  // Admin
  $items['admin/config/development/api'] = array(
    'title' => 'API reference',
    'description' => 'Configure branches for documentation.',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_page_admin_overview',
    'file' => 'api.admin.inc',
  );
  $items['admin/config/development/api/branches'] = array(
    'title' => 'Branches',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/config/development/api/branches/list'] = array(
    'title' => 'List',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/config/development/api/branches/new'] = array(
    'title' => 'New branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_new_branch_page',
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/config/development/api/branches/reset_queue'] = array(
    'title' => 'Reset parse queue',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_reset_queue_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/config/development/api/branches/new/%'] = array(
    'title' => 'New branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_edit_form', 6),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/development/api/branches/%'] = array(
    'title' => 'Edit branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_edit_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/development/api/reparse/%'] = array(
    'title' => 'Reparse branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_reparse',
    'page arguments' => array(5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/branches/%/delete'] = array(
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_delete_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  if (module_exists('comment')) {
    $items['admin/config/development/api/comments'] = array(
      'title' => 'Comment settings',
      'access arguments' => array('administer API reference'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('api_comments_settings_form'),
      'file' => 'api.admin.inc',
      'type' => MENU_LOCAL_TASK,
    );
  }

  // OpenSearch metadata callback.
  $items['api/opensearch/%'] = array(
    'page callback' => 'api_opensearch',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // OpenSearch suggestions callback.
  $items['api/suggest/%/%menu_tail'] = array(
    'page callback' => 'api_suggest',
    'page arguments' => array(2, 3),
    'load arguments' => array('%map', '%index'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Autocomplete callback.
  // This returns ALL possibilities for a search term.
  $items['api/autocomplete/%'] = array(
    'page callback' => 'api_autocomplete',
    'page arguments' => array(2, TRUE),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
  );

  // Function dumps for IDEs and code editors.
  $items['api/function_dump/%'] = array(
    'page callback' => 'api_page_function_dump',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  foreach (api_get_branches() as $branch) {
    if ($branch->status) {
      $items['api/search/' . $branch->branch_name . '/%menu_tail'] = array(
        'title' => $branch->branch_name,
        'page callback' => 'api_search_listing',
        'page arguments' => array($branch->branch_name, 3),
        'load arguments' => array('%map', '%index'),
        'access arguments' => array('access API reference'),
        'type' => MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
    }
  }

  // Listings

  // Projects
  $items['api/projects'] = array(
    'title' => 'Projects',
    'page callback' => 'api_page_projects',
    'access arguments' => array('access API reference'),
    'type' => MENU_SUGGESTED_ITEM,
    'file' => 'api.pages.inc',
  );

  // Files
  $items['api/%/%api_filename'] = array(
    'title' => 'File',
    'load arguments' => array(1, 3), // project, branch
    'page callback' => 'api_page_file',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%api_filename/theme_invokes'] = array(
    'title' => 'File',
    'load arguments' => array(1, 4), // project, branch
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(2, 'theme_invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Items
  $items['api/%/%/function/%api_item'] = array(
    'title' => 'Function',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/%/function/calls/%api_item'] = array(
    'title' => 'Function calls',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'calls'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/implementations/%api_item'] = array(
    'title' => 'Function implementations',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'implementations'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/references/%api_item'] = array(
    'title' => 'Function references',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'references'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/invokes/%api_item'] = array(
    'title' => 'Hook invocations',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/theme_invokes/%api_item'] = array(
    'title' => 'Theme invokes',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'theme_invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/%/constant/%api_item'] = array(
    'title' => 'Constant',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'constant'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/global/%api_item'] = array(
    'title' => 'Global',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'global'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/property/%api_item'] = array(
    'title' => 'Property',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'property'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/class/%api_item'] = array(
    'title' => 'Class',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/interface/%api_item'] = array(
    'title' => 'Interface',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/group/%api_item'] = array(
    'title' => 'Group',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_group',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  foreach ($branches as $branch) {
    if ($branch->status) {
      $is_default = ($branch->branch_name === $projects[$branch->project]['use branch']);

      // Main branch page
      if ($is_default) {
        $items['api/' . $branch->project] = array(
          'title' => 'API reference',
          'page callback' => 'api_page_branch',
          'page arguments' => array($branch),
          'access arguments' => array('access API reference'),
          'type' => $branch->branch_id === $default_branch->branch_id ? MENU_NORMAL_ITEM : MENU_SUGGESTED_ITEM,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/' . $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_branch',
        'page arguments' => array($branch),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );

      // Listings
      if ($is_default) {
        $items['api/' . $branch->project . '/functions'] = array(
          'title' => 'Functions',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'function'),
          'type' => MENU_SUGGESTED_ITEM,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/functions/' . $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'function'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/constants'] = array(
          'title' => 'Constants',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'constant'),
          'type' => MENU_SUGGESTED_ITEM,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/constants/' . $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'constant'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/globals'] = array(
          'title' => 'Globals',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'global'),
          'type' => MENU_SUGGESTED_ITEM,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/globals/' . $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'global'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/files'] = array(
          'title' => 'Files',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'file'),
          'type' => MENU_SUGGESTED_ITEM,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/files/' . $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'file'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/classes'] = array(
          'title' => 'Classes and interfaces',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'class'),
          'type' => MENU_SUGGESTED_ITEM,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/classes/' . $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'class'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
      if ($is_default) {
        $items['api/' . $branch->project . '/groups'] = array(
          'title' => 'Topics',
          'page callback' => 'api_page_listing',
          'access arguments' => array('access API reference'),
          'page arguments' => array($branch, 'group'),
          'type' => MENU_SUGGESTED_ITEM,
          'file' => 'api.pages.inc',
        );
      }
      $items['api/' . $branch->project . '/groups/' . $branch->branch_name] = array(
        'title' => $branch->title,
        'page callback' => 'api_page_listing',
        'page arguments' => array($branch, 'group'),
        'access arguments' => array('access API reference'),
        'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
        'file' => 'api.pages.inc',
      );
    }
  }

  // Redirect 1.0 file links.
  $items['api/file/%menu_tail'] = array(
    'page callback' => 'api_file_redirect',
    'page arguments' => array(2),
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
    'file' => 'legacy.inc',
  );

  // Redirect 1.1 links.
  // Objects
  $items['api/function/%api_legacy_1_2_object'] =
  $items['api/function/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('function', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constant/%api_legacy_1_2_object'] =
  $items['api/constant/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('constant', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/global/%api_legacy_1_2_object'] =
  $items['api/global/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('global', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/group/%api_legacy_1_2_object'] =
  $items['api/group/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('group', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // Default listings
  $items['api/functions'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/functions'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/files'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/files'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constants'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/constants'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/globals'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/globals'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/groups'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/groups'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // Branch listings
  $items['api/functions/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('functions'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/files/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('files'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constants/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('constants'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/globals/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('globals'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/groups/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('groups'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/%api_legacy_1_2_listing'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Returns a list of projects with their default branches, for use in menus.
 *
 * Basically, we need to define a default branch for each project. If a project
 * has a branch_name matching the global default_branch, use that. Otherwise,
 * use the max, so that if the branch names are 5, 6, 7, etc., we use 7.
 */
function _api_make_menu_projects() {
  $branches = api_get_branches();
  $default_branch = api_get_branch_by_id();
  $projects = array();

  foreach ($branches as $branch) {
    if ($branch->status) {
      if (!isset($projects[$branch->project])) {
        $projects[$branch->project] = array(
          'max branch' => $branch->branch_name,
          'use branch' => NULL,
        );
      }
      else {
        $projects[$branch->project]['max branch'] = max($projects[$branch->project]['max branch'], $branch->branch_name);
      }

      if ($branch->branch_name === $default_branch->branch_name) {
        $projects[$branch->project]['use branch'] = $branch->branch_name;
      }
    }
  }

  foreach (array_keys($projects) as $project) {
    if (is_null($projects[$project]['use branch'])) {
      $projects[$project]['use branch'] = $projects[$project]['max branch'];
    }
  }

  return $projects;
}

/**
 * Finds objects for old URLs and returns the new URL.
 *
 * @param $object_name
 *   Name of the object to find the URL of.
 * @param $object_type
 *   Type of object ('function', 'constant', etc.).
 * @param $branch_name
 *   Name of the branch to find the object in (across projects).
 *
 * @return
 *   First matching URL for this combination of object name, type, and branch
 *   name, or NULL if none is found.
 */
function api_legacy_1_2_object_load($object_name, $object_type, $branch_name) {
  foreach (api_get_branches_by_name($branch_name) as $branch) {
    $object = api_object_load($object_name, $branch, $object_type);
    if (isset($object)) {
      return api_url($object);
    }
  }
}

/**
 * Returns the current path to listing pages accessed with old URLs.
 *
 * @param $branch_name
 *   Name of the branch to redirect.
 * @param $type
 *   Type of listing page ('functions', etc.), or NULL for the home page.
 *
 * @return
 *   URL to redirect this listing to, in the default project.
 */
function api_legacy_1_2_listing_load($branch_name, $type = NULL) {
  $branch = api_get_branch_by_id();
  if (empty($branch_name)) {
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      $branch_name = '';
    }
  }
  if (isset($type)) {
    return 'api/' . $branch->project . '/' . $type . '/' . $branch_name;
  }
  else {
    return 'api/' . $branch->project . '/' . $branch_name;
  }
}

/**
 * Finds all branches matching a branch name, across projects.
 *
 * @param $branch_name
 *   Branch name to match. If empty, defaults to the default branch.
 *
 * @return
 *   Array of all branch objects with this name.
 */
function api_get_branches_by_name($branch_name) {
  $return = array();
  if (empty($branch_name)) {
    $branch = api_get_branch_by_id();
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      return array();
    }
  }

  foreach (api_get_branches() as $branch) {
    if ($branch->branch_name === $branch_name) {
      $return[] = $branch;
    }
  }

  return $return;
}

/**
 * Loads a branch, given a project and branch name.
 *
 * @param $project
 *   The project name matching {api_branch}.project.
 * @param $branch_name
 *   The branch name matching {api_branch}.branch_name. If not set, uses the
 *   default branch name.
 *
 * @return
 *   Object representing the branch, or NULL if there is no match.
 */
function api_get_branch_by_name($project, $branch_name) {
  if (empty($branch_name)) {
    $branch = api_get_branch_by_id();
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      $branch_name = '';
    }
  }

  foreach (api_get_branches() as $branch) {
    if ($branch->project === $project && $branch->branch_name === $branch_name) {
      return $branch;
    }
  }

  return NULL;
}

/**
 * Loads an API object for the menu router.
 *
 * Menu object load callback for %api_item in menu paths.
 *
 * @param $object_name
 *   The object name matching {api_documentation}.object_name.
 * @param $project
 *   The project name matching {api_branch}.project.
 * @param $branch_name
 *   The branch name matching {api_branch}.branch_name.
 * @param $file_name
 *   The name of the file the object is in, with API_FILEPATH_SEPARATOR for path
 *   separators. We convert all API_FILEPATH_SEPARATOR_REPLACEMENTs back to
 *   API_FILEPATH_SEPARATORs to maintain the original file path information.
 *   (When a URL is created for a documentation object, all
 *   API_FILEPATH_SEPARATORs in the original file path are replaced with
 *   API_FILEPATH_SEPARATOR_REPLACEMENTs so that API_FILEPATH_SEPARATORs won't
 *   be interpreted as part the of URL.
 * @param $type
 *   API item type; one of function, constant, global, property, class,
 *   interface, or group.
 *
 * @return
 *   Loaded documentation object, or FALSE if not found (returning FALSE will
 *   cause the Drupal menu system to recognize it's a 404 error).
 */
function api_item_load($object_name, $project, $branch_name, $file_name, $type) {
  // Check type
  if (!in_array($type, array('function', 'constant', 'global', 'property', 'class', 'interface', 'group'))) {
    return FALSE;
  }

  // Load branch
  $branch = api_get_branch_by_name($project, $branch_name);
  if (is_null($branch)) {
    return FALSE;
  }

  // Load object
  $back_to_orig_filename = str_replace(API_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name);
  $doc_object = api_object_load($object_name, $branch, $type, $back_to_orig_filename);

  if (empty($doc_object) && (strpos($file_name, API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) !== FALSE)) {
    // May be an API 1.3 style path. See if we can load a valid object with the
    // old replacement pattern.
    $doc_object = api_object_load($object_name, $branch, $type, str_replace(API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name) );
    // If we could, redirect to the current URL.
    if (!empty($doc_object)) {
      drupal_goto(api_url($doc_object));
    }
  }

  if (empty($doc_object)) {
    return FALSE;
  }

  return $doc_object;
}

/**
 * Implements hook_cron_queue_info().
 */
function api_cron_queue_info() {
  return array(
    'api_parse' => array(
      'worker callback' => 'api_queue_parse_file',
      'time' => 15,
    ),
    'api_delete' => array(
      'worker callback' => 'api_queue_file_delete',
      'time' => 15,
    ),
  );
}

/**
 * Loads an API file object.
 *
 * Menu object load callback for %api_filename in menu paths.
 *
 * API v 1.3 replaced all '/'s in the file path with '--' for the URL generated
 * for the file. We need to handle a URL with '--' (=
 * API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) and redirected it to the current,
 * correct URL.  We now convert all '/'s (= API_FILEPATH_SEPARATOR) to
 * API_FILEPATH_SEPARATOR_REPLACEMENT when a URL is created for a documentatio
 * object. Here we need to go back to the original filename and path.
 *
 * @param $file_name
 *   Name of the file to load.
 * @param $project
 *   Name of the project the file is in.
 * @param $branch_name
 *   Name of the branch the file is in.
 *
 * @return
 *   Loaded documentation object, or FALSE if not found (returning FALSE will
 *   cause the Drupal menu system to recognize it's a 404 error).
 */
function api_filename_load($file_name, $project, $branch_name) {
  $branch = api_get_branch_by_name($project, $branch_name);
  if (is_null($branch)) {
    return FALSE;
  }

  $doc_object = api_object_load(str_replace(API_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name), $branch, 'file');

  if (empty($doc_object) && (strpos($file_name, API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) !== FALSE)) {
    // May be an API 1.3 style path. See if we can load a valid object with the
    // old replacement pattern.
    $doc_object = api_object_load(str_replace(API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name), $branch, 'file');
    // If we could, redirect to the current URL.
    if (!empty($doc_object)) {
      drupal_goto(api_url($doc_object));
    }
  }

  if (empty($doc_object)) {
    return FALSE;
  }

  return $doc_object;
}

/**
 * Loads a documentation object.
 *
 * @param $object_name_or_did
 *   The string object name or documentation ID to load.
 * @param $branch
 *   Branch object.
 * @param $object_type
 *   A string type, or array of strings: class, interface, function, etc.
 * @param $file_name
 *   Name of the file the object is in (if needed).
 *
 * @return
 *   Object with information about the matching documentation, or NULL if it
 *   does not exist.
 */
function api_object_load($object_name_or_did, $branch, $object_type, $file_name = NULL) {
  static $cache;

  if (!is_array($object_type)) {
    $object_type = array($object_type);
  }
  $key = $object_name_or_did . ':' . implode('-', $object_type) . ':' . $branch->branch_id . ':' . $file_name;

  // See if we have this cached.
  if (isset($cache[$key])) {
    return $cache[$key];
  }

  // We don't have a cached value. Prepare the query.
  $query = db_select('api_documentation', 'ad');
  $ao = $query->leftJoin('api_overrides', 'ao', 'ao.did = ad.did');
  $query->fields('ad');
  $ao_documented_did = $query->addField($ao, 'documented_did');
  $ao_overrides_did = $query->addField($ao, 'overrides_did');
  $ao_root_did = $query->addField($ao, 'root_did');
  $query->condition('ad.object_type', $object_type)
    ->condition('ad.branch_id', $branch->branch_id);

  if (is_int($object_name_or_did)) {
    $query->condition('ad.did', $object_name_or_did);
  }
  else {
    $query->condition('ad.object_name', $object_name_or_did);
  }

  if (!is_null($file_name)) {
    $query->condition('ad.file_name', $file_name);
  }

  if (in_array('function', $object_type)) {
    $afunc = $query->leftJoin('api_function', 'afunc', 'afunc.did = ad.did');
    $af_signature = $query->addField($afunc, 'signature');
    $af_params = $query->addField($afunc, 'parameters');
    $af_return = $query->addField($afunc, 'return_value');
  }
  elseif (in_array('file', $object_type)) {
    $afile = $query->leftJoin('api_file', 'afile', 'afile.did = ad.did');
    $af_modified = $query->addField($afile, 'modified');
    $af_queued = $query->addField($afile, 'queued');
  }

  // Execute the query, and store in cache if it's successful.
  $query = $query->range(0,1);
  $result = $query->execute();
  $result_object = NULL;
  foreach($result as $result_object) {
    // Grab documentation from documented parent.
    if (!empty($result_object->documented_did) && $result_object->documented_did !== $result_object->did) {
      $documented_object = api_object_load((int) $result_object->documented_did, $branch, $object_type);
      if (isset($documented_object)) {
        foreach (array('documentation', 'parameters', 'return_value', 'see', 'throws', 'var') as $member) {
          $result_object->$member = $documented_object->$member;
        }
      }
    }
    // Store in the cache.
    $cache[$key] = $result_object;
    return $result_object;
  }

  return NULL;
}

/**
 * Implements hook_permission().
 */
function api_permission() {
  return array(
    'access API reference' => array(
      'title' => t('Access API reference pages'),
    ),
    'administer API reference' => array(
      'title' => t('Administer API reference'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function api_theme() {
  return array(
    'api_branch_table' => array(
      'render element' => 'element',
    ),
    'api_defined' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-defined',
      'file' => 'api.theme.inc',
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_defined'),
    ),
    'api_related_topics' => array(
      'variables' => array(
        'topics' => array(),
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-related-topics',
    ),
    'api_functions' => array(
      'variables' => array(
        'functions' => array(),
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-functions',
    ),
    'api_function_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'signatures' => NULL,
        'documentation' => NULL,
        'parameters' => NULL,
        'return' => NULL,
        'related_topics' => NULL,
        'call_links' => array(),
        'code' => NULL,
        'see' => NULL,
        'throws' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-function-page',
      'file' => 'api.theme.inc',
    ),
    'api_constant_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-constant-page',
      'file' => 'api.theme.inc',
    ),
    'api_global_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-global-page',
      'file' => 'api.theme.inc',
    ),
    'api_property_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
        'var' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-property-page',
      'file' => 'api.theme.inc',
    ),
    'api_class_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'implements' => NULL,
        'hierarchy' => NULL,
        'objects' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-class-page',
      'file' => 'api.theme.inc',
    ),
    'api_file_page' => array(
      'variables' => array(
        'object' => NULL,
        'documentation' => NULL,
        'objects' => NULL,
        'code' => NULL,
        'see' => NULL,
        'related_topics' => NULL,
        'defined' => '',
        'call_links' => array(),
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-file-page',
      'file' => 'api.theme.inc',
    ),
    'api_group_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'objects' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-group-page',
      'file' => 'api.theme.inc',
    ),
    'api_branch_default_page' => array(
      'variables' => array(
        'branch' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-branch-default-page',
    ),
    'api_function_reference_link' => array(
      'variables' => array(
        'type' => '',
        'count' => 0,
        'function' => (object) array(),
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'file' => 'api.theme.inc',
    ),
  );
}

/**
 * Saves or returns a string to use for the HTML page title.
 *
 * @param $title
 *   If provided, stores this as the page title string.
 *
 * @return
 *   The previously-set page title, or NULL if it has not been set during
 *   this page load.
 */
function api_set_html_page_title($title = NULL) {
  static $page_title = NULL;

  if (isset($title)) {
    $page_title = $title;
  }

  return $page_title;
}

/**
 * Implements hook_preprocess_HOOK() for html.tpl.php.
 *
 * Sets the page title if it's an API module page.
 */
function api_preprocess_html(&$variables) {
  $title = api_set_html_page_title();
  if ($title) {
    $variables['head_title'] = $title;
  }
}

/**
 * Implements hook_init().
 *
 * Adds CSS and JavaScript for the search auto-complete. Adds OpenSearch
 * autodiscovery links. Redirects nodes of type 'api' to the correct URL.
 */
function api_init() {
  $branch = api_get_active_branch();
  if (isset($branch)) {
    drupal_add_js(array('apiAutoCompletePath' => base_path() . variable_get('api_autocomplete_path_' . $branch->branch_name, 'api/autocomplete/' . $branch->branch_name)), array('type' => 'setting', 'scope' => JS_DEFAULT));
  }

  // Add OpenSearch autodiscovery links.
  foreach (api_get_branch_names() as $branch_name) {
    $title = t('Drupal API @branch', array('@branch' => $branch_name));
    $url = url('api/opensearch/' . $branch_name, array('absolute' => TRUE));
    drupal_add_html_head('<link rel="search" type="application/opensearchdescription+xml" href="' . $url . '" title="' . $title . '" />', 'api_opensearch_' . $branch_name);
  }

  // If we happen to be on an API node page, redirect.
  if (($node = menu_get_object('node')) && $node->type == 'api') {
    $result = db_select('api_documentation', 'd')
      ->fields('d', array('branch_id', 'object_type', 'file_name', 'object_name'))
      ->condition('did', $node->nid)
      ->range(0,1)
      ->execute();
    foreach ($result as $documentation) {
      drupal_goto(api_url($documentation));
    }
  }
}

/**
 * Implements hook_query_TAG_alter() for node_access queries.
 *
 * Excludes nodes of type 'api' from node queries.
 */
function api_query_node_access_alter($query) {
  // Find all instances of the 'node' table, and make sure they exclude API
  // nodes.
  $tables = $query->getTables();
  foreach ($tables as $alias => $table_info) {
    if (is_array($table_info) && isset($table_info['table']) && $table_info['table'] == 'node') {
      $query->condition($alias . '.type', 'api', '<>');
    }
  }
}

/**
 * Implements hook_block_info().
 */
function api_block_info() {
  return array(
    'api-search' => array(
      'info' => t('API search'),
      'cache' => DRUPAL_CACHE_PER_PAGE,
    ),
    'navigation' => array(
      'info' => t('API navigation'),
      'cache' => DRUPAL_CACHE_PER_PAGE,
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function api_block_view($delta) {
  $branch = api_get_active_branch();

  switch ($delta) {
    case 'api-search':
      if (user_access('access API reference') && !empty($branch)) {
        return array(
          'subject' => t('Search @branch', array('@branch' => $branch->branch_name)),
          'content' => drupal_get_form('api_search_form', $branch),
        );
      }
      return;

    case 'navigation':
      if (user_access('access API reference') && !empty($branch)) {
        // Figure out if this is the default branch for this project, the same
        // way the menu system decides.

        $default_branch = api_get_branch_by_id();
        $projects = _api_make_menu_projects();
        $is_default = ($branch->branch_name === $projects[$branch->project]['use branch']);
        $suffix = ($is_default) ? '' : '/' . $branch->branch_name;

        $links = array();
        $links[] = l($branch->title, 'api/' . $branch->project . $suffix);
        $counts = api_listing_counts($branch);
        if ($counts['constants'] > 0) {
          $links[] = l(t('Constants'), 'api/' . $branch->project . '/constants' . $suffix);
        }
        if ($counts['classes'] > 0) {
          $links[] = l(t('Classes'), 'api/' . $branch->project . '/classes' . $suffix);
        }
        if ($counts['files'] > 0) {
          $links[] = l(t('Files'), 'api/' . $branch->project . '/files' . $suffix);
        }
        if ($counts['functions'] > 0) {
          $links[] = l(t('Functions'), 'api/' . $branch->project . '/functions' . $suffix);
        }
        if ($counts['globals'] > 0) {
          $links[] = l(t('Globals'), 'api/' . $branch->project . '/globals' . $suffix);
        }
        if ($counts['groups'] > 0) {
          $links[] = l(t('Topics'), 'api/' . $branch->project . '/groups' . $suffix);
        }

        return array(
          'subject' => t('API Navigation'),
          'content' => theme('item_list', array('items' => $links)),
        );
      }
      return;
  }
}

/**
 * Counts items by type for a branch.
 *
 * @param $branch
 *   Object representing the branch to count.
 *
 * @return
 *   Associative array where the keys are the type of listing ('functions',
 *   'classes', etc.) and the values are the count of how many there are in
 *   that listing for the given branch.
 */
function api_listing_counts($branch) {

  static $cached_counts = array();

  // Check the cache.
  $key = $branch->branch_name . $branch->branch_id;
  if (isset($cached_counts[$key])) {
    return $cached_counts[$key];
  }

  $return = array(
    'groups' => 0,
    'classes' => 0,
    'functions' => 0,
    'constants' => 0,
    'globals' => 0,
    'files' => 0,
  );

  // These queries mirror what is done in api_page_listing().
  $return['groups'] = db_select('api_documentation', 'ad')
    ->condition('branch_id', $branch->branch_id)
    ->condition('object_type', 'group')
    ->groupBy('branch_id')
    ->countQuery()
    ->execute()
    ->fetchField();

  $return['classes'] = db_select('api_documentation', 'ad')
    ->condition('branch_id', $branch->branch_id)
    ->condition('object_type', array('class', 'interface'))
    ->condition('class_did', 0)
    ->groupBy('branch_id')
    ->countQuery()
    ->execute()
    ->fetchField();

  foreach (array('function', 'constant', 'global', 'file') as $type) {
    $return[$type . 's'] = db_select('api_documentation', 'ad')
      ->condition('branch_id', $branch->branch_id)
      ->condition('object_type', $type)
      ->condition('class_did', 0)
      ->groupBy('branch_id')
      ->countQuery()
      ->execute()
      ->fetchField();
  }

  $cached_counts[$key] = $return;
  return $return;
}

/**
 * Implements hook_filter_info().
 */
function api_filter_info() {
  return array(
    'api_filter' => array(
      'title' => t('API filter'),
      'description' => t('Add links to API objects, like theme() or theme.inc.'),
      'process callback' => 'api_filter_documentation'
    ),
  );
}

/**
 * Implements hook_forms().
 *
 * Since the 'api' content type is hidden, do what comment_forms() does so
 * that the comment form will work.
 */
function api_forms() {
  $forms = array();
  $forms['comment_node_api_form']['callback'] = 'comment_form';
  return $forms;
}

/**
 * Constructs a link to an API object page.
 *
 * Constructs a URL for an object, replacing any API_FILEPATH_SEPARATOR in a
 * file path with API_FILEPATH_SEPARATOR_REPLACEMENT.
 *
 * @param $object
 *   An API object with object_type, object_name, and file_name properties.
 * @param $file
 *   TRUE links to the object’s containing file, FALSE links to the object
 *   itself.
 *
 * @return
 *   A URL string, or an empty string if there was a problem.
 */
function api_url($object, $file = FALSE) {
  $branch = api_get_branch_by_id($object->branch_id);
  if (!$branch) {
    return '';
  }

  if ($file) {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->file_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $branch->branch_name;
  }
  elseif ($object->object_type === 'file') {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->object_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $branch->branch_name;
  }
  else {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->file_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $object->object_type . '/' . $object->object_name . '/' . $branch->branch_name;
  }
}

/**
 * Saves an API branch.
 *
 * @param $branch
 *   A branch object, with branch_name, title, and directories properties.
 */
function api_save_branch($branch) {
  $branch->data = serialize($branch->data);
  if (empty($branch->branch_id)) {
    drupal_write_record('api_branch', $branch);
    if (is_null(variable_get('api_default_branch', NULL))) {
      variable_set('api_default_branch', $branch->branch_id);
    }
  }
  else {
    drupal_write_record('api_branch', $branch, 'branch_id');
  }

  // Reweight all branches.
  api_get_branch_names(TRUE);
  $branches = api_get_branches(TRUE);
  usort($branches, 'api_branch_sort');
  $weight = 0;
  foreach ($branches as $branch) {
    $branch->weight = $weight;
    $weight += 1;
    drupal_write_record('api_branch', $branch, 'branch_id');
  }

  menu_rebuild();
}

/**
 * Sorts branches by type, version number, and branch name.
 *
 * Callback for usort() within api_save_branch().
 */
function api_branch_sort($a, $b) {
  // PHP type branches should come after file type branches.
  $result = strcmp($a->type, $b->type);
  if ($result != 0) {
    return $result;
  }
  // Sort by numeric version number next.
  $result = version_compare($a->branch_name, $b->branch_name);
  if ($result != 0) {
    return $result;
  }

  // If they are the same type and version_compare said they were the same,
  // then just do alphabetical.
  return strcasecmp($a->branch_name, $b->branch_name);
}

/**
 * Returns the currently active branch object.
 */
function api_get_active_branch() {
  static $branch;

  if (!isset($branch)) {
    $item = menu_get_item();
    $branches = api_get_branches();
    $branch_names = api_get_branch_names();
    $default_branch = variable_get('api_default_branch', NULL);
    if (isset($item['page_arguments'][0]->branch_id)) {
      $branch = $branches[$item['page_arguments'][0]->branch_id];
    }
    elseif (isset($item['page_arguments'][0]->branch_name)) {
      $branch = $item['page_arguments'][0];
    }
    elseif (strpos($item['path'], 'api/search') === 0 && isset($branch_names[$item['page_arguments'][0]])) {
      // Search page, use the default project if possible
      foreach ($branches as $possible_branch) {
        if ($possible_branch->project === $branches[$default_branch]->project && $possible_branch->branch_name === $item['page_arguments'][0]) {
          $branch = $possible_branch;
        }
      }
    }
    if (!isset($branch)) {
      if (!is_null($default_branch)) {
        $branch = $branches[$default_branch];
      }
      else {
        $branch = NULL;
      }
    }
  }

  return $branch;
}

/**
 * Form constructor for the API search form.
 *
 * @param $branch
 *   Object representing the branch to build the search form for.
 *
 * @see api_search_form_submit()
 */
function api_search_form($form, $form_state, $branch) {
  $form['#attributes']['class'] = 'api-search-form';
  $form['#branch'] = $branch;

  $form['search'] = array(
    '#title' => t('Function, file, or topic'),
    '#type' => 'textfield',
    '#default_value' => '',
    '#required' => TRUE,
    '#attributes' => array('class' => array('api-search-keywords')),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );

  return $form;
}

/**
 * Form submission handler for api_search_form().
 */
function api_search_form_submit($form, &$form_state) {
  $form_state['redirect'] = 'api/search/' . $form['#branch']->branch_name . '/' . $form_state['values']['search'];
}

/**
 * Prepares a listing of documentation objects for a branch.
 *
 * @param $branch_name
 *   Name of the branch to list.
 * @param $page
 *   TRUE if this will be embedded in a page, and FALSE if it is an AHAH
 *   callback.
 *
 * @return
 *   JavaScript listing of all the objects in the branch.
 */
function api_autocomplete($branch_name, $page = TRUE) {
  $query = db_select('api_documentation', 'ad')
    ->fields('ad', array('title', 'object_type'));
  $b = $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
  $query->condition($b . '.branch_name', $branch_name)
    ->condition('ad.object_type', 'mainpage', '<>')
    ->orderBy('ad.title');
  $result = $query->execute();
  $objects = array();
  foreach ($result as $object) {
    $objects[] = $object->title;
  }

  $objects = array_values(array_unique($objects));
  if ($page) {
    drupal_json_output($objects);
  }
  else {
    return drupal_json_encode($objects);
  }
}

/**
 * Implements hook_cron().
 */
function api_cron() {
  module_load_include('inc', 'api', 'parser');
  api_update_all_branches();
}

/**
 * Turns function names into links in code.
 *
 * @param $code
 *   PHP code to scan for function names.
 * @param $branch
 *   Branch to make the links in.
 * @param $class_did
 *   Documentation ID of the class the code is in (if any).
 *
 * @return
 *   Code with function names formatted as links.
 */
function api_link_code($code, $branch, $class_did = NULL) {
  return _api_link_documentation($code, $branch, $class_did, array('code hook name', 'code alter hook name', 'code theme hook name', 'code function', 'code member', 'code string'));
}

/**
 * Turns function names into links in documentation.
 *
 * @param $documentation
 *   Documentation to scan for function names.
 * @param $branch
 *   Branch to make the links in.
 * @param $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @param $aggressive_classes
 *   Try linking every word with a capital letter to a class or interface, if
 *   TRUE.
 *
 * @return
 *   Documentation with function names formatted as links.
 */
function api_link_documentation($documentation, $branch, $class_did = NULL, $aggressive_classes = FALSE) {
  $filter = new StdClass();
  $filter->callback = '_filter_url';
  $filter->settings = array( 'filter_url_length' => 72);

  return _filter_url(api_filter_documentation($documentation, $branch, $class_did, $aggressive_classes), $filter);
}

/**
 * Turns function names into links for a text filter.
 *
 * This is the process callback for the API filter supplied by api_filter().
 * It turns function names into links on output, using the currently active
 * branch.
 *
 * @param $text
 *   Text to filter.
 * @param $branch
 *   Branch object to use for links.
 * @param $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @param $aggressive_classes
 *   Try linking every word with a capital letter to a class or interface, if
 *   TRUE.
 *
 * @return
 *   Text with function names turned into links.
 */
function api_filter_documentation($text, $branch = NULL, $class_did = NULL, $aggressive_classes = FALSE) {
  if (is_null($branch)) {
    $branch = api_get_active_branch();
  }

  // Remove escaping from \@.
  $stages = array('tags', 'link', 'function', 'file', 'constant');
  if ($aggressive_classes) {
    $stages[] = 'class';
  }
  return preg_replace('!\\\@!', '@', _api_link_documentation($text, $branch, $class_did, $stages));
}

/**
 * Recursive internal callback for turning function names into links in code.
 *
 * @param $documentation
 *   PHP code to scan for function names.
 * @param $branch
 *   Branch to make the links in.
 * @param $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @stages
 *   Array of stages to process.
 *
 * @return
 *   Code with function names formatted as links.
 *
 * @see api_link_code()
 * @see api_link_name()
 */
function _api_link_documentation($documentation, $branch, $class_did = NULL, $stages = array()) {

  $stage = array_shift($stages);

  $callback_match = 'api_link_name';
  $prepend = '';
  $append = '';
  $prepend_if_not_found = NULL;
  $use_php = TRUE;
  $type = '';
  $pattern = '';

  switch ($stage) {
    case 'tags':
      // Find HTML tags, not filtered.
      $callback_match = NULL;
      $pattern = '/(<[^>]+?' . '>)/';
      break;

    case 'link':
      // Find @link.
      $pattern = '/' . API_RE_TAG_START . 'link\s+(.*)\s+' . API_RE_TAG_START . 'endlink/U';
      $callback_match = 'api_link_link';
      break;

    case 'function':
      // Find function names, which are preceded by white space and followed by
      // '('.
      $append = '(';
      $pattern = '!(?<=^|\s)(' . API_RE_FUNCTION_IN_TEXT . ')\(!';
      $type = 'function';
      break;

    case 'code function':
      // Find function names in marked-up code.
      $pattern = '!<span class="php-function-or-constant">(' . DRUPAL_PHP_FUNCTION_PATTERN . ')</span>!';
      $prepend = '<span class="php-function-or-constant">';
      $append = '</span>';
      break;

    case 'code string':
      // Find potential function names (callback strings) in marked-up code.
      // These are all strings that are legal function names, where the function
      // name is put into something like a hook_menu() page callback as a
      // string.
      $pattern = '!<span class="php-string">\'(' . DRUPAL_PHP_FUNCTION_PATTERN . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'function';
      break;

    case 'code hook name':
      // Find potential hook names in marked-up code. These are strings that
      // are legal function names, which were found in parsing to be inside
      // module_implements() and related functions.
      $pattern = '!<span class="php-string potential-hook">\'(' . API_RE_HOOK_NAME . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'hook';
      break;

    case 'code alter hook name':
      // Works like 'code hook name' above, but for alter hooks.
      $pattern = '!<span class="php-string potential-alter">\'(' . API_RE_HOOK_NAME . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'alter hook';
      break;

    case 'code theme hook name':
      // Works like 'code hook name' above, but for theme hooks.
      $pattern = '!<span class="php-string potential-theme">\'(' . DRUPAL_PHP_FUNCTION_PATTERN . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'theme';
      break;

    case 'code member':
      // Works like 'code hook name' above, but for class members.
      $callback_match = 'api_link_member_name';
      $pattern = '!(<span class="php-function-or-constant [^"]+ member-of-[^"]+">' . DRUPAL_PHP_FUNCTION_PATTERN . '</span>)!';
      break;

    case 'file':
      // Find file names, which are an arbitrary number of strings joined with
      // '.'
      $pattern = '%(?<=^|\s|\()' . API_RE_FILENAME . '(?=$|\s|[.,:;?!\)])%';
      $type = 'file';
      break;

    case 'constant':
      // Find constants, UPPERCASE_LETTERS_WITH_UNDERSCORES.
      $pattern = '/\b([A-Z_]+)\b/';
      $type = 'constant';
      break;

    case 'class':
      // Find class names, which have a capital letter.
      $pattern = '/\b(' . API_RE_CLASS_NAME_TEXT . ')\b/';
      $type = 'class';
      break;
  }

  if (count($stages) > 0) {
    $callback = '_api_link_documentation';
  }
  else {
    $callback = NULL;
  }

  return api_split($pattern, $documentation, $callback_match, array($branch, $prepend, $append, $class_did, NULL, NULL, $use_php, $prepend_if_not_found, NULL, $type), $callback, array($branch, $class_did, $stages));
}

/**
 * Splits a string using a regular expression and processes using callbacks.
 *
 * @param $pattern
 *   The regular expression to match for splitting.
 * @param $subject
 *   The string to process.
 * @param $callback_match
 *   Function name to be called for text which matches $pattern. The first
 *   argument will be the parenthesized expression in the pattern. Should
 *   return a string. NULL to pass the text through unchanged.
 * @param $callback_match_arguments
 *   An array of additional parameters for $callback_match.
 * @param $callback
 *   Function name to be called for text which does not match $pattern. The
 *   first argument will be the text. Should return a string. NULL to pass the
 *   text through unchanged.
 * @param $callback_arguments
 *   An array of additional parameters for $callback.
 *
 * @return
 *   The original string, with both matched and unmatched portions filtered by
 *   the appropriate callbacks.
 */
function api_split($pattern, $subject, $callback_match = NULL, $callback_match_arguments = array(), $callback = NULL, $callback_arguments = array()) {
  $return = '';
  $matched = FALSE;
  foreach (preg_split($pattern . 'sm', $subject, -1, PREG_SPLIT_DELIM_CAPTURE) as $part) {
    if ($matched) {
      if (is_null($callback_match)) {
        $return .= $part;
      }
      else {
        $return .= call_user_func_array($callback_match, array_merge(array($part), $callback_match_arguments));
      }
    }
    else {
      if (is_null($callback)) {
        $return .= $part;
      }
      else {
        $return .= call_user_func_array($callback, array_merge(array($part), $callback_arguments));
      }
    }
    $matched = !$matched;
  }
  return $return;
}

/**
 * Links an object name to its documentation.
 *
 * @param $name
 *   Object name to link to.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Text to prepend on the link.
 * @param $append
 *   Text to append on the link.
 * @param $class_did
 *   (unused) Documentation ID of the class this is part of (if any).
 * @param $text
 *   Link text. If omitted, uses $name.
 * @param $is_link
 *   TRUE if this was inside a @link.
 * @param $use_php
 *   TRUE if links to PHP functions should be made; FALSE if only Drupal
 *   objects.
 * @param $prepend_if_not_found
 *   Text to prepend if object is not found (defaults to $prepend).
 * @param $append_if_not_found
 *   Text to append if object is not found (defaults to $append).
 * @param $type
 *   The type of information $name represents. Possible values:
 *   - '': (default) $name is a normal object name.
 *   - 'hook': $name is a hook name.
 *   - 'alter hook': $name is an alter hook name.
 *   - 'theme': $name is a theme hook name.
 *   - 'function': $name is specifically a function ('file', 'constant', etc.
 *     also are supported).
 *
 * @return
 *   The text as a link to the object page.
 */
function api_link_name($name, $branch, $prepend = '', $append = '', $class_did = NULL, $text = NULL, $is_link = FALSE, $use_php = TRUE, $prepend_if_not_found = NULL, $append_if_not_found = NULL, $type = '') {

  if (is_null($text)) {
    $text = $name;
  }

  if ($is_link) {
    // See if this is a link to a group/topic.
    $query = db_select('api_documentation', 'ad')
      ->fields('ad', array('did', 'branch_id', 'object_name', 'title', 'object_type', 'summary', 'file_name'))
      ->condition('ad.branch_id', $branch->branch_id)
      ->condition('ad.object_name', $name)
      ->condition('ad.object_type', 'group');
    $result = $query->execute();
    foreach ($result as $object) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($object->object_name == $name) {
        // Note: Use html = TRUE here because the @link stuff was check_plained
        // during parsing. If we run it through check_plain() again, we get
        // double encoding of entities.
        return $prepend . l($text, api_url($object), array('attributes' => array('title' => api_entity_decode($object->summary), 'class' => array('local')), 'html' => TRUE)) . $append;
      }
    }

    // See if it could be a file name being linked.
    $query = db_select('api_documentation', 'ad')
      ->fields('ad', array('did', 'branch_id', 'object_name', 'title', 'object_type', 'summary', 'file_name', 'object_name'));
    $af = $query->innerJoin('api_file', 'af', 'ad.did = af.did');
    $basename = $query->addField($af, 'basename', 'match_name');
    $query->condition('ad.branch_id', $branch->branch_id)
      ->condition($af . '.basename', $name)
      ->condition('ad.object_type', 'file');
    $result = $query->execute();
    foreach ($result as $object) {
      if ($object->$basename == $name) {
        return $prepend . l($text, api_url($object), array('attributes' => array('title' => api_entity_decode($object->summary), 'class' => array('local')), 'html' => TRUE)) . $append;
      }
    }
  }

  // If we get here, we're looking to match some kind of documentation object.
  $query = db_select('api_documentation', 'ad')
    ->fields('ad', array('did', 'branch_id', 'object_name', 'title', 'object_type', 'summary', 'file_name'))
    ->condition('ad.branch_id', $branch->branch_id);
  $match_name = $query->addField('ad', 'object_name', 'match_name');
  $match_name_field = 'ad.object_name';

  // Figure out what potential names we should match on.
  $potential_names = array($name);
  if ($type == 'hook') {
    $potential_names = array(
      'hook_' . $name,
      'hook_field_' . $name,
      'field_default_' . $name,
      'hook_user_' . $name,
    );
    $query->condition('ad.object_type', 'function');
  }
  elseif ($type == 'alter hook') {
    $potential_names = array('hook_' . $name . '_alter');
    $query->condition('ad.object_type', 'function');
  }
  elseif ($type == 'theme') {
    $potential_names = array();
    // Potential matches are the whole theme call, or with stripped off pieces
    // separated by __. And we look for template files preferably over
    // functions.
    $hook_elements = explode('__', $name);
    while (count($hook_elements) > 0) {
      $hook = implode('__', $hook_elements);
      $potential_names[] = str_replace('_', '-', $hook) . '.tpl.php';
      $potential_names[] = 'theme_' . $hook;
      array_pop($hook_elements);
    }
    // Because this needs to match theme files, change the query to match on
    // object title (which is the file base name).
    $query = db_select('api_documentation', 'ad')
      ->fields('ad', array('did', 'branch_id', 'object_name', 'title', 'object_type', 'summary', 'file_name'))
      ->condition('ad.branch_id', $branch->branch_id)
      ->condition('ad.object_type', array('file', 'function'));
    $match_name = $query->addField('ad', 'title', 'match_name');
    $match_name_field = 'ad.title';
  }
  elseif ($type == 'function') {
    $query->condition('ad.object_type', 'function');
  }
  elseif ($type == 'file') {
    // Because this needs to match files, change the query to match on
    // basename field in {api_files}.
    $query = db_select('api_documentation', 'ad')
      ->fields('ad', array('did', 'branch_id', 'object_name', 'title', 'object_type', 'summary', 'file_name'))
      ->condition('ad.branch_id', $branch->branch_id)
      ->condition('ad.object_type', 'file');
    $af = $query->innerJoin('api_file', 'af', 'ad.did = af.did');
    $match_name = $query->addField('af', 'basename', 'match_name');
    $match_name_field = 'af.basename';
  }
  elseif ($type == 'constant') {
    $query->condition('ad.object_type', 'constant');
  }
  elseif ($type == 'class') {
    $query->condition('ad.object_type', array('class', 'interface'));
  }

  $query->condition($match_name_field, $potential_names);
  $results = $query->execute();
  $url = NULL;
  $options = array();
  $url_name_matched = '';
  foreach ($results as $object) {
    // MySQL is not case-sensitive, so check the match for exact string.
    $matched = $object->match_name;
    if (!in_array($matched, $potential_names)) {
      continue;
    }

    // See if this matched name takes precidence over the previous one.
    $priority = _api_match_priority($matched, $url_name_matched);

    if (isset($url) && $priority == 0) {
      // This is the second match at same priority, so make this a search.
      $url = 'api/search/' . $branch->branch_name . '/' . $matched;
      $options = array(
        'attributes' => array(
          'title' => t('Multiple implementations exist.'),
          'class' => array('local'),
        ),
      );
    }
    else if ($priority > 0) {
      $url = api_url($object);
      $options = array(
        'attributes' => array(
          'title' => api_entity_decode($object->summary),
          'class' => array('local'),
        ),
      );
      $url_name_matched = $matched;
    }
  }

  // See if we found a match.
  if (isset($url)) {
    return $prepend . l($text, $url, $options) . $append;
  }

  // If we get here, there wasn't a match. Try PHP functions.
  if ($use_php) {
    $query = db_select('api_php_documentation', 'd')
      ->fields('d', array('object_name', 'documentation'));
    $b = $query->innerJoin('api_branch', 'b', "b.branch_id = d.branch_id");
    $data = $query->addField($b, 'data');
    $query->condition('d.object_type', 'function')
      ->condition('d.object_name', $name);
    $result = $query->execute();
    foreach ($result as $info) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($info->object_name != $name) {
        continue;
      }

      $data = unserialize($info->data);
      $link = strtr($data['path'], array('!function' => $name));
      return $prepend . l($text, $link, array('attributes' => array('title' => api_entity_decode($info->documentation), 'class' => array('php-manual')))) . $append;
    }
  }

  // If we get here, there still wasn't a match, so return non-linked text.
  if (isset($prepend_if_not_found)) {
    $prepend = $prepend_if_not_found;
  }
  if (isset($append_if_not_found)) {
    $append = $append_if_not_found;
  }

  return $prepend . $text . $append;
}

/**
 * Checks if the name found has higher or lower priority than previous match.
 *
 * Helper function for api_link_name(), to distinguish between theme functions
 * and theme templates.
 *
 * @param $current
 *   Current matched string.
 * @param $previous
 *   Previous matched string.
 *
 * @return
 *   1 if previous is empty or current has higher priority. 0 if they have
 *   the same priority. -1 if current has lower priority.
 */
function _api_match_priority($current, $previous) {
  if (strlen($previous) == 0) {
    return 1;
  }
  if ($current == $previous) {
    return 0;
  }

  // Theme templates have higher priority than theme functions.
  $current_is_theme_function = (strpos($current, 'theme_') === 0);
  $current_is_theme_template = (strpos($current, '.tpl.php') === strlen($current) - 8);
  $previous_is_theme_function = (strpos($previous, 'theme_') === 0);
  $previous_is_theme_template = (strpos($previous, '.tpl.php') === strlen($previous) - 8);
  if ($current_is_theme_function && $previous_is_theme_template) {
    return -1;
  }
  if ($current_is_theme_template && $previous_is_theme_function) {
    return 1;
  }

  // Prefer the shorter item.
  if (strlen($current) < strlen($previous)) {
    return 1;
  }
  if (strlen($previous) < strlen($current)) {
    return -1;
  }
  // All things being equal...
  return 0;
}

/**
 * Links text to an appropriate class member variable, constant, or function.
 *
 * @param $text
 *   Text matched by the regular expression.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Unused.
 * @param $append
 *   Unused.
 * @param $class_did
 *   Documentation ID of the class this is part of (if any).
 */
function api_link_member_name($text, $branch, $prepend = '', $append = '', $class_did = NULL) {

  // The pattern matched to get here contains the entire span with all of its
  // classes. Parse it out.
  $matches = array();
  preg_match('!<span class="php-function-or-constant ([^"]+) member-of-([^"]+)">(' . DRUPAL_PHP_FUNCTION_PATTERN . ')</span>!', $text, $matches);
  $name = $matches[3];
  $member_type = $matches[2];
  $object_type = $matches[1];

  if ($object_type == 'function') {
    $object_type_where = " AND ad.object_type = 'function'";
  }
  else {
    $object_type_where = " AND ad.object_type <> 'function'";
  }
  $prepend = '<span class="php-function-or-constant">';
  $append = '</span>';

  // Figure out what class we're looking for a member of, and build a query.
  // $member_type is one of: parent, self, variable, or class-NAME.
  $result = NULL;

  if ($member_type == 'parent') {
    // We're looking for a member of the parent class. Find the class doc ID.
    $query = db_select('api_reference_storage', 'ars');
    $ad = $query->innerJoin('api_documentation', 'ad', 'ad.did = ars.to_did');
    $did = $query->addField($ad, 'did');
    $query->condition('ars.from_did', $class_did)
      ->condition('ars.object_type', 'class');
    $item = $query->execute()->fetchObject();
    if ($item) {
      $class_did = $item->did;
      $member_type = 'self';
    }
    else {
      // There is no parent class recorded (probably a built-in PHP class).
      $member_type = 'none';
    }
  }
  elseif (strpos($member_type, 'class-') === 0) {
    // We're looking for a specific class. Find the class doc ID.
    $class_name = substr($member_type, 6);
    $query = db_select('api_documentation', 'ad')
      ->fields('ad', array('did'))
      ->condition('object_type', 'class')
      ->condition('branch_id', $branch->branch_id)
      ->condition('object_name', $class_name);
    $item = $query->execute()->fetchObject();
    if ($item) {
      $class_did = $item->did;
      $member_type = 'self';
    }
    else {
      // Class name doesn't exist (probably a built-in PHP class).
      $member_type = 'none';
    }
  }

  if ($member_type == 'self') {
    // Looking for a member of a particular class. Note that we use the
    // {api_members} table here, since it includes members inherited from
    // parent classes.
    $query = db_select('api_members', 'am');
    $ad = $query->innerJoin('api_documentation', 'ad', 'ad.did = am.did');
    $query->fields('ad', array('branch_id', 'title', 'object_name', 'summary', 'object_type', 'file_name', 'did', 'member_name'))
      ->condition('am.class_did', $class_did)
      ->condition('ad.member_name', $name);

    if ($object_type == 'function') {
      $query->condition('ad.object_type', 'function');
    }
    else {
      $query->condition('ad.object_type', 'function', '<>');
    }

    $result = $query->execute();
  }
  elseif ($member_type == 'variable') {
    // This was some kind of a variable like $foo->member(). So match any member
    // of any class.
    $query = db_select('api_documentation', 'ad');
    $query->fields('ad', array('branch_id', 'title', 'object_name', 'summary', 'object_type', 'file_name', 'did', 'member_name'))
      ->condition('ad.member_name', $name);

    if ($object_type == 'function') {
      $query->condition('ad.object_type', 'function');
    }
    else {
      $query->condition('ad.object_type', 'function', '<>');
    }

    $result = $query->execute();
  }

  // See if we have one result, more than one result, or no results.
  $url = NULL;
  $options = array();
  if (isset($result)) {
    foreach ($result as $object) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($object->member_name != $name) {
        continue;
      }
      if (strlen($url)) {
        // This is the second match, so make this a search.
        $url = 'api/search/' . $branch->branch_name . '/' . $name;
        $options = array(
          'attributes' => array(
            'title' => t('Multiple implementations exist.'),
            'class' => array('local'),
          ),
        );
        break;
      }
      else {
        // This is the first match, make a link.
        $url = api_url($object);
        $options = array(
          'attributes' => array(
            'title' => api_entity_decode($object->summary),
            'class' => array('local'),
          ),
        );
      }
    }

    // See if we found a match.
    if (isset($url)) {
      return $prepend . l($name, $url, $options) . $append;
    }
  }

  // If we got here, we didn't have a match.
  return $prepend . $name . $append;
}

/**
 * Decodes HTML entities.
 *
 * @param $text
 *   Text to decode.
 *
 * @return
 *   Text with all HTML entities decoded.
 */
function api_entity_decode($text) {
  $text = html_entity_decode($text);
  // html_entity_decode does not decode numeric entities, and there are
  // many cases of &#39; (quote) in here.
  $text = str_replace('&#039;', "'", $text);
  $text = str_replace('&#39;', "'", $text);
  return $text;
}

/**
 * Turns text into a link, using the first word as the object name.
 *
 * @param $name
 *   Text to link.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Text to prepend on the link.
 * @param $append
 *   Text to append on the link.
 * @param $class_did
 *   Documentation ID of the class the link is in (if any).
 *
 * @return
 *   The text as a link.
 */
function api_link_link($name, $branch, $prepend = '', $append = '', $class_did = NULL) {
  $words = preg_split('/\s+/', $name);
  $name = array_shift($words);
  return api_link_name($name, $branch, $prepend, $append, $class_did, implode(' ', $words), TRUE);
}

/**
 * Flags a file, branch, or all branches, to be reparsed on the next cron run.
 *
 * @param $branch_or_file
 *   (optional) Identifier or ID number of the branch to reparse, or name of a
 *   single file to reparse. If omitted all branches will be reparsed. File
 *   names must include the path relative to the common path to the directories
 *   indexed by this branch.
 * @param $is_branch_name
 *   If passing in a branch name, set to TRUE so that if it happens to be an
 *   integer, it won't be considered to be a branch ID number by mistake.
 *   Otherwise, just leave this as the default FALSE.
 *
 * @return
 *   Number of files marked for reparsing.
 */
function api_mark_for_reparse($branch_or_file = NULL, $is_branch_name = FALSE) {
  $time_in_past = 52;

  // See if it's a request to reparse everything.
  if (empty($branch_or_file)) {
    return db_update('api_file')
      ->fields(array(
          'modified' => $time_in_past,
        ))
      ->execute();
  }

  // See if it's a request for a particular branch.
  if (!$is_branch_name && is_numeric($branch_or_file) && ($branch_or_file == intval($branch_or_file))) {
    $branch_id = $branch_or_file;
  }
  else {
    $branch_id = db_select('api_branch', 'b')
      ->fields('b', array('branch_id'))
      ->condition('branch_name', $branch_or_file)
      ->execute()
      ->fetchField();
  }

  if (!empty($branch_id)) {
    // Reparse a branch.
    // This is a query using a WHERE EXISTS, and there is no apparent way
    // to write it using the database API, so use ANSI syntax.
    $out = db_query("UPDATE {api_file} SET modified = :mod_time WHERE EXISTS ( SELECT * FROM {api_documentation} d WHERE d.branch_id = :branch_id AND d.object_type = 'file' AND d.did = {api_file}.did )", array(':mod_time' => $time_in_past, ':branch_id' => $branch_id));
    return $out->rowCount();
  }

  // If we get here, it's a request to reparse just one file. So find the file
  // ID, and then request its reparse.
  $did = db_select('api_documentation', 'd')
    ->fields('d', array('did'))
    ->condition('file_name', $branch_or_file)
    ->condition('object_type', 'file')
    ->execute()
    ->fetchField();

  if ($did) {
    $out = db_update('api_file')
      ->fields(array(
          'modified' => $time_in_past,
        ))
      ->condition('did', $did)
      ->execute();

    return $out;
  }

  return 0;
}

/**
 * Parses a queued file.
 *
 * @data
 *   Array of information about the file to be parsed.
 */
function api_queue_parse_file($data) {
  module_load_include('inc', 'api', 'parser');

  api_parse_file($data['parser'], $data['path'], $data['branch'], $data['file']);
  watchdog('api', 'API parse %branch %file', array('%branch' => $data['branch_name'], '%file' => $data['file']));
}

/**
 * Deletes an obsolete JavaScript autocomplete index file.
 *
 * @param $data
 *   Array of infomration about the file to be deleted.
 */
function api_queue_file_delete($data) {
  file_unmanaged_delete($data['path']);
  watchdog('api', 'Remove expired API JSON, %path.', array('%path' => $data['path']));
}

/**
 * Resets the parse queue.
 *
 * Empties all parse jobs from the queue, and sets all files to "unqueued"
 * status.
 */
function api_reset_parse_queue() {
  $queue = DrupalQueue::get('api_parse');
  $queue->deleteQueue();

  db_update('api_file')
    ->fields(array(
        'queued' => 0,
      ))
    ->execute();
}

/**
 * Verifies that the required libraries are loaded.
 *
 * @param $watchdog
 *   TRUE to log an error if the library is not loaded (first time only).
 *
 * @return
 *   TRUE if OK, FALSE if parsing will not work.
 */
function api_libraries_loaded($watchdog = TRUE) {
  static $loaded = NULL;
  if (!is_null($loaded)) {
    return $loaded;
  }

  $library = libraries_load('grammar_parser');
  $loaded = !empty($library['loaded']);
  if ($watchdog && !$loaded) {
    watchdog('api', 'Grammar Parser library is not loaded. Unable to parse files.', array(), WATCHDOG_ERROR);
  }

  return $loaded;
}
