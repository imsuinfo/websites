<?php

/**
 * @file
 * Enable submission and display of categorized web links.
 * Drupal 7 Version
 */

  if (!module_exists('weight')) {
    module_load_include('inc', 'weblinks', 'weblinks.weight');
  }
  if (module_exists('content')) {
    module_load_include('inc', 'weblinks', 'weblinks.cck');
  }

/**
 * Implementation of hook_help().
 */
function weblinks_help($path, $args) {
  switch ($path) {
    case 'admin/modules#description':
    case 'admin/help#weblinks':
      return '<p>'. t('Enables the submission and display of categorized links to other web sites.') .'</p>';

    case 'node/%':
      $node = node_load($args[1]);
      if ($node->type != 'weblinks') {
        return NULL;
      }
      // Fall through to get css.

    case 'weblinks/%':
    case 'weblinks':
      drupal_add_css(drupal_get_path('module', 'weblinks') .'/weblinks.css');
      return theme('weblinks_pagedesc');
  }
}

/**
 * Implementation of hook_permission().
 */
function weblinks_permission() {
  return module_invoke_all('weblinks_permission');
}

/**
 * Implementation of hook_weblinks_permission().
 */
function weblinks_weblinks_permission() {
  return array(
    'access web links' => array(
      'title' => t('Access Web Links'),
      'description' => t('View Web Links'),
    ),
    'create weblinks' => array(
      'title' => t('Create Weblinks'),
      'description' => t('Create Web Links'),
    ),
    'edit own weblinks' => array(
      'title' => t('Edit Own Weblinks'),
      'description' => t('Edit own Web Links'),
    ),
    'view my weblinks' => array(
      'title' => t('View my Weblinks'),
      'description' => t('View my Web Links'),
    ),
    'edit group weblinks' => array(
      'title' => t('Edit Group Weblinks'),
      'description' => t('Edit Web Links Groups'),
    ),
    'administer weblinks' => array(
      'title' => t('Administer Weblinks'),
      'description' => t('Administer Web Links Settings and more'),
    ),
    'view click count' => array(
      'title' => t('view click count'),
      'description' => t('View Web Links Click Count'),
    ),
  );
}

/**
 * Implementation of hook_node_info().
 */
function weblinks_node_info() {
  return array(
    'weblinks' => array(
      'name' => t('Web Links'),
      'description' => t('Web links are pointers to other sites or pages on the Internet.'),
      'has_title' => TRUE,
      'title_label' => t('Link Name'),
      'has_body' => TRUE,
      'body_label' => t('Link Description'),
      'base' => 'weblinks',
    )
  );
}

/**
 * Implementation of hook_init().
 */
function weblinks_init() {
  global $base_path;
  // The menu title is not correct if the menu item has been moved to
  // a menu other than Navigation. See http://drupal.org/node/184955.
  if (arg(0) == 'weblinks') {
    $active_trail = menu_set_active_trail();
    foreach ($active_trail as $key => $item) {
      if (isset($item['link_path'])) {
        if ($item['link_path'] == 'weblinks') {
          $active_trail[$key]['title'] = _weblinks_get_menu_title();
        }
      }
    }
    menu_set_active_trail($active_trail);
  }
}

/**
 * Get the correct menu title.
 * This is a helper function for hook_init and hook_view.
 */
function _weblinks_get_menu_title() {
  return t(db_query("SELECT link_title FROM {menu_links} WHERE link_path = 'weblinks'")->fetchField());
}

/**
 * Retrieve ids of term children.
 *
 * @param $tid
 *   The term's ID.
 * @param $tids
 *   An array where ids of term children will be added
 */
function term_get_children_ids($tid) {
  $children = taxonomy_get_children($tid);
  $tids = array();

  if (!empty($children)) {
    foreach($children as $child) {
      $tids[] = $child->tid;
      $tids = array_merge($tids, term_get_children_ids($child->tid));
    }
  }

  return $tids;
}

/*
 * Retrieve taxonomy node count by Term ID as by taxonomy_term_count_nodes.
 *
 * @param tid
 *   Term ID
 * @param type
 *   Node type
 * @param child_count
 *   TRUE - Also count all nodes in child terms (if they exists) - Default
 *   FALSE - Count only nodes related to Term ID
 */
function weblinks_term_node_count($tid, $type = '', $child_count = TRUE) {
  $tids = array($tid);

  if ($child_count){
    $tids = array_merge($tids, term_get_children_ids($tid));
  }

  global $language;
  $langs = array($language->language);
  $langs[] = 'und';

  $query = db_select('taxonomy_index', 't');
  $query->condition('tid', $tids, 'IN');
  $query->join('node', 'n', 't.nid = n.nid');
  $query->condition('n.status', 1, '=');
  if ($type <> '') {
    $query->condition('n.type', $type, '=');
  }
  $query->condition('n.language', $langs, 'IN');

  $count = $query->countQuery()->execute()->fetchField();
  return $count;
}

/**
 * Display a select box of taxonomy terms.
 * This is a helper function.
 */
function _d7_taxonomy_term_select($title, $name, $value, $vocabulary_id, $description, $multiple, $blank, $exclude = array()) {
  $tree = taxonomy_get_tree($vocabulary_id);
  $options = array();

  if ($blank) {
    $options[''] = $blank;
  }
  if ($tree) {
    foreach ($tree as $term) {
      if (!in_array($term->tid, $exclude)) {
        $choice = new stdClass();
        $choice->option = array($term->tid => str_repeat('-', $term->depth) . $term->name);
        $options[] = $choice;
      }
    }
  }

  return array(
    '#type' => 'select',
    '#title' => $title,
    '#default_value' => $value,
    '#options' => $options,
    '#description' => $description,
    '#multiple' => $multiple,
    '#size' => $multiple ? min(9, count($options)) : 0,
    '#weight' => -5,
    '#theme' => 'select',
   );
}

/**
 * Display a select box of taxonomy terms.
 * This is a helper function for hook_form. See http://drupal.org/node/1204750.
 * Like D6 taxonomy_form.
 */
function d7_taxonomy_form($vid, $value = 0, $help = NULL, $name = 'taxonomy') {
  $vocabulary = taxonomy_vocabulary_load($vid);
  $multiple = false;
  //$help = ($help) ? $help : filter_xss_admin($vocabulary->help);
  $required = false;
  if (!$multiple) {
    $blank = ($required) ? t('- Please choose -') : t('- None selected -');
  }
  else {
    $blank = ($required) ? 0 : t('- None -');
  }
  return _d7_taxonomy_term_select(check_plain($vocabulary->name), $name, $value, $vid, "", intval($multiple), $blank);
}

/**
 * Implementation of hook_form().
 * Validation of the url, if desired, is performed by the weblinks_checker module.
 */
function weblinks_form(&$node) {
  $type = node_type_get_type($node);

  if ($type->has_title) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#maxlength' => 255,
      '#default_value' => $node->title,
      '#weight' => 2,
    );
  }

  /* First attempt to process weblinks term
  if (isset($node->taxonomy)) {
    // Node has an attached taxonomy term
    $form['term'] = d7_taxonomy_form(_weblinks_get_vocid(), $node->taxonomy);
  }
  else {
    // Actions for a non term node
    if (module_exists('taxonomy')) {
      if (variable_get('weblinks_nav_vocabulary', 0) != 0) {
        // Taxonomy exists and a vocabulary is defined
        $form['term'] = d7_taxonomy_form(_weblinks_get_vocid(), 0);
        // TODO: how is select term retrieved and stored?
      }
    }
  }
  */

  /* This is not needed in D7. The body field is handled by the Field API.
  $body = field_get_items('node', $node, 'body');
  if ($body) {
    $items = field_get_items('node', $node, 'body');
    $temp_value = !empty($items['0']['safe_value']) ? $items['0']['safe_value'] : $items['0']['value'];
    $form['body_field'] = field_view_field('node', $node, 'body', array('label'=>'hidden',
                            'type' => 'text_summary_or_trimmed',
                            'settings'=>array('trim_length' => 150), ));  // $type->min_word_count
    $form['body_field']['#rows'] = 5;
    $form['body_field']['#default_value'] = ($temp_value != '') ? $temp_value : variable_get('weblinks_body_stub', '');
    $form['body_field']['#format'] = isset($items['0']['format']) ? $items['0']['format'] : variable_get('weblinks_format', filter_fallback_format());
    $form['body_field']['#weight'] = 1;
  } */

  $form['url'] = array(
    '#type' => 'textarea',
    '#rows' => 2,
    '#title' => t('URL'),
    '#description' => t('Enter a single web address (URL), including the "http://".'),
    '#default_value' => isset($node->url) ? $node->url : variable_get('weblinks_url_stub', 'http://'),
    '#required' => TRUE,
    '#weight' => 1,
  );

  // If the weight module is available, skip this.
  $form['node_weight'] = array(
    '#type' => module_exists('weight') ? 'value' : 'weight',
    '#title' => t('Weight'),
    '#default_value' => isset($node->node_weight) ? $node->node_weight : 0,
    '#description' => t('In listings, the heavier terms (with a larger weight) will sink and the lighter terms will be positioned nearer the top.'),
    '#access' => user_access('administer weblinks'),
    '#required' => !module_exists('weight') ? TRUE : FALSE,
  );

  // Stick our basic validation in before the node module.
  if (isset($form['#validate'])) {
    array_unshift($form['#validate'], 'weblinks_form_validate');
  }
  else {
    $form['#validate'] = array('weblinks_form_validate');
  }

  return $form;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node_form().
 */
function weblinks_form_node_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['taxonomy_weblinks'])) {
    $langcode = $form['taxonomy_weblinks']['#language'];
    if (empty($form['taxonomy_weblinks'][$langcode]['#default_value'])) {
      // If there is no default term already selected, attempt to assign one.
      if (isset($form['#node']->taxonomy)) {
        // Node has an attached taxonomy term
        $requested_weblinks_term = $form['#node']->taxonomy;
      }
      else {
        $requested_weblinks_term = '';
      }
      $form['taxonomy_weblinks'][$langcode]['#default_value'] = $requested_weblinks_term;
    }
  }
}

/**
 * Simple validation for weblinks_form().
 */
function weblinks_form_validate($form, &$form_state) {
  if ($form_state['values']['url'] == variable_get('weblinks_url_stub', 'http://')) {
    form_set_error('url', t('You must enter a complete URL.'));
  }
}

/**
 * Implementation of hook_node_access().
 *
 * Requires to check the node type for own content type.
 *
 */
function weblinks_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : $node->type;

  // Ignore non-Web Links node.
  if ($type !== 'weblinks') {
    return NODE_ACCESS_IGNORE;
  }

  if ($op == 'create') {
    if (user_access('create weblinks', $account))
      return NODE_ACCESS_ALLOW;
  }

  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own weblinks', $account) && ($account->uid == $node->uid)) {
      return  NODE_ACCESS_ALLOW;
    }
    if (user_access('administer weblinks', $account)) {
      return  NODE_ACCESS_ALLOW;
    }
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Implementation of hook_entity_info_alter(). Was hook_term_path().
 *  Replaces the taxonomy term path with one for Weblinks.
 */
function weblinks_entity_info_alter(&$info) {
  // Take over URI construction for taxonomy terms that are weblinks.
  if ($vid = variable_get('weblinks_nav_vocabulary', 0)) {
    // Within hook_entity_info(), we can't invoke entity_load() as that would
    // cause infinite recursion, so we call taxonomy_vocabulary_get_names()
    // instead of taxonomy_vocabulary_load(). All we need is the machine name
    // of $vid, so retrieving and iterating all the vocabulary names is somewhat
    // inefficient, but entity info is cached across page requests, and an
    // iteration of all vocabularies once per cache clearing isn't a big deal,
    // and is done as part of taxonomy_entity_info() anyway.
    foreach (taxonomy_vocabulary_get_names() as $machine_name => $vocabulary) {
      if ($vid == $vocabulary->vid) {
        $info['taxonomy_term']['bundles'][$machine_name]['uri callback'] = 'weblinks_uri';
      }
    }
  }
}

/**
 * URI callback for Web Links terms.
 *
 * @see node_uri()
 */
function weblinks_uri($term) {
  $uri['path'] = 'weblinks/' . $term->tid;
  return $uri;
}

/**
 * Checks whether a node can be used as a weblink, based on its content type.
 *
 * @param $node
 *   A node object.
 *
 * @return
 *   Boolean indicating if the node can be assigned to a weblink.
 */
function _weblinks_node_check_node_type($node) {
  // Fetch information about the weblinks field.
  $field = field_info_instance('node', 'taxonomy_weblinks', $node->type);

  return is_array($field) || ($node->type == 'weblinks');
}

/**
 * Returns the vocabulary id for weblinks navigation.
 *
 * @param none.
 *
 * @return vocid
 *   an integer specifying the vocabulary in use.
 */
function _weblinks_get_vocid() {
  $vocid = variable_get('weblinks_nav_vocabulary', '');
  if (empty($vocid) && function_exists('taxonomy_vocabulary_load')) {
    // Check to see if a weblinks vocabulary exists
    $vocid = db_query("SELECT vid FROM {taxonomy_vocabulary} WHERE module='weblinks'")->fetchField();
    if ($vocid) {
      // We found a vocabulary, so make sure it is associated with our content.
      $vocabulary = taxonomy_vocabulary_load($vocid);
      $vocabulary->nodes = array('weblinks' => 1);  // TBC
      $status = taxonomy_vocabulary_save($vocabulary);
    }
    else {
      // Didn't find one, so create vocabulary from scratch.
      $vocabulary = new stdClass();
      $vocabulary->name = t('Web Links');
      $vocabulary->machine_name = 'weblinks';
      $vocabulary->description = t('Web Links navigation vocabulary');
      $vocabulary->multiple = 1;
      $vocabulary->required = 0;
      $vocabulary->hierarchy = 2;
      $vocabulary->relations = 0;
      $vocabulary->module = 'weblinks';
      $status = taxonomy_vocabulary_save($vocabulary);
      $vocid = $vocabulary->vid;
    }
    variable_set('weblinks_nav_vocabulary', $vocid);
  }
  return $vocid;
}

/**
 * Implementation of hook_insert().
 */
function weblinks_insert($node) {
  if (!isset($node->is_converted) || !$node->is_converted) {
    $node->last_click = NULL;
    $node->click_count = 0;
  }
  weblinks_write($node);
}

/**
 * Generic write function.
 */
function weblinks_write($node) {
  $node->url = strip_tags(trim($node->url));
  $node->urlhash = md5($node->url);
  $node->last_status = $node->last_checked = NULL;
  if ($node->revision || $node->is_new) {
    drupal_write_record('weblinks', $node);
  }
  else {
    drupal_write_record('weblinks', $node, array('nid', 'vid'));
  }
  if (variable_get('weblinks_new_redirect', TRUE)) {
    $_REQUEST['destination'] = 'weblinks';
  }
}

/**
 * Implementation of hook_update().
 */
function weblinks_update($node) {
  if ($node->revision) {
    $node->last_click = NULL;
    $node->click_count = 0;
  }
  weblinks_write($node);
}

/**
 * Implementation of hook_delete().
 */
function weblinks_delete($node) {
  // db_query('DELETE FROM {weblinks} WHERE nid = :nid', array(':nid' => $node->nid));
  db_delete('weblinks')
    ->condition('nid', $node->nid, '=')
    ->execute();
  $_REQUEST['destination'] = 'weblinks';
}

/**
 * Implements hook_node_revision_delete().
 */
function weblinks_node_revision_delete($node) {
  db_query("DELETE FROM {weblinks} WHERE vid = ':vid'", array(':vid' => $node->vid));
}

/**
 * Implements hook_node_load().
 */
function weblinks_node_load($nodes, $types) {
  $result = db_query('SELECT * FROM {node} WHERE nid IN(:nids)', array(':nids' => array_keys($nodes)));
  foreach ($result as $node) {
    if (!module_exists('weight')) {
      weblinks_weight_decode($node);
    }
    if (module_exists('taxonomy')) {
      $tids = db_query("SELECT ti.tid FROM {taxonomy_index} as ti INNER JOIN {node} as n on n.nid=ti.nid
                       WHERE ti.nid = :nid and n.type='weblinks'", array(':nid' => $node->nid))->fetchCol();
      if (!empty($tids)) {
        $nodes[$node->nid]->taxonomy = array();
        foreach ($tids as $tid) {
          $nodes[$node->nid]->taxonomy[$tid] = $tid; // As a quick and dirty solution!
        }
      }
    }
  }
}

/**
 * Implements hook_node_update_index().
 */
function weblinks_node_update_index($node) {
  // Adds URL to the search text search.
  $text = '';
  if (isset($node->url)) {
    $text = '<h2>' . $node->url . '</h2>';
    $parts = parse_url($node->url);
    $pieces = explode('.', $parts['host']);
    if (substr($pieces[0], 0, 3) == 'www') {
      unset($pieces[0]);
    }
    $j = count($pieces);
    for ($i = 0; $i < $j; ++$i) {
      $text .= '<h2>' . implode('.', array_slice($pieces, 0, $i + 1)) . '</h2>';
    }
  }
  return $text;
}

/**
 * Implements hook_node_presave().
 *
 *  Assigns the weblinks taxonomy when adding a term related link.
 */
function weblinks_node_presave($node) {
  if (!module_exists('weight')) {
    // Non-weighted nodes have a weight of zero.
    if (!isset($node->node_weight)) {
      $node->node_weight = 0;
    }
    // Encode weight into the sticky value for the database.
    weblinks_weight_encode($node);
  }

  if (_weblinks_node_check_node_type($node)) {
    // Make sure all fields are set properly:
    if (is_array($node->taxonomy_weblinks)) {
      reset($node->taxonomy_weblinks);
      $langcode = key($node->taxonomy_weblinks);
      if (!empty($node->taxonomy_weblinks[$langcode])) {
        $node->taxonomy = $node->taxonomy_weblinks[$langcode][0]['tid'];
      }
    }
  }
}

/**
 * Implementation of hook_load().
 */
function weblinks_load($nodes) {
  // note that $nodes is an array of object references, keyed by nid
  $obj = db_select('weblinks', 'w')
           ->condition('w.nid', array_keys($nodes), 'IN')
           ->fields('w', array ('nid', 'urlhash', 'url', 'last_status', 'last_checked', 'click_count', 'last_click', 'reciprocal'))
           ->execute();
  // run through each result row and add in the needed attributes
  foreach ($obj as $record) {
    $nodes[$record->nid]->urlhash = $record->urlhash;
    $nodes[$record->nid]->url = $record->url;
    $nodes[$record->nid]->last_status = $record->last_status;
    $nodes[$record->nid]->last_checked = $record->last_checked;
    $nodes[$record->nid]->click_count = $record->click_count;
    $nodes[$record->nid]->last_click = $record->last_click;
    $nodes[$record->nid]->reciprocal = $record->reciprocal;
    if (!module_exists('weight')) {
      weblinks_weight_decode($nodes[$record->nid]);
    }
  }

  // This makes formatting easier.
  // $obj->none = NULL;
}

/**
 * Implementation of hook_view().
 * This formats a viewable link node.
 */
function weblinks_view($node, $view_mode) {
  if ($view_mode == 'full' && node_is_page($node)) {
    // Breadcrumb navigation
    $breadcrumb = array();
    $breadcrumb[] = l(t('Home'), '<front>');

    // See the comments in hook_init.
    $breadcrumb[] = l(_weblinks_get_menu_title(), 'weblinks');

    if (isset($node->taxonomy)) {
      $tids = array_keys($node->taxonomy);
      $parent_links = array();
      foreach ($tids as $tid) {
        if ($parents = taxonomy_get_parents_all($tid)) {
          $parents = array_reverse($parents);
          foreach ($parents as $p) {
            // @@@ $uri = entity_uri('taxonomy_term', $p);
            // @@@ $link = l($p->name, $uri['path']);
            $parent_links[] = l($p->name, 'weblinks/'. $p->tid);
          }
        }
      }
      $breadcrumb[] = implode(' | ', $parent_links);
    }
    drupal_set_breadcrumb($breadcrumb);
  }
  $node->is_teaser = !node_is_page($node);
  $node->content['body']['#markup'] = theme('weblinks_link', array('node' => $node, 'teaser' => ($view_mode == 'teaser')));
  return $node;
}

/**
 * Implementation of hook_preprocess_node().
 */
function weblinks_preprocess_node(&$variables) {
  // We only do this for our content and only on the links page.
  if ($variables['type'] == 'weblinks' && arg(0) == 'weblinks') {
    // Set the node title destination (1 = node, 0 = site).
    if (variable_get('weblinks_title_link', TRUE)) {
      $variables['node_url'] = drupal_get_path_alias('node/'. $variables['nid']);
    }
    else {
      $variables['node_url'] = $variables['weblinks_title_link'];
    }
  }
}

/**
 * Build template variables.
 */
function template_preprocess_weblinks_link(&$variables) {
  $node = $variables['node'];
  node_object_prepare($node);

  $variables['teaser'] = $node->is_teaser;
  $items = field_get_items('node', $node, 'body');
  // $variables['weblinks_body'] = $items['0']['safe_value'];

  // Call all contribs to add to the variables.
  $variables += module_invoke_all('weblinks_preprocess', $node);
  if (!array_key_exists('link_status', $variables)) {
    $variables['link_status'] = NULL; // Link checker not available, fake its output
  }
}

/**
 * Implementation of hook_weblinks_preprocess().
 */
function weblinks_weblinks_preprocess($node) {
  global $user;
  // Making these static means we only need to set them the first time we come here.
  static $description, $urlnode, $admin_weblinks, $edit_group, $options, $dest, $comments, $user_link;
  if (!isset($description)) {
    $description = variable_get('weblinks_linkdesc', 'teaser');
    $admin_weblinks = user_access('administer weblinks');
    $edit_group = user_access('edit group weblinks');
    $dest = drupal_get_destination();
    $user_link = variable_get('weblinks_user_links', FALSE);

    $options = array();
    if ($extra_classes = variable_get('weblinks_extra_classes', '')) {
      $options['attributes']['class'] = $extra_classes;
    }

    if (variable_get('weblinks_external', TRUE)) {
      $options['attributes']['target'] = '_blank';
    }

    if (variable_get('weblinks_nofollow', FALSE)) {
      $options['attributes']['rel'] = 'nofollow';
    }
  }
  $variables = array();

  // Note that drupal_attributes will do a check_plain.
  $options['attributes']['title'] = $node->title;

  if (variable_get('weblinks_title_link', TRUE)) {
    $variables['title'] = l($node->title, 'node/'. $node->nid);
  }
  else {
    $variables['title'] = check_plain($node->title);
  }
  // If this is a full-page view (e.g. node/xxx), then disregard "description" setting.
  if (!$node->is_teaser) {
    $description = 'body';
  }

  if ($items = field_get_items('node', $node, 'body')) {
    $instance = field_info_instance('node', 'body', $node->type);
    $field_langcode = field_language('node', $node, 'body');
    $sanitize = 1;  // Sanitize link description always
  }
  else {
    // There seems to be no body field?!
    $description = 'none';
  }
  switch ($description) {
    case 'none':
      $variables['weblinks_body'] = NULL;
      break;
    case 'teaser':
      if (!empty($items[0]['summary'])) {
        $variables['weblinks_body'] = $sanitize ? _text_sanitize($instance, $field_langcode, $items[0], 'summary') : $items[0]['summary'];
      }
      else {
        if (isset($instance['display']['teaser']['settings']['trim_length'])) {
          $trim_length = $instance['display']['teaser']['settings']['trim_length'];
        }
        else {
          // Use default value.
          $trim_length = NULL;
        }
        $variables['weblinks_body'] = text_summary($items[0]['value'],
                                                   $instance['settings']['text_processing'] ? $items[0]['format'] : NULL, $trim_length);
      }
      break;
    case 'body':
      $variables['weblinks_body'] = $sanitize ? _text_sanitize($instance, $field_langcode, $items[0], 'value') : $items[0]['value'];
      break;
  }
  $variables['link'] = theme('weblinks_node_view', array('node' => $node, 'options' => $options));

  if (user_access('view click count')) {
    $variables['click_count'] = $node->click_count;
    $last_click = strtotime($node->last_click);
    if ($last_click > 0) {
      $variables['last_click'] = format_date($last_click, 'small');
    }
    else {
      $variables['last_click'] = '';
    }
  }

  return $variables;
}

/**
 * Implementation of hook_node_view().
 */
function weblinks_node_view($node, $view_mode, $langcode) {
  global $base_path, $user;
  static $users = array();
  static $user_link, $admin;

  // Make sure it's only our content and on a node page.
  if ($node->type != 'weblinks') {
    return;
  }
  if (arg(0) != 'weblinks') {
    return;  // TBC
  }

  // Check our static variables.
  if (!isset($user_link)) {
    $user_link = variable_get('weblinks_user_links', FALSE);
    $admin = user_access('administer weblinks');
  }

  if ($admin) {
    $dest = drupal_get_destination();
    $links['edit'] = array(
      'title' => t('Edit link'),
      'href' => "node/{$node->nid}/edit",
      'query' => $dest,
      'attributes' => array('class' => array('weblinks-ops')),
      );
    $links['delete'] = array(
      'title' => t('Delete link'),
      'href' => "node/{$node->nid}/delete",
      'query' => $dest,
      'attributes' => array('class' => array('weblinks-ops')),
      );
    $node->content['links']['weblinks'] = array(
      '#theme' => 'links__node',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
     );
  }

  // We don't want the link if we are asking for a specific user.
  // This way we don't see every link on the page saying "xxx's links".
  if ($user_link && $node->uid != $user->uid && !(arg(0) == 'user' && arg(1) == $node->uid))  {
    // Check for correct implementation of theme_username (done by D7 now).
    $name = format_username($node);
    $links['weblinks-user-link'] = array(
      'title' => t("!name's links", array('!name' => $name)),
      'href' => 'weblinks/user/'. $node->uid,
      );
    $node->content['links']['weblinks'] = array(
      '#theme' => 'links__node',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }
}

function _weblinks_add() {
  drupal_goto('node/add/weblinks');
}

function _weblinks_settings() {
  drupal_goto('admin/config/content/weblinks');
}

function _weblinks_links_page() {
  drupal_goto('weblinks');
}

/**
 * Implementation of hook_menu().
 */
function weblinks_menu() {
  $items = array();
  // Full group listing of all weblinks categories.
  $items['weblinks'] = array(
    'title' => 'Web Links',
    'page callback' => 'weblinks_page',
    'access arguments' => array('access web links'),
    'type' => MENU_NORMAL_ITEM,
    ); /* */

  // Main links page.
  $items['weblinks/%weblink_placeholder'] = array(
    'title' => 'Links page',
    'page callback' => 'weblinks_page',
    'page arguments' => array(1),
    'access arguments' => array('access web links'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -5,
    ); /* */

  // Add new link.
  $items['weblinks/add'] = array(
    'title' => 'Add a new link',
    'page callback' => '_weblinks_add',
    'access arguments' => array('create weblinks'),
    'type' => MENU_LOCAL_TASK,
    );

  // Group operations.
  $items['weblinks/group/add'] = array(
    'title' => 'Add a group',
    'page callback' => '_weblinks_group_operations',
    'page arguments' => array(2),
    'access callback' => 'weblinks_group_access',
    'type' => MENU_LOCAL_TASK,
    );

  $items['weblinks/group/edit'] = array(
    'title' => 'Edit a group',
    'page callback' => '_weblinks_group_operations',
    'page arguments' => array(2, 3),
    'access callback' => 'weblinks_group_access',
    'type' => MENU_CALLBACK,
    );

  // Admin settings for the site.
  $items['weblinks/settings'] = array(
    'title' => 'Settings',
    'description' => 'Set a variety of options for web link display and categorization.',
    'page callback' => '_weblinks_settings',
    'access arguments' => array('administer weblinks'),
    'type' => MENU_LOCAL_TASK,
    );

  // Links redirect.
  $items['weblinks/goto/%'] = array(
    'title' => 'Web Links',
    'page callback' => 'weblinks_goto',
    'page arguments' => array(2),
    'access arguments' => array('access web links'),
    'type' => MENU_CALLBACK,
    );

  // User-limited links.
  $items['weblinks/user/%'] = array(
    'title' => 'Web Links',
    'page callback' => '_weblinks_user',
    'page arguments' => array(2),
    'access arguments' => array('access web links'),
    'type' => MENU_CALLBACK,
    );

  // User Edit weblinks
  $items['user/%user/weblinks'] = array(
    'title' => 'Web Links',
    'page callback' => 'weblinks_user_page',
    'page arguments' => array(1),
    'file' => 'weblinks.user.inc',
    'access arguments' => array('view my weblinks'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    );

  // Admin settings for the site.
  $items['admin/config/content/weblinks'] = array(
    'title' => 'Web Links',
    'description' => 'Set a variety of options for web link display and categorization.',
    'page callback' => 'weblinks_settings_page',
    'file' => 'weblinks.admin.inc',
    'access arguments' => array('administer weblinks'),
    'type' => MENU_NORMAL_ITEM,
    );

  $items['admin/config/content/weblinks/general'] = array(
    'title' => 'General',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('weblinks_admin_settings'),
    'file' => 'weblinks.admin.inc',
    'access arguments' => array('administer weblinks'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
    );

  $items['admin/config/content/weblinks/links'] = array(
    'title' => 'Links page',
    'page callback' => '_weblinks_links_page',
    'access arguments' => array('access web links'),
    'file' => 'weblinks.module',
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
    );

  return $items;
}

/**
 * Returns NULL or $arg so to remove PHP notices.
 */
function weblink_placeholder_to_arg($arg) {
  return $arg;
}

/**
 * Determine menu access for group adding/editing.
 */
function weblinks_group_access() {
  return module_exists('taxonomy') && (user_access('administer weblinks') || user_access('edit group weblinks') || user_access('administer taxonomy'));
}

/**
 * Make a dummy term for unclassified links.
 *
 * @param none.
 * @return Pseudo term object.
 */
function _weblinks_unclassed() {
  $noclass = new stdClass();
  $noclass->tid = $noclass->vid = $noclass->depth = 0;
  $noclass->name = variable_get('weblinks_unclassified_title', t('Unclassified'));
  $noclass->description = variable_get('weblinks_unclassified_desc', t('These links have not been assigned a group.'));

  return $noclass;
}

/**
 * Make a dummy term for unpublished links.
 *
 * @param none.
 * @return Pseudo term object.
 */
function _weblinks_unpublished() {
  $noclass = new stdClass();
  $noclass->vid = $noclass->depth = 0;
  $noclass->tid = 'unpublished';
  $noclass->name = variable_get('weblinks_unpublished_title', t('Unpublished'));
  $noclass->description = variable_get('weblinks_unpublished_desc', t('These links are not published and need to be reviewed.'));

  return $noclass;
}

/**
 * Format a group's fieldset.
 *
 * @param $term
 *   the term object being formatted.
 * @param $tree
 *   the entire array of terms (array of objects) - will be used for handling child terms.
 * @return
 *   The formatted HTML string.
 */
function _weblinks_format_group($term, $tree) {
  static $admin;
  if (!isset($admin)) {
    $admin = weblinks_group_access() && arg(0) != 'node';
  }

  $data = $term->image . $term->desc;

  if ($admin && is_numeric($term->tid) && $term->tid !== 0) {
    $data .= '<div class="more-link">'. l(t('Edit group'), 'weblinks/group/edit/'. $term->tid, array('query' => drupal_get_destination())) .'</div>';
  }

  $data .= _weblinks_links($term);
  foreach ($term->children as $child) {
    $data .= _weblinks_format_group($tree[$child], $tree);
  }
  // Can't be collapsed if the title is empty.
  $fieldset = array(
    '#title' => $term->title . ' (' . $term->node_count . ')',
    '#collapsible' => $term->collapsible,
    '#collapsed' => $term->collapsed,
    '#value' => $data,
    '#attributes' => array('class' => array('collapsible')),
    '#children' => '',
    );
  return '<div class="weblinkCat weblinkCat-depth-'. $term->depth .'">'. theme('fieldset', array('element' => $fieldset)) ."</div>\n";
}

/**
 * Returns tree of existing containers.
 * Replacement for taxonomy_get_tree.
 *
 * @param $parent
 *   the parent term to restrict the tree to. (optional)
 *
 * @return an array of term objects.
 */

function weblinks_get_tree($parent = 0, $quick = FALSE) {
  $admin = user_access('administer weblinks');

  $taxo_img = module_exists('taxonomy_image_x');  // @@@

  $collapsible = variable_get('weblinks_collapsible', TRUE);
  $collapsed = variable_get('weblinks_collapsed', FALSE);
  $empty_text = variable_get('weblinks_empty_text', NULL);
  $skip_empty = empty($empty_text);
  if ($admin) {
    $skip_empty = FALSE;
  }
  $show_desc = variable_get('weblinks_catdesc', TRUE);
  $format = variable_get('weblinks_format', filter_fallback_format());
  $max_depth = $admin ? 99999999 : variable_get('weblinks_maxfrontdepth', 1);

  $tree = array();
  if (module_exists('taxonomy')) {
    $tree = taxonomy_get_tree(_weblinks_get_vocid(), $parent);
  }

  // Is this a top level request?
  if ($parent) {
    // The existing elements have depths one too low.
    foreach ($tree as $term) {
      ++$term->depth;
    }
    // Not top level, so we need to get the requested term
    // and stick it on the front of the tree.
    $parent_term = taxonomy_term_load($parent);
    array_unshift($tree, $parent_term);
    $tree[0]->depth = 0;
  }
  else {
    // Top level, so do we have unclassified links?
    $unclassed_count = db_query(_weblinks_get_query(0, 'count'))->fetchField();
    if ($admin || $unclassed_count > 0) {
      // Add our dummy unclassified term object to the list.
      $tree[] = _weblinks_unclassed();
    }

    // Do we want a separate unpublished group?
    if (variable_get('weblinks_unpublished_title', t('Unpublished'))) {
      // Do we have unpublished nodes?
      $unpub_count = db_query(_weblinks_get_query('unpublished', 'count'))->fetchField();
      if ($admin && $unpub_count > 0) {
        $tree[] = _weblinks_unpublished();
      }
    }
  }

  $new_tree = array();
  foreach ($tree as $term) {
    $tid = $term->tid;
    // If we are too deep already, or the admin doesn't want it, skip the whole term.
    $show_this_term = variable_get('weblinks_page_'. $tid, TRUE);
    if (!$admin && ($term->depth > $max_depth || !$show_this_term)) {
      continue;
    }
    // If we are suppressing empty terms and there are no links in this group, skip it.
    if ($tid === 0) {
      $term->node_count = $unclassed_count;
    }
    else {
      if ($tid == 'unpublished') {
        $term->node_count = $unpub_count;
      }
      else {
        // $term->node_count = db_query("SELECT COUNT(ti.nid) FROM {taxonomy_index} as ti INNER JOIN {node} as n on n.nid=ti.nid WHERE ti.tid = :aid and n.type='weblinks'", array(':aid' => $tid))->fetchField();
        $term->node_count = weblinks_term_node_count($tid, 'weblinks', TRUE);
      }
    }
    if ($skip_empty && $term->node_count == 0) {
      continue;
    }

    $new_tree[$tid] = $term;
    $new_tree[$tid]->children = array();
    if (isset($term->parents)) {
      if ($term->parents[0] != 0) {
        foreach ($term->parents as $parent) {
          if (isset($new_tree[$parent])) {
            $new_tree[$parent]->children[] = $tid;
          }
        }
      }
    }

    $new_tree[$tid]->limit = variable_get('weblinks_maxdisp_'. $tid, '');
    $new_tree[$tid]->sort = variable_get('weblinks_group_sort_'. $term->tid, '');

    // Collapsible is more complicated than just the setting.
    $new_tree[$tid]->collapsible = $collapsible && ($new_tree[$tid]->depth < $max_depth)  && !empty($term->name);
    $collapse_me = variable_get('weblinks_collapse_'. $tid, FALSE);
    $new_tree[$tid]->collapsed = $collapsed || ($new_tree[$tid]->depth > $max_depth) || ($new_tree[$tid]->collapsible ? $collapse_me : FALSE);

    if ($new_tree[$tid]->collapsible) {
      $new_tree[$tid]->title = check_plain($term->name);
    }
    else {
      if (variable_get('weblinks_linktitle', TRUE)) {
        $new_tree[$tid]->title = l($term->name, 'weblinks/'. $tid);
      }
      else {
        $new_tree[$tid]->title = check_plain($term->name);
      }
    }

    $new_tree[$tid]->desc = NULL;
    if ($show_desc && $new_tree[$tid]->collapsible) {
      if ($term->description) {
        $new_tree[$tid]->desc = '<div class="weblinks-cat-desc">'. check_markup($term->description, $format, '', FALSE) .'</div><!--class="weblinks-cat-desc"-->';
      }
    }
    else {
      $new_tree[$tid]->desc = '';
    }
    // Position first node after whatever description there was.
    $new_tree[$tid]->desc .= '<div class="clear-block"></div>';
    $new_tree[$tid]->image = $taxo_img ? '<div class="weblinks-cat-image">'. taxonomy_image_display($term->tid, NULL, NULL, array('wrapper' => FALSE)) .'</div>' : NULL;
  }
  return $new_tree;
}

/**
 * Display the main web links page, separated by category (term).
 *
 * @param $tid
 *   The term for which to display the links. If ommitted or 0, then show all.
 *
 * @return
 *   HTML formatted page.
 */
function weblinks_page($tid = 0) {
  global $base_path;

  // Allow collapsible form elements.
  drupal_add_library('system', 'drupal.collapse');

  // Get the page description, if there is one
  $output = theme('weblinks_pagedesc');

  // If the tid is not numeric, we came from a block "more".
  if (!is_numeric($tid)) {
    if (!in_array($tid, array('popular', 'recent', 'unpublished', 'random')) || !module_exists('weblinks_blocks')) {
      drupal_set_message(t('Invalid group requested (%tid).', array('%tid' => $tid)), 'error');
      return ' ';
    }

    $group_id = arg(2);
    $content = _weblinks_blocks_content($tid, $tid, 0, $group_id);

    $term = taxonomy_term_load($group_id);
    $fieldset = array(
      '#title' => check_plain(drupal_ucfirst($tid) .' '. $term->name),
      '#collapsible' => variable_get('weblinks_collapsible', TRUE),
      '#collapsed' => FALSE,
      '#value' => $content,
      '#attributes' => array('class' => array('collapsible')),
      );
    $output = '<div class="weblinkCat weblinkCat-depth-0">'. theme('fieldset', array('element' => $fieldset)) ."</div>\n";
    return $output;
  }

  $output = '<div class="weblinks">';
  $tree = weblinks_get_tree($tid);
  foreach ($tree as $term) {
    if ($term->depth == 0) {
      $output .= _weblinks_format_group($term, $tree);
    }
  }

  if (!$output) {
    $output .= '<p>'. t('There are no weblinks to display yet.') .'</p>';
  }

  return $output .'</div>';
}

/**
 * Handle group operations.
 */
function _weblinks_group_operations($op, $tid = NULL) {
  if (!weblinks_group_access()) {
    drupal_access_denied();
  }

  // Force admin theme.
  global $custom_theme;
  $custom_theme = variable_get('admin_theme', '0');
  drupal_add_css(drupal_get_path('module', 'system') .'/admin.css');
  drupal_add_css(drupal_get_path('module', 'weblinks') .'/weblinks.admin.css');

  drupal_set_title(t('Group !op', array('!op' => $op)));

  module_load_include('inc', 'taxonomy', 'taxonomy.admin');

  $vocabulary = taxonomy_vocabulary_load(_weblinks_get_vocid());
  $_REQUEST['destination'] = 'weblinks';

  switch ($op) {
    case 'add':
      return drupal_get_form('taxonomy_form_term', 0, $vocabulary);

    case 'edit':
      // D6: return taxonomy_admin_term_edit($tid);
      if ($term = taxonomy_term_load($tid)) {
        return drupal_get_form('taxonomy_form_term', $term);
      }
      else {
        return drupal_not_found();
      }
  }
}

/**
 * Process page for specific user.
 *
 * @param $uid
 *   user id to retrieve.
 *
 * @return the page of links submitted by the user.
 */
function _weblinks_user($uid) {
  $output = $username = NULL;
  $linkdesc = variable_get('weblinks_linkdesc', 'teaser');

  // See if name instead of id.
  if (!is_numeric($uid)) {
    $uid = _weblinks_find_user($uid);
  }

  $result = _weblinks_get_query($uid, 'user', 0);
  foreach ($result as $row) {
    $node = node_load($row->nid);
    if (!$username) {
      $username = theme('username', array('account' => $node));
    }
    $build = node_view($node, $linkdesc);
    $output .= drupal_render($build);
  }
  drupal_set_title(t('Links submitted by !name', array('!name' => $username)), PASS_THROUGH);
  $breadcrumb = drupal_get_breadcrumb();
  $breadcrumb[] = l(_weblinks_get_menu_title(), 'weblinks');
  drupal_set_breadcrumb($breadcrumb);
  return $output;
}

function _weblinks_find_user($name) {
  if (function_exists('user_locate')) {
    $account = user_locate(array('name' => $name));
    $uid = $account->uid;
  }
  else {
    $uid = db_query("SELECT uid FROM {users} WHERE name=':uid'", array(':uid' => $name))->fetchField();
  }
  return $uid;
}

/**
 * Process redirect for URL. Count clicks and node views.
 *
 * @param $nid
 *   node id that contains the link.
 * $param $update_node_counter
 *   bool indicating whether or not the node view counter should be updated.
 *
 * @return none.
 *   the page will be redirected (302) to the desired URL.
 */
function weblinks_goto($nid) {
  $node = db_query("SELECT n.nid, n.vid, l.url FROM {node} n LEFT JOIN {weblinks} l USING(nid, vid) WHERE n.nid=:nid", array(':nid' => $nid))->fetchObject();
  $qargs = array(':date' => date('Y-m-d H:i:s'), ':nid' => $nid, ':vid' => $node->vid);
  db_query("UPDATE {weblinks} SET click_count=click_count+1, last_click=:date WHERE nid=:nid AND vid=:vid", $qargs);
  if (module_exists('statistics')) {
    statistics_exit('node', $nid, '');
  }
  header('Location: '. $node->url);
}

/**
 * Prepare links content.
 *
 * @param $term
 *   a term object to process links for.
 *
 * @return
 *   list of links for the given term (HTML).
 */
function _weblinks_links($term) {
  global $user;
  // Making these static means we only need to set them the first time we come here.
  static $options, $empty_text, $filter_format, $linkdesc;
  if (!isset($empty_text)) {
    $empty_text = variable_get('weblinks_empty_text', NULL);
    $filter_format = variable_get('weblinks_format', filter_fallback_format());
    $linkdesc = variable_get('weblinks_linkdesc', 'teaser');

    $options = array();
    if (variable_get('weblinks_external', TRUE)) {
      $options['attributes']['target'] = '_blank';
    }

    if (variable_get('weblinks_nofollow', FALSE)) {
      $options['attributes']['rel'] = 'nofollow';
    }
  }

  $output = NULL;

  $limit = isset($term->limit) ? $term->limit : 99999999;
  $need_more = $limit < $term->node_count;

  if ($term->tid === 'unpublished') {
    $sort_order = 'recent';
  }
  else {
    $sort_order = variable_get('weblinks_group_sort_'. $term->tid, variable_get('weblinks_page_sort', 'title'));
  }

  $result = _weblinks_get_query($term->tid, $sort_order, ($limit ? ++$limit : 0));

  foreach ($result as $row) {
    $node = node_load($row->nid);
    $build = node_view($node, $linkdesc);
    $output .= drupal_render($build);
  }

  // Do we need a "more" link?
  if ($need_more) {
    $more_link = '<div class="more-link">'. l(t('more&#8230;'), 'weblinks/'. $term->tid) .'</div>';
  }
  else {
    $more_link = NULL;
  }
  if ($term->node_count == 0) {
    $output = check_markup($empty_text, $filter_format, '', FALSE);
  }

  return decode_entities($output);
}

/**
 * Trim the link title (either text or the url itself) to the admin-specified length.
 */
function _weblinks_trim($text, $length = NULL) {
  if (!$length) {
    // Blocks have to specify the length.
    $length = variable_get('weblinks_trim', 0);
  }

  // Zero means no limit;
  if ($length == 0) {
    return $text;
  }

  // Use +3 for '...' string length.
  if (drupal_strlen($text) > $length + 3) {
    $text = drupal_substr($text, 0, $length) .'...';
  }

  return $text;
}

/**
 * General database query function.
 *
 * @param $tid
 *   the term id to fetch links for. May be a comma separated list.
 * @param $sort
 *   the order in which to sort.
 * @param $limit
 *   the maximum number of rows to retrieve - 0 means unlimited.
 *
 * @return result set from the query.
 */
function _weblinks_get_query($tid = 0, $sort = 'title', $limit = 0) {
  $wheres = array();
  if ($tid === 'unpublished') {
    $wheres[] = 'n.status = 0';
  }
  else {
    // If there is an "unpublished" group title, then don't show them in this group.
    if (variable_get('weblinks_unpublished_title', t('Unpublished'))) {
      $wheres[] = 'n.status = 1';
    }
  }

  // Acts as filter on {node}.
  $join = 'INNER JOIN {weblinks} bw ON n.vid = bw.vid ';

  // In some cases we need a join on taxonomy_index; in some we don't. We decide later according to $sort.
  // TODO: join node revisions too?
  if (function_exists('taxonomy_term_load') && $tid !== 'all') {
    if ($tid === 0) {
      $join_tn = 'LEFT JOIN {taxonomy_index} tn ON tn.nid=n.nid '; // AND tn.tid=n.vid ';
      $where_tn = 'tn.nid IS NULL';
    }
    else {
      $join_tn = 'INNER JOIN {taxonomy_index} tn ON tn.nid=n.nid '; // AND tn.tid=n.vid ';
      $where_tn = 'tn.tid IN (:tid)';
    }
  }
  else {
    $join_tn = '';
    $where_tn = '1 = 1';
  }

  $order = '';
  switch ($sort) {
    case 'standard':
      // Distinct is in case a node has more than one term from this group.
      $cols = 'DISTINCT(n.nid), n.sticky, n.created';
      $join .= $join_tn;
      $wheres[] = $where_tn;
      $order = 'ORDER BY n.sticky DESC, n.created DESC';
      break;
    case 'title':
      $cols = 'DISTINCT(n.nid), n.title, n.sticky';
      $join .= $join_tn;
      $wheres[] = $where_tn;
      $order .= 'ORDER BY n.sticky DESC, n.title ASC';
      break;
    case 'popular':
      $cols = 'DISTINCT(n.nid), bw.click_count, bw.last_click';
      $wheres[] = 'bw.click_count>0';
      $order .= 'ORDER BY bw.click_count DESC, bw.last_click DESC';
      break;
    case 'author':
    case 'user':
      $cols = 'DISTINCT(n.nid), n.sticky, n.created';
      $wheres[] = 'n.uid=:tid';  // Parameter is shared in query
      $order .= 'ORDER BY n.sticky, n.created';
      break;
    case 'recent':
      $cols = 'DISTINCT(n.nid), n.changed, n.title';
      if ($tid != 0) {
        $join .= $join_tn;
        $wheres[] = $where_tn;
      }
      $order .= 'ORDER BY n.changed DESC, n.title ASC';
      break;
    case 'random':
      $cols = 'DISTINCT(n.nid)';
      if ($tid != 0) {
        $join .= $join_tn;
        $wheres[] = $where_tn;
      }
      $order .= 'ORDER BY RAND()';
      break;
    case 'count':
      $cols = 'COUNT(n.nid)';
      if ($tid !== 'unpublished') {
        $join .= $join_tn;
        $wheres[] = $where_tn;
      }
      $order = '';
      break;
  }

  $where = $wheres ? (' WHERE '. implode(' AND ', $wheres) .' ') : NULL;
  $query_wl = 'SELECT ' . $cols . ' FROM {node} n ' . $join . $where .' '. $order;
  // Debug! Next two lines.
  // $term = taxonomy_term_load($tid);
  // drupal_set_message("$tid ($term->name), $sort: " . $query_wl);

  // db_rewrite_sql
  if ($limit) {
    $result = db_query_range($query_wl, 0, $limit, array(':tid' => $tid));
  }
  else {
    $result = db_query($query_wl, array(':tid' => $tid));
  }

  return $result;
}

/**
 * Implementation of hook_form_alter
 * Alters the taxonomy term form to allow us to use it.
 * @TODO - check if necessary for this user and include. ** if (weblinks_group_access()) { **
 */
function weblinks_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'taxonomy_form_term':
      // Is this for our vocabulary?
      if ($form['#vocabulary']->vid != _weblinks_get_vocid()) {
        return '';
      }
      $form['identification']['#weight'] = -10;
      $form['identification']['#collapsible'] = FALSE;
      $form['identification']['name']['#title'] = t('Group name');
      $form['identification']['name']['#description'] = t('The name of this group.');
      $form['identification']['description']['#title'] = t('Group description');
      $form['identification']['description']['#description'] = t('A description of the group, to be displayed on web links pages and forms.');

      $form['advanced']['#weight'] = -5;
      $form['advanced']['parent']['#description'] = t('Parent groups.');
      $form['advanced']['weight']['#description'] = t('Groups are displayed in ascending order by weight.');
      unset($form['advanced']['relations']);
      unset($form['advanced']['synonyms']);

      if (isset($form['taxonomy_image'])) {
        $form['taxonomy_image']['#title'] = t('Group image');
        $form['taxonomy_image']['new_image']['path']['#description'] = t('The image file you wish to associate this group.');
      }

      break;
  } // End switch form_id.
}

/**
 * Implementation of hook_theme().
 */
function weblinks_theme() {
  return array(
    // In separate files.
    'weblinks_user_form' => array(
      'variables' => array('form' => NULL),
      'file' => 'weblinks.user.inc',
      ),
    // In template files.
    'weblinks_node_view' => array(
      'template' => 'weblinks_node_view',
      'variables' => array('node' => NULL, 'options' => NULL, 'status' => NULL),
      ),
    'weblinks_link' => array(
      'template' => 'weblinks-link',
      'variables' => array('node' => NULL, 'teaser' => NULL),
      ),
    // In this module.
    'weblinks_pagedesc' => array(
      'variables' => array(),
      ),
    'weblinks_user_link' => array(
      'variables' => array('acct_id' => NULL),
      ),
    );
}

/**
 *  Theme the page description.
 *
 *  @param none
 *
 *  @return
 *    String containing the formatted info.
 */
function theme_weblinks_pagedesc() {
  // Get the page description, if there is one.
  $pagedesc = variable_get('weblinks_pagedesc', NULL);
  if (empty($pagedesc)) {
    return NULL;
  }
  else {
    return '<div class="weblinks-pagedesc">'. check_markup($pagedesc, variable_get('weblinks_format', filter_fallback_format(), '',
    FALSE)) .'</div>';
  }
}

/**
 *  Theme the user link.
 *
 *  @param $acct_id
 *    User ID for the link to be made.
 *
 *  @return
 *    String containing the formatted info.
 */
function theme_weblinks_user_link($acct_id) {
  static $users = array();
  if (!isset($users[$acct_id])) {
    $account = user_load($acct_id);
    $users[$acct_id] = l($account->name ."'s links", 'user/'. $acct_id .'/weblinks');
  }
  return '<div class="weblinks-user-link">'. $users[$acct_id] .'</div>';
}

/**
 *  Implementation of hook_views_api()
 */
function weblinks_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'weblinks'),
    );
}

