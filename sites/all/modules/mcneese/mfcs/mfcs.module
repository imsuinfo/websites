<?php

/**
 * @file
 * McNeese State University Facilities Use module.
 */

/**
 * @defgroup mfcs McNeese Facilities Use
 * @{
 * Provides Workflow specific module functionality for the Requests Workflow
 * System.
 */

/**
 * Defines request status codes.
 */
define('MFCS_REQUEST_STATUS_DELETED', 0);
define('MFCS_REQUEST_STATUS_LOCKED', 1);
define('MFCS_REQUEST_STATUS_UNLOCKED', 2);
define('MFCS_REQUEST_STATUS_CLOSED_ACCEPTED', 3);
define('MFCS_REQUEST_STATUS_CLOSED_DENIED', 4);
define('MFCS_REQUEST_STATUS_CLOSED_UNAVAILABLE', 5);
define('MFCS_REQUEST_STATUS_CLOSED_DUE_TO_LOCK', 6);
define('MFCS_REQUEST_STATUS_CANCELLED', 7);

/**
 * Defines Taxonomy VIDs.
 */
 define('MFCS_VID_REQUEST_CLASSIFICATION', 1);
 define('MFCS_VID_REQUEST_STEPS', 19);
 define('MFCS_VID_REQUEST_LOCATION', 7);
 define('MFCS_VID_REQUEST_AUDIENCE', 9);
 define('MFCS_VID_REQUEST_REVENUE_GENERATED', 15);
 define('MFCS_VID_REQUEST_REQUEST_TYPE', 8);
 define('MFCS_VID_REQUEST_PUBLICITY_DETAILS', 11);
 define('MFCS_VID_REQUEST_DESIGNING_MATERIAL', 16);
 define('MFCS_VID_REQUEST_TECHNICAL_EQUIPMENT_DETAILS', 10);
 define('MFCS_VID_REQUEST_REVIEWER_CLASSIFICATION', 17);
 define('MFCS_VID_REQUEST_REVIEWER_DECISION', 18);
 define('MFCS_VID_REQUEST_DATES_CATEGORY', 20);

/**
 * Defines Taxonomy TIDs for review steps.
 */
 define('MFCS_REVIEW_STEP_CHANGES_REQUIRED', 140);
 define('MFCS_REVIEW_STEP_COMPLETED', 134);
 define('MFCS_REVIEW_STEP_MAKE_DECISIONS', 117);
 define('MFCS_REVIEW_STEP_RELEASE_HOLD', 118);
 define('MFCS_REVIEW_STEP_REVIEW', 132);
 define('MFCS_REVIEW_STEP_REQUIREMENTS', 133);
 define('MFCS_REVIEW_STEP_VENUE_AVAILABLE', 116);

/**
 * Defines Taxonomy TID for review decisions.
 */
 define('MFCS_REVIEW_DECISION_MANAGER_RECHECK', -1);
 define('MFCS_REVIEW_DECISION_AMENDMENT', 141);
 define('MFCS_REVIEW_DECISION_APPROVE', 115);
 define('MFCS_REVIEW_DECISION_COMMENT', 113);
 define('MFCS_REVIEW_DECISION_DENY', 114);
 define('MFCS_REVIEW_DECISION_WAVE', 135);
 define('MFCS_REVIEW_DECISION_REQUIREMENT', 136);

/**
 * Defines Taxonomy TIDs for review classifications.
 */
 define('MFCS_REVIEW_CLASSIFICATION_ADMINISTRATIVE_ACCOUNTING', 105);
 define('MFCS_REVIEW_CLASSIFICATION_EVENT_COORDINATOR', 99);
 define('MFCS_REVIEW_CLASSIFICATION_FACILITIES', 104);
 define('MFCS_REVIEW_CLASSIFICATION_FACULTY_ADVISOR', 100);
 define('MFCS_REVIEW_CLASSIFICATION_FOOD_SERVICES', 108);
 define('MFCS_REVIEW_CLASSIFICATION_HOUSING', 107);
 define('MFCS_REVIEW_CLASSIFICATION_MAINTENANCE', 103);
 define('MFCS_REVIEW_CLASSIFICATION_PURCHASING', 106);
 define('MFCS_REVIEW_CLASSIFICATION_SECURITY', 102);
 define('MFCS_REVIEW_CLASSIFICATION_STUDENT_SERVICES', 101);
 define('MFCS_REVIEW_CLASSIFICATION_VENUE_COORDINATOR', 112);
 define('MFCS_REVIEW_CLASSIFICATION_SYSTEM_ADMINISTRATOR', 1);
 define('MFCS_REVIEW_CLASSIFICATION_MANAGER', 2);
 define('MFCS_REVIEW_CLASSIFICATION_FAILSAFE_COORDINATOR', 45);

/**
 * Defines Taxonomy TIDs for request classifications.
 */
 define('MFCS_EVENT_CLASSIFICATION_STUDENT', 1);
 define('MFCS_EVENT_CLASSIFICATION_CAMPS', 2);
 define('MFCS_EVENT_CLASSIFICATION_FACULTY', 3);
 define('MFCS_EVENT_CLASSIFICATION_EXTERNAL', 4);

/**
 * Defines Taxonomy TIDs for request dates categories.
 */
 define('MFCS_EVENT_DATES_CATEGORY_ACTUAL', 137);
 define('MFCS_EVENT_DATES_CATEGORY_SETUP', 138);
 define('MFCS_EVENT_DATES_CATEGORY_CLEANUP', 139);

/**
 * Defines operator codes for building search queries.
 */
 define('MFCS_OPERATOR_LESS_THAN', 1);
 define('MFCS_OPERATOR_LESS_THAN_EQUAL', 2);
 define('MFCS_OPERATOR_EQUAL', 3);
 define('MFCS_OPERATOR_LIKE', 4);
 define('MFCS_OPERATOR_GREATER_THAN_EQUAL', 5);
 define('MFCS_OPERATOR_GREATER_THAN', 6);
 define('MFCS_OPERATOR_NOT_EQUAL', 7);
 define('MFCS_OPERATOR_NOT_LIKE', 8);
 define('MFCS_OPERATOR_IS_NULL', 9);
 define('MFCS_OPERATOR_IS_NOT_NULL', 10);

/**
 * Defines table join codes for building search queries.
 */
 define('MFCS_JOIN_INNER', 1);
 define('MFCS_JOIN_LEFT', 2);
 define('MFCS_JOIN_RIGHT', 3);
 define('MFCS_JOIN_OUTER', 4);

/**
 * Defines a recursion limit for the search and/or operations.
 */
 define('MFCS_MAX_SEARCH_RECURSION', 3);

/**
 * Defines a failsafe coordinator id to use.
 */
 define('MFCS_FAILSAFE_COORDINATOR_ID', 45);

/**
 * Defines a standardized string for consiting watchdog error reporting.
 */
 define('MFCS_WATCHDOG_ID', 'mfcs');

/**
 * Defines standard view modes.
 */
 define('MFCS_VIEW_MODE_NORMAL', 'normal');
 define('MFCS_VIEW_MODE_DISPLAY', 'display');
 define('MFCS_VIEW_MODE_LOG', 'log');
 define('MFCS_VIEW_MODE_OPERATIONS', 'operations');

/**
 * Defines PDF types.
 */
 define('MFCS_PDF_TYPE_REQUEST', 0);
 define('MFCS_PDF_TYPE_AGREEMENT', 1);

/**
 * Defines e-mail reminder types.
 */
 define('MFCS_REMINDER_TYPE_INSURANCE_NOT_PROVIDED', 0);

/**
 * Defines e-mail reminder intervals.
 */
 define('MFCS_REMINDER_INTERVAL_DAY_0', 0);
 define('MFCS_REMINDER_INTERVAL_DAY_1', 1);
 define('MFCS_REMINDER_INTERVAL_DAY_2', 2);
 define('MFCS_REMINDER_INTERVAL_DAY_3', 3);
 define('MFCS_REMINDER_INTERVAL_DAY_4', 4);
 define('MFCS_REMINDER_INTERVAL_DAY_5', 5);
 define('MFCS_REMINDER_INTERVAL_DAY_6', 6);
 define('MFCS_REMINDER_INTERVAL_DAY_7', 7);
 define('MFCS_REMINDER_INTERVAL_DAY_8', 8);
 define('MFCS_REMINDER_INTERVAL_DAY_9', 9);
 define('MFCS_REMINDER_INTERVAL_DAY_10', 10);
 define('MFCS_REMINDER_INTERVAL_DAY_11', 11);
 define('MFCS_REMINDER_INTERVAL_DAY_12', 12);
 define('MFCS_REMINDER_INTERVAL_DAY_30', 30);
 define('MFCS_REMINDER_INTERVAL_WEEK_0', 1000);
 define('MFCS_REMINDER_INTERVAL_WEEK_1', 1001);
 define('MFCS_REMINDER_INTERVAL_WEEK_2', 1002);
 define('MFCS_REMINDER_INTERVAL_WEEK_3', 1003);
 define('MFCS_REMINDER_INTERVAL_WEEK_4', 1004);
 define('MFCS_REMINDER_INTERVAL_WEEK_5', 1005);
 define('MFCS_REMINDER_INTERVAL_WEEK_6', 1006);
 define('MFCS_REMINDER_INTERVAL_WEEK_7', 1007);
 define('MFCS_REMINDER_INTERVAL_WEEK_8', 1008);
 define('MFCS_REMINDER_INTERVAL_WEEK_9', 1009);
 define('MFCS_REMINDER_INTERVAL_WEEK_10', 1010);
 define('MFCS_REMINDER_INTERVAL_WEEK_11', 1011);
 define('MFCS_REMINDER_INTERVAL_WEEK_12', 1012);

/**
 * Defines e-mail priority codes.
 */
 define('MFCS_MAIL_PRIORITY_HIGHEST', 1);
 define('MFCS_MAIL_PRIORITY_HIGH', 2);
 define('MFCS_MAIL_PRIORITY_NORMAL', 3);
 define('MFCS_MAIL_PRIORITY_LOW', 4);
 define('MFCS_MAIL_PRIORITY_LOWEST', 5);

/**
 * Defines Taxonomy TIDs for review steps.
 */
 define('MFCS_REQUEST_TYPE_ATHLETIC', 66);
 define('MFCS_REQUEST_TYPE_BANQUET', 61);
 define('MFCS_REQUEST_TYPE_CEREMONY', 64);
 define('MFCS_REQUEST_TYPE_FAIR', 65);
 define('MFCS_REQUEST_TYPE_LECTURE', 59);
 define('MFCS_REQUEST_TYPE_MEETING', 57);
 define('MFCS_REQUEST_TYPE_OTHER', 67);
 define('MFCS_REQUEST_TYPE_PERFORMANCE', 58);
 define('MFCS_REQUEST_TYPE_QUICK_MEETING', 142);
 define('MFCS_REQUEST_TYPE_RECEPTION', 60);
 define('MFCS_REQUEST_TYPE_TALENT', 63);
 define('MFCS_REQUEST_TYPE_WORKSHOP', 62);

/**
 * Defines Taxonomy TIDs for request classifications.
 */
 define('MFCS_REQUEST_AUDIENCE_FACULTY_AND_STAFF', 71);
 define('MFCS_REQUEST_AUDIENCE_GUESTS_ONLY', 68);
 define('MFCS_REQUEST_AUDIENCE_STUDENTS_AND_EMPLOYEES', 70);
 define('MFCS_REQUEST_AUDIENCE_PUBLIC', 72);
 define('MFCS_REQUEST_AUDIENCE_STUDENTS_ONLY', 69);

/**
 * Defines file include codes.
 */
define('MFCS_INCLUDE_TABLE', 0);
define('MFCS_INCLUDE_STRUCTURE', 1);
define('MFCS_INCLUDE_VALIDATION', 2);
define('MFCS_INCLUDE_AUTOCOMPLETE', 3);
define('MFCS_INCLUDE_LIST_OPTIONS', 4);
define('MFCS_INCLUDE_WORKFLOW', 5);
define('MFCS_INCLUDE_HOOKS', 6);
define('MFCS_INCLUDE_OUTPUT', 7);
define('MFCS_INCLUDE_MISCELLANEOUS', 8);
define('MFCS_INCLUDE_ACCESS', 9);
define('MFCS_INCLUDE_ICAL', 10);
define('MFCS_INCLUDE_REQUEST_CANCEL', 11);
define('MFCS_INCLUDE_REQUEST_CREATE', 12);
define('MFCS_INCLUDE_REQUEST_VIEW', 13);
define('MFCS_INCLUDE_TESTING', 14);



/**
 * Implements hook_init().
 */
function mfcs_init() {
  global $base_path;
  $module_path = drupal_get_path('module', 'mfcs');

  drupal_add_js($module_path . '/js/printing-fieldsets.js', array('type' => 'file', 'group' => JS_DEFAULT, 'preprocess' => TRUE));
}

/**
 * Implements hook_permission().
 */
function mfcs_permission() {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_permission();
}

/**
 * Implements hook_menu().
 */
function mfcs_menu() {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_menu();
}

/**
 * Implements hook_user_insert().
 */
function mfcs_user_insert(&$edit, $account, $category) {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_user_insert($edit, $account, $category);
}

/**
 * Access callback for facilities use pages.
 *
 * For already loaded requests, use: mfcs_request_access().
 *
 * This static caches the results in 'mfcs_request_access'.
 *
 * @param null|string $operation
 *   (optional) When specified, performs access check based on operation.
 * @param null|int|array $request_id
 *   (optional) When specified, performs access check based the provided id.
 *   Can be an array for 'review'.
 * @param null|object $user
 *   (optional) The user object to obtain access for.
 * @param null|string $section
 *   (optional) Check whether or not the user is allowed to perform a certain
 *   operation for a specific section. This is primarily used for the edit
 *   pages.
 *
 * @param bool|array
 *   TRUE on access granted, FALSE otherwise.
 *   An array of boolean values is returned when request_id is an array.
 *
 * @see: mfcs_request_access()
 */
function mfcs_page_request_access($operation = NULL, $request_id = NULL, $user = NULL, $section = NULL) {
  if (is_null($user) || !is_object($user)) {
    $user = cf_current_user();
  }

  // anonymous user is denied access to requests as a whole.
  if ($user->uid == 0) {
    return FALSE;
  }

  // allow for request_id to be an array of ids.
  $processed = array();
  if (is_array($request_id)) {
    $request_ids = array();

    foreach ($request_id as $id) {
      $request_ids[$id] = $id;
    }

    // only allow the null array key to be specified by this function.
    unset($request_ids[NULL]);
  }
  elseif (is_null($request_id)) {
    $request_ids = array(NULL => NULL);
  }
  else {
    $request_ids = array($request_id => $request_id);
  }

  // nothing to check access for.
  if (empty($request_ids)) {
    return FALSE;
  }


  // use advanced static cache for increased performance.
  static $mfcs_request_access;

  if (!isset($mfcs_request_access)) {
    $mfcs_request_access[$operation] = &drupal_static('mfcs_request_access');
  }

  if (!isset($mfcs_request_access[$operation][$section][$user->uid])) {
    $mfcs_request_access[$operation][$section][$user->uid] = array();
  }

  $access = &$mfcs_request_access[$operation][$section][$user->uid];

  if (is_string($request_id) || is_numeric($request_id)) {
    if (array_key_exists($request_id, $access)) {
      return $access[$request_id];
    }
  }
  elseif (is_array($request_id)) {
    $request_ids_copy = $request_ids;
    foreach ($request_ids_copy as $id => $value) {
      if (array_key_exists($id, $access)) {
        $processed[$id] = $access[$id];
        unset($request_ids[$id]);
      }
    }
    unset($request_ids_copy);

    // if all of the requests have been processed, then return.
    if (empty($request_ids)) {
      return $processed;
    }
  }
  elseif (is_null($request_id)) {
    // the request id is allowed to be NULL.
  }
  else {
    return FALSE;
  }

  $request_status = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_UNLOCKED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    MFCS_REQUEST_STATUS_CLOSED_DENIED,
    MFCS_REQUEST_STATUS_CLOSED_UNAVAILABLE,
    MFCS_REQUEST_STATUS_CLOSED_DUE_TO_LOCK,
    MFCS_REQUEST_STATUS_CANCELLED,
  );

  $roles = array(
    'manager' => user_access('mfcs manage', $user),
    'reviewer' => user_access('mfcs review', $user),
    'requester' => user_access('mfcs request', $user),
    'administer' => user_access('mfcs administer', $user),
  );

  mfcs_include(MFCS_INCLUDE_ACCESS);

  if ($operation == 'create') {
    $operation_result = mfcs_page_request_access_operation_create($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'edit') {
    $operation_result = mfcs_page_request_access_operation_edit($request_ids, $processed, $access, $roles, $user, $section);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'view') {
    $operation_result = mfcs_page_request_access_operation_view($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'list') {
    if ($roles['requester'] || $roles['reviewer'] || $roles['manager']) {
      if (is_array($request_id)) {
        foreach ($request_ids as $request_id) {
          $access[$request_id] = TRUE;
          $processed[$request_id] = TRUE;
        }

        return $processed;
      }

      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'search') {
    if ($roles['requester'] || $roles['reviewer'] || $roles['manager']) {
      if (is_array($request_id)) {
        foreach ($request_ids as $request_id) {
          $access[$request_id] = TRUE;
          $processed[$request_id] = TRUE;
        }

        return $processed;
      }

      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'reviewers') {
    if ($roles['manager']) {
      if (is_array($request_id)) {
        foreach ($request_ids as $request_id) {
          $access[$request_id] = TRUE;
          $processed[$request_id] = TRUE;
        }

        return $processed;
      }

      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'review') {
    $operation_result = mfcs_page_request_access_operation_review($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'comment') {
    // @todo: currently disabled feature. Enable if such functionality is requested.
  }
  elseif ($operation == 'log') {
    $operation_result = mfcs_page_request_access_operation_log($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'delete') {
    $operation_result = mfcs_page_request_access_operation_delete($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'cancel') {
    $operation_result = mfcs_page_request_access_operation_cancel($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'uncancel') {
    $operation_result = mfcs_page_request_access_operation_uncancel($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'history') {
    $operation_result = mfcs_page_request_access_operation_history($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'agreement') {
    $operation_result = mfcs_page_request_access_operation_agreement($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'statistics') {
    if (is_null($request_id)) {
      if ($roles['manager'] || $roles['reviewer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }

  if (is_array($request_id)) {
    foreach ($request_ids as $request_id) {
      $access[$request_id] = FALSE;
      $processed[$request_id] = FALSE;
    }

    return $processed;
  }

  $access[$request_id] = FALSE;
  return FALSE;
}

/**
 * Check access for already loaded facilities use requests.
 *
 * This is used to reduce database calls for when a request is already loaded.
 * If the request has not yet been loaded, either load it or directly call
 * mfcs_page_request_access() for access checks.
 *
 * This static caches the results in 'mfcs_request_access'.
 *
 * @param string $operation
 *   Operation to perform access check against.
 * @param array $request
 *   An already loaded request array to perform access checks against.
 * @param object $user
 *   (optional) The user object to obtain access for.
 * @param string $section
 *   (optional) Check whether or not the user is allowed to perform a certain
 *   operation for a specific section. This is primarily used for the edit
 *   pages.
 *
 * @param bool
 *   TRUE on access granted, FALSE otherwise.
 *
 * @see: mfcs_page_request_access()
 */
function mfcs_request_access($operation, $request, $user = NULL, $section = NULL) {
  if (!is_string($operation)) {
    cf_error::invalid_string('operation');
    return FALSE;
  }

  if (!is_array($request)) {
    cf_error::invalid_array('request');
    return FALSE;
  }

  if (is_null($user) || !is_object($user)) {
    $user = cf_current_user();
  }

  // anonymous user is denied access to requests as a whole.
  if ($user->uid == 0) {
    return FALSE;
  }


  // use advanced static cache for increased performance.
  static $mfcs_request_access;

  if (!isset($mfcs_request_access)) {
    $mfcs_request_access[$operation] = &drupal_static('mfcs_request_access');
  }

  if (!isset($mfcs_request_access[$operation][$section][$user->uid])) {
    $mfcs_request_access[$operation][$section][$user->uid] = array();
  }

  $access = &$mfcs_request_access[$operation][$section][$user->uid];

  if (empty($request['mer']['id'][0]->value)) {
    return FALSE;
  }
  $request_id = $request['mer']['id'][0]->value;

  if (array_key_exists($request_id, $access)) {
    return $access[$request_id];
  }

  if (!isset($request['top']['status'][0]->value) || !isset($request['top']['step'][0]->value)) {
    $access[$request_id] = FALSE;
    return FALSE;
  }


  $request_status = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_UNLOCKED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    MFCS_REQUEST_STATUS_CLOSED_DENIED,
    MFCS_REQUEST_STATUS_CLOSED_UNAVAILABLE,
    MFCS_REQUEST_STATUS_CLOSED_DUE_TO_LOCK,
    MFCS_REQUEST_STATUS_CANCELLED,
  );

  $manager = user_access('mfcs manage', $user);
  $reviewer = user_access('mfcs review', $user);
  $requester = user_access('mfcs request', $user);
  $administer = user_access('mfcs administer', $user);

  if ($operation == 'create') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // create operations on a specific request is actually a clone/copy operation, which only needs view access to clone/copy.
    $access[$request_id] = mfcs_request_access('view', $request, $user);
    return $access[$request_id];
  }
  elseif ($operation == 'edit') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $edit_request_status = array(
      MFCS_REQUEST_STATUS_UNLOCKED,
      MFCS_REQUEST_STATUS_LOCKED,
    );

    // when quick meeting is enabled, a section is not null, then additional checks are required.
    $is_quick_meeting = FALSE;
    if (!is_null($request_id) && !is_null($section) && ($manager || $requester)) {
      if (isset($request['information']['type'][0]->value) && $request['information']['type'][0]->value == MFCS_REQUEST_TYPE_QUICK_MEETING) {
        $is_quick_meeting = TRUE;

        // deny access to sections that are not allowed to be edited for a quick meeting.
        $allowed_sections = array(
          'request',
          'information',
          'coordinator',
          'dates',
        );

        if (!in_array($section, $allowed_sections)) {
          return FALSE;
        }
      }
    }

    $valid_status = in_array($request['top']['status'][0]->value, $edit_request_status);

    if ($manager) {
      $access[$request_id] = $valid_status;
      return $valid_status;
    }
    elseif ($requester) {
      if ($valid_status) {
        if (isset($request['mer']['user_id'][0]->value) && $request['mer']['user_id'][0]->value == $user->uid) {
          $access[$request_id] = TRUE;
          return TRUE;
        }
      }
    }
  }
  elseif ($operation == 'view') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($manager) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
    elseif ($reviewer) {
      // due to its complexity, the database calling function for reviewer access will be used.
      $review_access = mfcs_page_request_reviewer_access($user, $request_id, NULL);

      if (is_array($review_access) && array_key_exists($request_id, $review_access)) {
        $access[$request_id] = $review_access[$request_id];
        return $review_access[$request_id];
      }
    }
    elseif ($requester) {
      if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_CLOSED_ACCEPTED && $request['top']['step'][0]->value == MFCS_REVIEW_STEP_COMPLETED) {
        // always show completed and accepted requests when there are no restrictions
        $access[$request_id] = TRUE;
        return TRUE;
      }
      elseif (in_array($request['top']['status'][0]->value, $request_status)) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'review') {
    if (!$reviewer) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // due to its complexity, the database calling function for reviewer access will be used.
    $review_access = mfcs_page_request_reviewer_access($user, $request_id, TRUE);

    if (is_array($review_access) && array_key_exists($request_id, $review_access)) {
      $access[$request_id] = $review_access[$request_id];
      return $review_access[$request_id];
    }
  }
  elseif ($operation == 'comment') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // @todo: currently disabled feature. Enable if such functionality is requested.
    $access[$request_id] = FALSE;
    return FALSE;
  }
  elseif ($operation == 'log') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($manager) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
    elseif ($reviewer) {
      // due to its complexity, the database calling function for reviewer access will be used.
      $review_access = mfcs_page_request_reviewer_access($user, $request_id, NULL);

      if (is_array($review_access) && array_key_exists($request_id, $review_access)) {
        $access[$request_id] = $review_access[$request_id];
        return $review_access[$request_id];
      }
    }
  }
  elseif ($operation == 'delete') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($operation == 'delete') {
      if ($roles['administer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'cancel') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $cancellable_status_normal = array(
      MFCS_REQUEST_STATUS_UNLOCKED,
    );

    $cancellable_status_admin = array(
      MFCS_REQUEST_STATUS_LOCKED,
      MFCS_REQUEST_STATUS_UNLOCKED,
    );

    // if the user is the venue coordinator, then allow them to cancel an request at any point in the process.
    if ($request['venue_coordinator']['user_id'][0]->value == $user->uid && in_array($request['top']['status'][0]->value, $cancellable_status_admin)) {
      $access[$request_id] = TRUE;
      return TRUE;
    }

    if ($manager) {
      if (in_array($request['top']['status'][0]->value, $cancellable_status_admin)) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
    elseif ($requester) {
      if ($request['mer']['user_id'][0]->value == $user->uid && in_array($request['top']['status'][0]->value, $cancellable_status_normal)) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'uncancel') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $uncancellable_status = array(
      MFCS_REQUEST_STATUS_CANCELLED,
    );

    // if the user is the venue coordinator, then allow them to uncancel an request at any point in the process.
    if ($request['venue_coordinator']['user_id'][0]->value == $user->uid && in_array($request['top']['status'][0]->value, $uncancellable_status)) {
      $access[$request_id] = TRUE;
      return TRUE;
    }

    if ($manager) {
      if (in_array($request['top']['status'][0]->value, $uncancellable_status)) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'history') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED && !$administer) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($manager) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'agreement') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $agreement_request_status = array(
      MFCS_REQUEST_STATUS_LOCKED,
      MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
      MFCS_REQUEST_STATUS_CLOSED_DENIED,
      MFCS_REQUEST_STATUS_CANCELLED,
    );

    if ($manager || $reviewer) {
      $agreement_request_step = array(
        MFCS_REVIEW_STEP_COMPLETED,
        MFCS_REVIEW_STEP_MAKE_DECISIONS,
        MFCS_REVIEW_STEP_REVIEW,
        MFCS_REVIEW_STEP_REQUIREMENTS,
      );

      if (in_array($request['top']['status'][0]->value, $agreement_request_status) && in_array($request['top']['step'][0]->value, $agreement_request_step)) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
    else {
      $agreement_request_step = array(
        MFCS_REVIEW_STEP_COMPLETED,
      );

      if (in_array($request['top']['status'][0]->value, $agreement_request_status) && in_array($request['top']['step'][0]->value, $agreement_request_step)) {
        // the submitter should be the only non-manager/non-reviewer that can access the agreement.
        if ($request['mer']['user_id'][0]->value == $user->uid) {
          $access[$request_id] = TRUE;
          return TRUE;
        }
      }
    }
  }

  $access[$request_id] = FALSE;
  return FALSE;
}

/**
 * Check to see if a given user is allowed to review a given request.
 *
 * @param object $user
 *   User to check if is a valid reviewer of the given request.
 * @param int|array $request_id
 *   ID of the request to check review access for.
 *   This can be an array of request ids.
 *   Using multiple ids can improve performance instead of doing a check
 *   against each individual request id.
 * @param null|bool $review_restrictions
 *   When NULL, no review restrictions are applied.
 *   When FALSE, review view restrictions are applied.
 *   When TRUE, review edit restrictions are applied.
 *
 * @return bool|array
 *   An array of access grants by access id, FALSE otherwise.
 */
function mfcs_page_request_reviewer_access($user, $request_id, $review_restrictions) {
  if (!is_object($user)) {
    cf_error::invalid_object('user');
    return FALSE;
  }

  if (!cf_is_integer($request_id)) {
    if (!is_array($request_id) || empty($request_id)) {
      cf_error::invalid_integer('request_id');
      return FALSE;
    }
  }

  if (!is_null($review_restrictions) && !is_bool($review_restrictions)) {
    cf_error::invalid_bool('review_restrictions');
    return FALSE;
  }

  $request_ids = $request_id;
  if (!is_array($request_id)) {
    $request_ids = array($request_id);
  }

  $access = array();
  foreach ($request_ids as $id) {
    $access[$id] = FALSE;
  }

  $reviewer_classifications = array();
  $reviewer_steps = array();
  $reviewer_settings = mfcs_get_reviewers(array('mr.user_id' => $user->uid));
  if (is_array($reviewer_settings)) {
    foreach ($reviewer_settings as $reviewer_setting) {
      $reviewer_classifications[$reviewer_setting->reviewer_classification] = $reviewer_setting->reviewer_classification;
      $reviewer_steps[$reviewer_setting->review_step] = $reviewer_setting->review_step;
    }
  }
  unset($reviewer_settings);

  $show_status_venue_coordinator = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_UNLOCKED,
  );

  $show_step_venue_coordinator = array(
    MFCS_REVIEW_STEP_VENUE_AVAILABLE,
    MFCS_REVIEW_STEP_MAKE_DECISIONS,
  );

  $show_status_reviewer = array(
    MFCS_REQUEST_STATUS_LOCKED,
  );

  $show_step_reviewer = array(
    MFCS_REVIEW_STEP_REVIEW,
    MFCS_REVIEW_STEP_REQUIREMENTS,
  );

  $show_decision = array(
    MFCS_REVIEW_DECISION_APPROVE,
    MFCS_REVIEW_DECISION_DENY,
  );

  $show_step_insurance = array(
    MFCS_REVIEW_STEP_REVIEW,
    MFCS_REVIEW_STEP_REQUIREMENTS,
    MFCS_REVIEW_STEP_MAKE_DECISIONS,
    MFCS_REVIEW_STEP_COMPLETED,
  );

  $show_status_insurance = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
  );

  try {
    $query = db_select('mfcs_requests', 'mer');

    $query->innerJoin('mfcs_current_top', 'mct', 'mer.id = mct.request_id');

    $query->innerJoin('mfcs_field_top_status', 'mfts', 'mct.request_id = mfts.request_id AND mct.status = mfts.revision AND mfts.delta = 0');
    $query->innerJoin('mfcs_field_top_step', 'mftsp', 'mct.request_id = mftsp.request_id AND mct.step = mftsp.revision AND mftsp.delta = 0');

    $query->innerJoin('mfcs_current_request_coordinator', 'mcrc', 'mer.id = mcrc.request_id');
    $query->innerJoin('mfcs_field_request_coordinator_classification', 'mfrcc', 'mcrc.request_id = mfrcc.request_id AND mcrc.classification = mfrcc.revision AND mfrcc.delta = 0');

    $query->innerJoin('mfcs_current_venue_coordinator', 'mcvc', 'mer.id = mcvc.request_id');
    $query->innerJoin('mfcs_field_venue_coordinator_user_id', 'mfvcui', 'mcvc.request_id = mfvcui.request_id AND mcvc.user_id = mfvcui.revision AND mfvcui.delta = 0');

    $query->addField('mer', 'id', 'id');

    $query->condition('mer.id', array($request_ids), 'IN');

    $query->condition('mfts.value', MFCS_REQUEST_STATUS_DELETED, '<>');

    $or = null;

    if ($review_restrictions === TRUE) {
      if (is_null($or)) {
        $or = db_or();
      }

      // process venue coordinator access.
      $already_venue_coordinated_query = db_select('mfcs_reviewed', 'mrd_vc');
      $already_venue_coordinated_query->addField('mrd_vc', 'request_id', 'request_id');
      $already_venue_coordinated_query->where('mrd_vc.request_id = mftsp.request_id');
      $already_venue_coordinated_query->condition('mrd_vc.classification', MFCS_REVIEW_CLASSIFICATION_VENUE_COORDINATOR);

      $and = db_and();
      $and->condition('mfts.value', $show_status_venue_coordinator, 'IN');
      $and->condition('mftsp.value', $show_step_venue_coordinator, 'IN');
      $and->condition('mftsp.request_id', $already_venue_coordinated_query, 'NOT IN');
      $and->condition('mfvcui.value', $user->uid);

      $or->condition($and);

      // process review access.
      if (empty($reviewer_classifications)) {
        // if the 'reviewer' has no reviewer classifications, then they cannot review, remove all requests associated with reviewer steps.
        $and->condition('mftsp.value', $show_step_reviewer, 'NOT IN');

        $or->condition($and);
      }
      else {
        $already_reviewed_query = db_select('mfcs_reviewers', 'mr_r');
        $already_reviewed_query->innerJoin('mfcs_reviewed', 'mrd_r', 'mr_r.reviewer_classification = mrd_r.classification');
        $already_reviewed_query->addField('mrd_r', 'request_id', 'request_id');
        $already_reviewed_query->where('mr_r.request_classification = mfrcc.value AND mr_r.review_step = mftsp.value');
        $already_reviewed_query->condition('mr_r.user_id', $user->uid);
        $already_reviewed_query->condition('mr_r.disabled', 0);

        $and = db_and();
        $and->condition('mfts.value', $show_status_reviewer, 'IN');
        $and->condition('mftsp.value', $show_step_reviewer, 'IN');
        $and->condition('mftsp.value', $reviewer_steps, 'IN');
        $and->condition('mftsp.request_id', $already_reviewed_query, 'NOT IN');

        $or->condition($and);

        // special case reviewer access: insurance provided
        /*
        $has_insurance_query = db_select('mfcs_current_insurance', 'c_mci_1');
        $has_insurance_query->leftJoin('mfcs_field_insurance_contractor', 'mfic', 'c_mci_1.request_id = mfic.request_id AND c_mci_1.contractor = mfic.revision AND mfic.delta = 0');
        $has_insurance_query->leftJoin('mfcs_field_insurance_unaffiliated', 'mfiu', 'c_mci_1.request_id = mfiu.request_id AND c_mci_1.unaffiliated = mfiu.revision AND mfiu.delta = 0');
        $has_insurance_query->leftJoin('mfcs_field_insurance_provided', 'mfip', 'c_mci_1.request_id = mfip.request_id AND c_mci_1.provided = mfip.revision AND mfip.delta = 0');

        // $query->countQuery() does not appear to be functioning as expected, so manually count.
        $has_insurance_query->addExpression('count(c_mci_1.request_id)');

        $has_insurance_query->where('mer.id = c_mci_1.request_id');

        $nand = db_and();
        $nand->not();
        $nand->condition('mfip.value', 1);
        $has_insurance_query->condition($nand);

        $another_or = db_or();
        $another_or->condition('mfic.value', 1);
        $another_or->condition('mfiu.value', 1);
        $has_insurance_query->condition($another_or);

        $can_review_query = db_select('mfcs_reviewers', 'c_mr_3');

        $can_review_query->addField('c_mr_3', 'user_id', 'user_id');

        $can_review_query->where('c_mr_3.request_classification = mfrcc.value');
        $can_review_query->condition('c_mr_3.user_id', $user->uid);
        $can_review_query->condition('c_mr_3.review_step', $show_step_reviewer, 'IN');
        $can_review_query->condition('c_mr_3.reviewer_classification', MFCS_REVIEW_CLASSIFICATION_PURCHASING);
        $can_review_query->condition('c_mr_3.disabled', 0);
        $can_review_query->distinct();

        $and = db_and();
        $and->condition('mfts.value', $show_status_insurance, 'IN');
        $and->condition('mftsp.value', $show_step_insurance, 'IN');
        $and->condition($user->uid, $can_review_query, 'IN');
        $and->condition(0, $has_insurance_query, 'NOT IN');

        $or->condition($and);
        */
      }
    }
    elseif ($review_restrictions === FALSE) {
      if (is_null($or)) {
        $or = db_or();
      }

      // always show accepted requests.
      $or->condition('mfts.value', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);

      // process venue coordinator access.
      $or->condition('mfvcui.value', $user->uid);

      // process review access.
      if (!empty($reviewer_steps)) {
        $and = db_and();
        $and->condition('mftsp.value', $reviewer_steps, 'IN');

        $or->condition($and);
      }
    }
    else {
      if (is_null($or)) {
        $or = db_or();
      }

      // always show completed and accepted requests when there are no restrictions.
      $and = db_and();
      $and->condition('mfts.value', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);
      $and->condition('mftsp.value', MFCS_REVIEW_STEP_COMPLETED);
      $or->condition($and);

      // process venue coordinator access.
      $or->condition('mfvcui.value', $user->uid);

      // process reviewer access.
      if (!empty($reviewer_steps)) {
        $and = db_and();
        $and->condition('mfts.value', MFCS_REQUEST_STATUS_LOCKED);
        $and->condition('mftsp.value', $show_step_reviewer, 'IN');
        $or->condition($and);
      }
    }

    if (!is_null($or)) {
      $query->condition($or);
    }

    $results = $query->execute()->fetchAllAssoc('id');
    if (!is_array($results)) {
      return $access;
    }

    foreach ($access as $id => $value) {
      $access[$id] = array_key_exists($id, $results);
    }

    return $access;
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);

    return $access;
  }

  return $access;
}

/**
 * Access callback for facilities use management page.
 *
 * @param bool
 *   TRUE on access granted, FALSE otherwise.
 */
function mfcs_dashboard_page_access() {
  if (user_access('mfcs administer') || user_access('mfcs request') || user_access('mfcs review') || user_access('mfcs manage')) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Access callback for facilities use management page.
 *
 * @param bool
 *   TRUE on access granted, FALSE otherwise.
 */
function mfcs_management_page_access() {
  if (user_access('mfcs administer') || user_access('mfcs manage') || user_access('mfcs review')) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_cronapi().
 */
function mfcs_cronapi() {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_cronapi();
}

/**
 * Implements hook_mail().
 */
function mfcs_mail($key, &$message, $params) {
  global $base_url;

  $subject = '';
  $body = '';
  $markup = '';

  if ($key == 'request_alert') {
    $instance = mfcs_instance();

    if (!empty($params['title_prefix'])) {
      $subject .= $params['title_prefix'];
    }

    $subject .= 'Facilities Use Request: ' . $params['request_id'] . ' - ' . $params['request_title'];

    if (!empty($params['title_suffix'])) {
      $subject .= ' - ' . $params['title_suffix'];
    }

    $request_url = $base_url . '/requests/view-0/' . $params['request_id'];

    if (!empty($params['content'])) {
      $body .= $params['content'] . "\n";
    }

    $body .= "\n";
    $body .= "Request URL:\n - " . $request_url . "\n\n";

    $body .= "\n";
    $body .= "This e-mail was generated on:\n - " . date("Y/m/d h:i:s a T", $instance) . "\n";


    if (isset($params['markup'])) {
      $markup .= $params['markup'] . "\n";

      $markup .= "<br>\n";
      $markup .= "<strong>Request URL</strong>:\n<ul><li><a href=" . '"' . $request_url . '"' . ">" . $request_url . "</a></li></ul>\n<br>\n";

      $markup .= "<br>\n";
      $markup .= "<em>This e-mail was generated on</em>:\n<ul><li><em>" . date("Y/m/d h:i:s a T", $instance) . "</em></li></ul>\n";
    }
  }
  else {
    return;
  }

  $message['subject'] = $subject;
  $message['body'] = array($body);
  $message['markup'] = isset($params['markup']) ? array($markup) : array();
  $message['from_address'] = isset($params['from']) ? $params['from'] : $message['from'];

  if (!empty($params['files'])) {
    $message['files'] = $params['files'];
  }

  // assign message priority.
  if (isset($params['message_priority'])) {
    if ($params['message_priority'] == MFCS_MAIL_PRIORITY_HIGHEST) {
      $message['headers']['X-Priority'] = '1 (Highest)';
      $message['headers']['Importance'] = 'high';
    }
    elseif ($params['message_priority'] == MFCS_MAIL_PRIORITY_HIGH) {
      $message['headers']['X-Priority'] = '2 (High)';
      $message['headers']['Importance'] = 'high';
    }
    elseif ($params['message_priority'] == MFCS_MAIL_PRIORITY_NORMAL) {
      // @todo: should low be manually specified, such as: 3 (normal) ?
    }
    elseif ($params['message_priority'] == MFCS_MAIL_PRIORITY_LOW) {
      $message['headers']['X-Priority'] = '4 (Low)';
      $message['headers']['Importance'] = 'low';
    }
    elseif ($params['message_priority'] == MFCS_MAIL_PRIORITY_LOWEST) {
      $message['headers']['X-Priority'] = '5 (Lowest)';
      $message['headers']['Importance'] = 'low';
    }
  }
}

/**
 * Helper function to load files related to this project.
 *
 * @param int $id
 *   The number associated with the file to include.
 */
function mfcs_include($id) {
  if (!is_numeric($id)) {
    cf_error::invalid_number('id');
    return;
  }

  $module_path = drupal_get_path('module', 'mfcs');

  if ($id == MFCS_INCLUDE_TABLE) {
    require_once($module_path . '/includes/table.inc');
  }
  elseif ($id == MFCS_INCLUDE_STRUCTURE) {
    require_once($module_path . '/includes/structure.inc');
  }
  elseif ($id == MFCS_INCLUDE_VALIDATION) {
    require_once($module_path . '/includes/validation.inc');
  }
  elseif ($id == MFCS_INCLUDE_AUTOCOMPLETE) {
    require_once($module_path . '/includes/autocomplete.inc');
  }
  elseif ($id == MFCS_INCLUDE_LIST_OPTIONS) {
    require_once($module_path . '/includes/list_options.inc');
  }
  elseif ($id == MFCS_INCLUDE_WORKFLOW) {
    require_once($module_path . '/includes/workflow.inc');
  }
  elseif ($id == MFCS_INCLUDE_HOOKS) {
    require_once($module_path . '/includes/hooks.inc');
  }
  elseif ($id == MFCS_INCLUDE_OUTPUT) {
    require_once($module_path . '/includes/output.inc');
  }
  elseif ($id == MFCS_INCLUDE_MISCELLANEOUS) {
    require_once($module_path . '/includes/miscellaneous.inc');
  }
  elseif ($id == MFCS_INCLUDE_ACCESS) {
    require_once($module_path . '/includes/access.inc');
  }
  elseif ($id == MFCS_INCLUDE_ICAL) {
    require_once($module_path . '/includes/ical.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_CANCEL) {
    require_once($module_path . '/pages/request_cancel.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_CREATE) {
    require_once($module_path . '/pages/request_create.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_VIEW) {
    require_once($module_path . '/pages/request_view.inc');
  }
  elseif ($id == MFCS_INCLUDE_TESTING) {
    require_once($module_path . '/includes/testing.inc');
  }
}

/**
 * Performs a select query.
 *
 * @param string $query
 *   A query string to process.
 * @param array $arguments
 *   (optional) An array of arguments
 *
 * @return array|bool
 *   An array containing the query results.
 *   FALSE is returned on error.
 */
function mfcs_oracle_select($query, $arguments = array()) {
  if (!is_string($query)) {
    cf_error::invalid_string('query');

    return FALSE;
  }

  if (!is_array($arguments)) {
    cf_error::invalid_array('arguments');

    return FALSE;
  }

  $results = array();

  try {
    $conn = Database::getConnection('default', 'oracle');

    $results = (array) $conn->oracleQuery($query, $arguments)->fetchAll();
  } catch (Exception $ex) {
    cf_error::on_exception($ex);

    return FALSE;
  }

  return $results;
}

/**
 * Returns a list of locations available.
 *
 * Note: ucs.msu_venue_list calls the building location 'category'.
 *
 * @param int|null $location
 *   (optional) When specified, load the location associated with the location id.
 * @param bool $disabled
 *   (optional) When TRUE, will also load the disabled rooms.
 *
 * @return array|object|bool
 *   An array of locations objects or a single location object.
 *   FALSE is returned on error.
 */
function mfcs_load_locations($location = NULL, $disabled = FALSE) {
  if (!is_null($location) && !cf_is_integer($location)) {
    cf_error::invalid_integer('location');
    return FALSE;
  }

  if (!is_bool($disabled)) {
    cf_error::invalid_bool('disabled');
    return FALSE;
  }

  $cache_id = __function__;

  if ($disabled) {
    $cache_id .= '_disabled';
  }

  $items = &drupal_static($cache_id, NULL);
  if (is_array($items)) {
    if (is_null($location)) {
      return $items;
    }

    if (array_key_exists($location, $items)) {
      return $items[$location];
    }

    return FALSE;
  }

  $items = array();
  try {
    $query = db_select('mfcs_banner_locations', 'mbl');

    if (!$disabled) {
      $query->condition('mbl.disabled', 0);
    }

    $query->addField('mbl', 'id', 'location_id');
    $query->addField('mbl', 'human_name', 'location_name');

    $query->orderBy('mbl.human_name');

    $items = $query->execute()->fetchAllAssoc('location_id');

    if (is_null($location)) {
      return $items;
    }
    elseif (array_key_exists($location, $items)) {
      return $items[$location];
    }
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);

    return FALSE;
  }

  return FALSE;
}

/**
 * Returns a list of buildings available.
 *
 * Note: ucs.msu_venue_list calls the building location 'category'.
 *
 * @param int|null $location
 *   (optional) When specified, load buildings associated with the location id.
 * @param int|null $building
 *   (optional) When specified, load the building associated with the building id.
 * @param bool $disabled
 *   (optional) When TRUE, will also load the disabled rooms.
 *
* @return array|object|bool
 *   An array of building objects or a single building object.
 *   FALSE is returned on error.
 */
function mfcs_load_buildings($location = NULL, $building = NULL, $disabled = FALSE) {
  if (!is_null($location) && !cf_is_integer($location)) {
    cf_error::invalid_integer('location');
    return FALSE;
  }

  if (!is_null($building) && !cf_is_integer($building)) {
    cf_error::invalid_integer('building');
    return FALSE;
  }

  if (!is_bool($disabled)) {
    cf_error::invalid_bool('disabled');
    return FALSE;
  }

  $cache_id = __function__;

  if (!is_null($location)) {
    $cache_id .= '_' . $location;
  }

  if ($disabled) {
    $cache_id .= '_disabled';
  }

  $items = &drupal_static($cache_id, NULL);
  if (is_array($items)) {
    if (is_null($building)) {
      return $items;
    }

    if (array_key_exists($building, $items)) {
      return $items[$building];
    }

    return FALSE;
  }

  $items = array();
  try {
    $query = db_select('mfcs_banner_buildings', 'mbb');

    if (!is_null($location)) {
      $query->innerJoin('mfcs_banner_building_to_location', 'mbbl', 'mbb.id = mbbl.building');
      $query->innerJoin('mfcs_banner_locations', 'mbl', 'mbbl.location = mbl.id');

      $query->condition('mbl.id', $location);

      $query->addField('mbl', 'id', 'location_id');
      $query->addField('mbl', 'machine_name', 'location_code');
      $query->addField('mbl', 'human_name', 'location_name');

      $query->orderBy('mbl.human_name');

      if (!$disabled) {
        $query->condition('mbl.disabled', 0);
      }
    }

    if (!$disabled) {
      $query->condition('mbb.disabled', 0);
    }

    $query->addField('mbb', 'id', 'building_id');
    $query->addField('mbb', 'machine_name', 'building_code');
    $query->addField('mbb', 'human_name', 'building_name');
    $query->orderBy('mbb.human_name');

    $items = $query->execute()->fetchAllAssoc('building_id');

    if (is_null($building)) {
      return $items;
    }
    elseif (array_key_exists($building, $items)) {
      return $items[$building];
    }
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);

    return FALSE;
  }

  return FALSE;
}

/**
 * Returns a list of rooms available.
 *
 * @param int|null $location
 *   (optional) When specified, load rooms associated with the location id.
 * @param int|null $building
 *   (optional) When specified, load rooms associated with the building id.
 * @param int|null $room
 *   (optional) When specified, load the room associated with the room id.
 * @param bool $disabled
 *   (optional) When TRUE, will also load the disabled rooms.
 *
 * @return array|bool
 *   An array of rooms or a single room array.
 *   FALSE is returned on error.
 */
function mfcs_load_rooms($location = NULL, $building = NULL, $room = NULL, $disabled = FALSE) {
  if (!is_null($location) && !cf_is_integer($location)) {
    cf_error::invalid_integer('location');
    return FALSE;
  }

  if (!is_null($building) && !cf_is_integer($building)) {
    cf_error::invalid_integer('building');
    return FALSE;
  }

  if (!is_null($room) && !cf_is_integer($room)) {
    cf_error::invalid_integer('room');
    return FALSE;
  }

  if (!is_bool($disabled)) {
    cf_error::invalid_bool('disabled');
    return FALSE;
  }

  $cache_id = __function__;

  if (!is_null($location) || !is_null($building)) {
    $cache_id .= '_' . $location;
    $cache_id .= '_' . $building;
  }

  if ($disabled) {
    $cache_id .= '_disabled';
  }

  $items = &drupal_static($cache_id, NULL);
  if (is_array($items)) {
    if (is_null($room)) {
      return $items;
    }

    if (array_key_exists($room, $items)) {
      return $items[$room];
    }

    return FALSE;
  }

  $items = array();
  try {
    $query = db_select('mfcs_banner_rooms', 'mbr');
    $query->innerJoin('mfcs_banner_buildings', 'mbb', 'mbr.building = mbb.id');

    if (!is_null($location)) {
      $query->innerJoin('mfcs_banner_building_to_location', 'mbbl', 'mbb.id = mbbl.building AND mbr.building = mbbl.building');
      $query->innerJoin('mfcs_banner_locations', 'mbl', 'mbbl.location = mbl.id');

      $query->condition('mbl.id', $location);

      $query->addField('mbl', 'id', 'location_id');
      $query->addField('mbl', 'machine_name', 'location_code');
      $query->addField('mbl', 'human_name', 'location_name');

      $query->orderBy('mbl.human_name');

      if (!$disabled) {
        $query->condition('mbl.disabled', 0);
      }
    }

    if (!$disabled) {
      $query->condition('mbr.disabled', 0);
      $query->condition('mbb.disabled', 0);
    }

    if (!is_null($building)) {
      $query->condition('mbb.id', $building);
    }

    $query->addField('mbr', 'id', 'room_id');
    $query->addField('mbr', 'machine_name', 'room_number');
    $query->addField('mbr', 'human_name', 'room_name');
    $query->addField('mbr', 'coordinator_id', 'coordinator_id');
    $query->addField('mbr', 'capacity_normal', 'capacity_normal');
    $query->addField('mbr', 'capacity_max', 'capacity_max');

    $query->addField('mbb', 'id', 'building_id');
    $query->addField('mbb', 'machine_name', 'building_code');
    $query->addField('mbb', 'human_name', 'building_name');

    $query->orderBy('mbb.human_name');
    $query->orderBy('mbr.human_name');
    $query->orderBy('mbr.machine_name');

    $items = $query->execute()->fetchAllAssoc('room_id');
    if (is_null($room)) {
      return $items;
    }
    elseif (array_key_exists($room, $items)) {
      return $items[$room];
    }
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);

    return FALSE;
  }

  return FALSE;
}

/**
 * Returns a list of user roles available.
 *
 * @return array|bool
 *   An array containing the roles.
 *   FALSE is returned on error.
 */
function mfcs_load_request_user_roles() {
  try {
    $query = db_select('mfcs_banner_event_roles', 'mber');
    $query->addField('mber', 'machine_name', 'role');

    $roles = $query->execute()->fetchAll();
  } catch (Exception $ex) {
    $transaction->rollback();

    return FALSE;
  }

  if (empty($roles)) return FALSE;

  return $roles;
}

/**
 * Returns an array containg mapping information for oracle.
 *
 * Use this to map drupal request role taxonomy terms with the oracle roles.
 *
 * @return array|bool
 *   An array containing the mapping information.
 *   FALSE is returned on error.
 */
function mfcs_load_request_user_role_mapping() {
  $cache_id = __function__;
  $terms = &drupal_static($cache_id, array());
  if (!empty($terms)) {
    return $terms;
  }

  try {
    $query = db_select('taxonomy_term_data', 'ttd');
    $query->innerJoin('taxonomy_vocabulary', 'tv', 'tv.vid = ttd.vid');
    $query->fields('ttd', array('tid'));
    $query->condition('tv.machine_name', 'user_roles');

    $executed = $query->execute();
    foreach ($executed as $row) {
      $term = taxonomy_term_load($row->tid);
      $name = $term->field_role_oracle_name['und'][0]['value'];

      $terms[$name] = array('tid' => FALSE, 'role' => FALSE, 'rid' => FALSE, 'name' => FALSE);


      if (!empty($term->field_role_oracle_name['und'][0]['value'])) {
        $terms[$name]['tid'] = $row->tid;
      }

      if (!empty($term->field_role_system_name['und'][0]['value'])) {
        $role = user_role_load_by_name($term->field_role_system_name['und'][0]['value']);

        if (is_object($role)) {
          $terms[$name]['role'] = $role->name;
          $terms[$name]['rid'] = $role->rid;
        }

        unset($role);
      }

      if (!empty($term->name)) {
        $terms[$name]['name'] = $term->name;
      }
    }
  } catch (Exception $ex) {
    cf_error::on_exception($ex);

    return FALSE;
  }

  return $terms;
}

/**
 * Returns user's information.
 *
 * This is different from user_load in that this loads user banner information.
 *
 * @param integer $user_id
 *   The user id number uniquely representing some user.
 *
 * @return array|bool
 *   An array containing the user information.
 *   FALSE is returned on error.
 */
function mfcs_load_request_user_by_user_id($user_id) {
  if (!cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');

    return FALSE;
  }

  $cache_id = __function__;
  $user = &drupal_static($cache_id, NULL);
  if (isset($user[$user_id]) && is_array($user[$user_id])) {
    return $user[$user_id];
  }

  $user[$user_id] = NULL;

  try {
    $query = db_select('mfcs_banner_event_roles_to_users', 'mberu');
    $query->innerJoin('mfcs_banner_event_roles', 'mber', 'mber.id = mberu.event_role_id');
    $query->innerJoin('field_data_field_user_banner_id', 'fdfubi', 'mberu.user_id = fdfubi.entity_id');

    $query->addField('mber', 'machine_name', 'role');
    $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

    $query->condition('mberu.user_id', $user_id);

    $rows = $query->execute()->fetchAll();

    if (!empty($rows)) {
      $user[$user_id] = array(
        'id' => NULL,
        'user_id' => $user_id,
        'role' => array(),
      );

      foreach ($rows as $row) {
        $user[$user_id]['role'][] = $row->role;

        if (is_null($user[$user_id]['id'])) {
          $user[$user_id]['id'] = $row->banner_id;
        }
      }
    }
  } catch (Exception $ex) {
    cf_error::on_exception($ex);

    return FALSE;
  }

  if (is_null($user[$user_id])) return FALSE;

  return $user[$user_id];
}

/**
 * Returns user's information.
 *
 * This is different from user_load in that this loads user banner information.
 *
 * @param string $banner_id
 *   The numeric banner id string uniquely representing some user.
 *
 * @return array|bool
 *   An array containing the user information.
 *   FALSE is returned on error.
 */
function mfcs_load_request_user_by_banner_id($banner_id) {
  if (!is_string($banner_id)) {
    cf_error::invalid_string('banner_id');

    return FALSE;
  }

  $cache_id = __function__;
  $user = &drupal_static($cache_id, NULL);
  if (isset($user[$banner_id]) && is_array($user[$banner_id])) {
    return $user[$banner_id];
  }

  $user[$banner_id] = NULL;

  try {
    $query = db_select('mfcs_banner_event_roles_to_users', 'mberu');
    $query->innerJoin('mfcs_banner_event_roles', 'mber', 'mber.id = mberu.event_role_id');
    $query->innerJoin('field_data_field_user_banner_id', 'fdfubi', 'mberu.user_id = fdfubi.entity_id');

    $query->addField('mber', 'machine_name', 'role');
    $query->addField('fdfubi', 'entity_id', 'user_id');

    $query->condition('fdfubi.field_user_banner_id_value', $banner_id);

    $rows = $query->execute()->fetchAll();

    if (!empty($rows)) {
      $user[$banner_id] = array(
        'id' => $banner_id,
        'user_id' => NUll,
        'role' => array(),
      );

      foreach ($rows as $row) {
        $user[$banner_id]['role'][] = $row->role;

        if (is_null($user[$banner_id]['user_id'])) {
          $user[$banner_id]['user_id'] = $row->user_id;
        }
      }
    }
  } catch (Exception $ex) {
    cf_error::on_exception($ex);

    return FALSE;
  }

  if (is_null($user[$banner_id])) return FALSE;

  return $user[$banner_id];
}

/**
 * Synchronizes the user settings with the oracle settings.
 *
 * @param object|null $user
 *   (optional) The user object to synchronize.
 *   If not specified, then the current user is synchronized.
 * @param array $roles
 *   (optional) Additional roles to assign the user to.
 *   Providing this will override the auto-assign role as requester.
 *   This is an array of role names and not role ids.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_synchronize_user_settings($user = NULL, $roles = array()) {
  if (is_null($user)) {
    $user = cf_current_user();
  }

  if (!is_object($user)) {
    cf_error::invalid_object('user');
    return FALSE;
  }

  if (!is_array($roles)) {
    cf_error::invalid_array('roles');
    return FALSE;
  }

  // a collection of user ids who should not have their roles changed.
  $whitelist = array();

  // skip special-case ldapless user.
  $whitelist[8] = 8;

  // kday
  $whitelist[6] = 6;

  // gfisher
  $whitelist[19] = 19;

  // colleen
  $whitelist[22] = 22;

  // gbodin
  $whitelist[23] = 23;

  // shogan
  $whitelist[45] = 45;

  if (array_key_exists($user->uid, $whitelist)) {
    return TRUE;
  }

  $mappings = mfcs_load_request_user_role_mapping();

  // unset all system role information associated with oracle.
  $system_roles = (array) $user->roles;
  foreach ($mappings as $mapping) {
    if (array_key_exists($mapping['rid'], $system_roles)) {
      unset($system_roles[$mapping['rid']]);
    }
  }

  // if the (non-admin) user has no core roles, then assign requester role.
  $assign_requester_role = TRUE;
  foreach ($system_roles as $key => &$role) {
    if ($role == 'administrator') {
      $assign_requester_role = FALSE;
      break;
    }

    if ($role == 'reviewer') {
      $assign_requester_role = FALSE;
      break;
    }

    if ($role == 'manager') {
      $assign_requester_role = FALSE;
      break;
    }

    if ($role == 'requester') {
      $assign_requester_role = FALSE;
      break;
    }
  }

  if (!empty($roles)) {
    $assign_requester_role = FALSE;

    foreach ($roles as $role) {
      $role = user_role_load_by_name($role);

      if (is_object($role)) {
        $system_roles[$role->rid] = $role;
      }
    }
  }

  if ($assign_requester_role) {
    $role = user_role_load_by_name('requester');
    $system_roles[$role->rid] = 'requester';
  }

  // only change user event roles for banner users.
  if (isset($user->field_user_banner_id['und'][0]['value'])) {
    $u = mfcs_load_request_user_by_user_id($user->uid);

    if ($u == FALSE) {
      $u = array();
    }

    $request_roles = array();
    if (!empty($u['role'])) {
      foreach ($u['role'] as $role) {
        if (isset($mappings[$role]['tid'])) {
          $request_roles[] = array('tid' => $mappings[$role]['tid']);
          $system_roles[$mappings[$role]['rid']] = $mappings[$role]['role'];
        }
      }
    }

    // Note: the system used to refer to requests as events, but because this is a drupal field, 'event' cannot be changed to 'request' in this explicit case.
    $edit = array('field_user_event_roles' => array('und' => $request_roles), 'roles' => $system_roles);

    if (user_save($user, $edit)) return TRUE;
  }

  return FALSE;
}

/**
 * Loads the user by e-mail and if the user does not exist. create it.
 *
 * @param string $email
 *   The users mcneese e-mail address.
 * @param array $roles
 *   An array of roles to assign the user to. If none is specified, then the
 *   default is to assign the reviewer role.
 *
 * @return object|false
 *   User object on success, FALSE otherwise.
 */
function mfcs_ensure_user_by_email($email, $roles = array()) {
  if (!is_string($email) || empty($email)) {
    cf_error::invalid_string('email');
    return FALSE;
  }

  if (!is_array($roles)) {
    cf_error::invalid_array('roles');
    return FALSE;
  }

  $email_parts = explode('@', $email);

  if (count($email_parts) != 2) {
    return FALSE;
  }

  $username = trim($email_parts[0]);
  $hostname = trim($email_parts[1]);

  if ($hostname != 'mcneese.edu' && $hostname != 'student.mcneese.edu') {
    return FALSE;
  }

  $user = user_load_by_name($username);
  if (is_object($user)) {
    return $user;
  }
  unset($user);


  // check to see if the user exists in ldap.
  $auth_conf = ldap_authentication_get_valid_conf();
  $ldap_user = FALSE;
  $ldap_server = NULL;
  $detailed_watchdog_log = variable_get('ldap_help_watchdog_detail', 0);
  $authentication_result = LDAP_AUTHENTICATION_RESULT_FAIL_GENERIC;

  foreach ($auth_conf->enabledAuthenticationServers as $sid => $ldap_server) {
    $watchdog_tokens = array();
    $authentication_result = LDAP_AUTHENTICATION_RESULT_FAIL_GENERIC;
    $result = $ldap_server->connect();

    if ($result != LDAP_SUCCESS) {
      $authentication_result = LDAP_AUTHENTICATION_RESULT_FAIL_CONNECT;
      $watchdog_tokens['%err_msg'] = $ldap_server->errorMsg('ldap');

      if ($detailed_watchdog_log) {
        watchdog('ldap_authentication',  '%username : Failed connecting to %sid.  Error: %err_msg', $watchdog_tokens, WATCHDOG_DEBUG);
      }

      continue;
    }

    $bind_success = FALSE;
    if ($ldap_server->bind_method != LDAP_SERVERS_BIND_METHOD_ANON && $ldap_server->bind_method != LDAP_SERVERS_BIND_METHOD_ANON_USER) {
      // this can only work using anonymous bindings.
      continue;
    }

    $bind_success = ($ldap_server->bind(NULL, NULL, TRUE) == LDAP_SUCCESS);

    if (!$bind_success) {
      if ($detailed_watchdog_log) {
        $watchdog_tokens['%err_text'] = $ldap_server->errorMsg('ldap');
        watchdog('ldap_authentication', '%username : Trying server %sid where bind_method = %bind_method.  Error: %err_text', $watchdog_tokens, WATCHDOG_DEBUG);
      }
      $authentication_result = ($ldap_server->bind_method == LDAP_SERVERS_BIND_METHOD_USER) ? LDAP_AUTHENTICATION_RESULT_FAIL_CREDENTIALS : LDAP_AUTHENTICATION_RESULT_FAIL_BIND;
      continue; // if bind fails, onto next server
    }

    $ldap_user = $ldap_server->userUserNameToExistingLdapEntry($username);
    if ($ldap_user !== FALSE) {
      break;
    }
  }

  if (empty($ldap_user)) {
    return FALSE;
  }


  // create the new user.
  $auth_conf = ldap_authentication_get_valid_conf();
  $watchdog_tokens = array(
    '%authname' => $username,
    '%account_name_attr' => $username,
    '%drupal_accountname' => $username,
  );

  if (!$auth_conf) {
    watchdog('ldap_authentication', 'Failed to get valid ldap authentication configuration.', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!$auth_conf->hasEnabledAuthenticationServers()) {
    watchdog('ldap_authentication',  'No LDAP servers configured.', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!$auth_conf->ldapUser->provisionEnabled(LDAP_USER_PROV_DIRECTION_TO_DRUPAL_USER, LDAP_USER_DRUPAL_USER_PROV_ON_AUTHENTICATE)) {
    watchdog('ldap_user', 'Drupal account for authname=%authname account name=%account_name_attr does not exist and provisioning of Drupal accounts on authentication is not enabled', $watchdog_tokens, WATCHDOG_INFO);
    return;
  }

  $user_register = variable_get('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL);
  if ($auth_conf->ldapUser->acctCreation == LDAP_USER_ACCT_CREATION_USER_SETTINGS_FOR_LDAP && $user_register == USER_REGISTER_ADMINISTRATORS_ONLY) {
    watchdog('ldap_user', 'Failed to create account for %drupal_accountname. Administrative user must create user.', $watchdog_tokens, WATCHDOG_ERROR);
    return FALSE;
  }

  if ($auth_conf->ldapUser->acctCreation == LDAP_AUTHENTICATION_ACCT_CREATION_USER_SETTINGS_FOR_LDAP && $user_register == USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL) {
    $user_edit = array('name' => $username, 'mail' => $email, 'status' => 0); // if admin approval required, set status to 0.
  }
  else {
    $user_edit = array('name' => $username, 'mail' => $email, 'status' => 1);
  }

  // don't pass in ldap user to provisionDrupalAccount, because want to requery with correct attributes needed
  // this may be a case where efficiency dictates querying for all attributes
  $drupal_account = $auth_conf->ldapUser->provisionDrupalAccount(FALSE, $user_edit, NULL, TRUE);

  if ($drupal_account === FALSE) {
    watchdog('ldap_user', 'Failed to find or create %drupal_accountname.', $watchdog_tokens, WATCHDOG_ERROR);
    return FALSE;
  }

  if ($drupal_account === TRUE) {
    $drupal_account = user_load_by_name($username);
  }

  user_set_authmaps($drupal_account, array('authname_ldap_user' => $username));

  // Using Rules allows emails to be fired and many other possible reactions
  // to the creation of a user.
  if (function_exists('rules_invoke_event')) {
    rules_invoke_event('ldap_user_created', $drupal_account, FALSE);
  }

  mfcs_synchronize_user_settings($drupal_account, $roles);

  // reset the user object cache to force loading of new settings.
  $user = user_load($drupal_account->uid, TRUE);

  return $user;
}

/**
 * Synchronizes the local database with the banner venue information.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_sync_banner_to_local() {
  $join = ' inner join ucs.msu_venue_list mvl on (mvl.category = mvd.category and mvl.building_code = mvd.building_code and mvl.room_number = mvd.room_number)';

  $select = 'mvd.*';
  $select .= ', mvl.building_desc as building_desc';
  $select .= ', mvl.room_desc as room_desc';

  $rows = mfcs_oracle_select('select ' . $select . ' from ucs.msu_venue_detail mvd' . $join);

  if (empty($rows) || !is_array($rows)) {
    return FALSE;
  }

  mfcs_include(MFCS_INCLUDE_LIST_OPTIONS);
  $request_locations = mfcs_get_request_location_list_options(NULL, TRUE);

  $instance = mfcs_instance();

  $transaction = db_transaction();
  try {
    // disable all locations, buildings, and rooms such that the ones that are not added back will be disabled.
    $query = db_update('mfcs_banner_locations');
    $query->fields(array('disabled' => 1, 'date' => $instance));
    $query->condition('disabled', 0);
    $query->execute();

    $query = db_update('mfcs_banner_buildings');
    $query->fields(array('disabled' => 1, 'date' => $instance));
    $query->condition('disabled', 0);
    $query->execute();

    $query = db_update('mfcs_banner_rooms');
    $query->fields(array('disabled' => 1, 'date' => $instance));
    $query->condition('disabled', 0);
    $query->execute();

    $query = db_update('mfcs_banner_building_to_location');
    $query->fields(array('disabled' => 1, 'date' => $instance));
    $query->condition('disabled', 0);
    $query->execute();

    foreach ($rows as $row) {
      $location_item = array();
      $building_item = array();
      $room_item = array();
      $coordinator_room_item = array();
      $coordinator_venue_item = array();
      $location_to_building_item = array();

      if (is_array($row)) {
        foreach ($row as $key => $value) {
          // oracle returns duplicate/redundant data in numeric rows.
          if (is_numeric($key)) continue;

          // remove possible trailing whitespaces.
          $v = trim($value);

          if ($key == 'building_code') {
            $building_item['machine_name'] = $v;
            $building_item['disabled'] = 0;
          }
          elseif ($key == 'building_desc') {
            $building_item['human_name'] = $v;
          }
          elseif ($key == 'room_number') {
            $room_item['machine_name'] = $v;
            $room_item['disabled'] = 0;

            // Banner stores other things inside of the room number, so if it actually is a number, store it in the human name, which contains the description.
            if (isset($room_item['human_name']) && cf_is_integer($room_item['machine_name'])) {
              if (empty($room_item['human_name'])) {
                $room_item['human_name'] = "Room #"  . $room_item['machine_name'];
              }
              else {
                $room_item['human_name'] .= " " . $room_item['machine_name'];
              }
            }
          }
          elseif ($key == 'room_desc') {
            $room_item['human_name'] = $v;

            // Banner stores other things inside of the room number, so if it actually is a number, store it in the human name, which contains the description.
            if (isset($room_item['machine_name']) && cf_is_integer($room_item['machine_name'])) {
              if (empty($room_item['human_name'])) {
                $room_item['human_name'] = "Room";
              }
              $room_item['human_name'] .= " #" . $room_item['machine_name'];
            }
          }
          elseif ($key == 'capacity') {
            $room_item['capacity_normal'] = $v;
          }
          elseif ($key == 'max_capacity') {
            $room_item['capacity_max'] = $v;
          }
          elseif ($key == 'category') {
            $location_item['machine_name'] = $v;
            $location_item['human_name'] = $v;
            $location_item['disabled'] = 0;

            if (array_key_exists($v, $request_locations)) {
              $location_item['human_name'] = substr($request_locations[$v], 0, 63);
            }
          }
          elseif ($key == 'room_coordinator_email') {
            $coordinator_room_item['email'] = $v;
          }
          elseif ($key == 'venue_coordinator_email') {
            $coordinator_venue_item['email'] = $v;

            // have the room coordinator fallback to the venue coordinator if no room coordinator is specified.
            if (!isset($coordinator_room_item['email'])) {
              $coordinator_room_item['email'] = $v;
            }
          }
        }

        // add the room and venue coordinators.
        $room_coordinator = NULL;
        if (!empty($coordinator_room_item['email'])) {
          $room_coordinator = mfcs_ensure_user_by_email($coordinator_room_item['email'], array('reviewer'));
        }

        if (!is_object($room_coordinator) && !empty($coordinator_venue_item['email'])) {
          $room_coordinator = mfcs_ensure_user_by_email($coordinator_venue_item['email'], array('reviewer', 'requester'));
        }

        if (is_object($room_coordinator)) {
          $room_item['coordinator_id'] = $room_coordinator->uid;
        }
        else {
          $room_item['coordinator_id'] = MFCS_FAILSAFE_COORDINATOR_ID;
        }

        // add/update the location.
        $query = db_select('mfcs_banner_locations', 'mbl');
        $query->addField('mbl', 'id', 'id');
        $query->condition('mbl.machine_name', $location_item['machine_name']);

        $location_id = $query->execute()->fetchField();
        $location_item['date'] = $instance;

        if ($location_id > 0) {
          $query = db_update('mfcs_banner_locations');
          $query->fields($location_item);
          $query->condition('id', $location_id);
          $query->execute();
        }
        else {
          $query = db_insert('mfcs_banner_locations');
          $query->fields($location_item);
          $location_id = $query->execute();
        }

        // add/update the building.
        $query = db_select('mfcs_banner_buildings', 'mbb');
        $query->addField('mbb', 'id', 'id');
        $query->condition('mbb.machine_name', $building_item['machine_name']);

        $building_id = $query->execute()->fetchField();
        $building_item['date'] = $instance;

        if ($building_id > 0) {
          $query = db_update('mfcs_banner_buildings');
          $query->fields($building_item);
          $query->condition('id', $building_id);
          $query->execute();
        }
        else {
          $query = db_insert('mfcs_banner_buildings');
          $query->fields($building_item);
          $building_id = $query->execute();
        }

        $room_item['building'] = $building_id;
        $room_item['date'] = $instance;

        // add/update the room.
        $query = db_select('mfcs_banner_rooms', 'mbr');
        $query->addField('mbr', 'id', 'id');
        $query->condition('mbr.machine_name', $room_item['machine_name']);
        $query->condition('mbr.building', $building_id);

        $room_id = $query->execute()->fetchField();

        if ($room_id > 0) {
          $query = db_update('mfcs_banner_rooms');
          $query->fields($room_item);
          $query->condition('id', $room_id);
          $query->execute();
        }
        else {
          $query = db_insert('mfcs_banner_rooms');
          $query->fields($room_item);
          $room_id = $query->execute();
        }

        // add/update the location to building relations
        $location_to_building_item['location'] = $location_id;
        $location_to_building_item['building'] = $building_id;
        $location_to_building_item['disabled'] = 0;
        $location_to_building_item['date'] = $instance;

        $query = db_select('mfcs_banner_building_to_location', 'mbbl');
        $query->addExpression('count(mbbl.building)');
        $query->condition('mbbl.location', $location_id);
        $query->condition('mbbl.building', $building_id);

        $building_to_location_count = $query->execute()->fetchField();

        if ($building_to_location_count > 0) {
          $query = db_update('mfcs_banner_building_to_location');
          $query->fields($location_to_building_item);
          $query->condition('location', $location_id);
          $query->condition('building', $building_id);
          $query->execute();
        }
        else {
          $query = db_insert('mfcs_banner_building_to_location');
          $query->fields($location_to_building_item);
          $query->execute();
        }
      }
    }

    // enforce transaction execution
    unset($transaction);
  } catch (Exception $ex) {
    $transaction->rollback();
    cf_error::on_exception($ex);

    return FALSE;
  }


  $rows = mfcs_oracle_select('select distinct role from ucs.msu_event_role');

  if (!empty($rows) && is_array($rows)) {
    $transaction = db_transaction();
    try {
      $query = db_update('mfcs_banner_event_roles');
      $query->fields(array('disabled' => 1, 'date' => $instance));
      $query->condition('disabled', 0);
      $query->execute();

      foreach ($rows as $row) {
        if (!is_array($row)) {
          continue;
        }

        foreach ($row as $key => $role) {
          // oracle returns duplicate/redundant data in numeric rows.
          if (is_numeric($key)) continue;

          // add/update the role.
          $mfcs_banner_event_roles_item['machine_name'] = $role;
          $mfcs_banner_event_roles_item['disabled'] = 0;
          $mfcs_banner_event_roles_item['date'] = $instance;

          $query = db_select('mfcs_banner_event_roles', 'mber');
          $query->addExpression('count(mber.id)');
          $query->condition('mber.machine_name', $role);

          $mfcs_banner_event_roles_count = $query->execute()->fetchField();

          if ($mfcs_banner_event_roles_count > 0) {
            $query = db_update('mfcs_banner_event_roles');
            $query->fields($mfcs_banner_event_roles_item);
            $query->condition('machine_name', $role);
            $query->execute();
          }
          else {
            $query = db_insert('mfcs_banner_event_roles');
            $query->fields($mfcs_banner_event_roles_item);
            $query->execute();
          }
        }
      }

      // enforce transaction execution
      unset($transaction);
    } catch (Exception $ex) {
      $transaction->rollback();
      cf_error::on_exception($ex);

      return FALSE;
    }
  }

  return mfcs_sync_banner_to_local_users();
}

/**
 * Synchronizes the local database with the banner venue information for users.
 *
 * @param null|string $user_id
 *   (optional) If not NULL, the user id of the user to sync data from.
 *   When NULL, process all local users.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_sync_banner_to_local_users($user_id = NULL) {
  if (!is_null($user_id) && !cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  $banner_id = NULL;
  if (!is_null($user_id)) {
    $user = user_load($user_id);

    if (!is_object($user) || !isset($user->field_user_banner_id['und'][0]['value'])) {
      return FALSE;
    }

    $banner_id = $user->field_user_banner_id['und'][0]['value'];

    if (empty($banner_id) || !is_numeric($banner_id)) {
      return FALSE;
    }
  }

  $instance = mfcs_instance();

  if (is_null($banner_id)) {
    $rows = mfcs_oracle_select('select id, role from ucs.msu_event_role');
  }
  else {
    $rows = mfcs_oracle_select('select id, role from ucs.msu_event_role where id = \'' . $banner_id . '\'');
  }

  if (!empty($rows) && is_array($rows)) {
    $transaction = db_transaction();
    try {
      $query = db_select('mfcs_banner_event_roles', 'mber');
      $query->addField('mber', 'machine_name', 'role');
      $query->addField('mber', 'id', 'id');

      $roles_by_name = $query->execute()->fetchAllKeyed();

      $query = db_update('mfcs_banner_event_roles_to_users');
      $query->fields(array('disabled' => 1, 'date' => $instance));
      $query->condition('disabled', 0);

      if (!is_null($banner_id)) {
        $query->condition('user_id', $user_id);
      }

      $query->execute();

      foreach ($rows as $row) {
        if (!is_array($row)) {
          continue;
        }

        if (!isset($roles_by_name[$row['role']])) {
          continue;
        }

        // add/update the roles to users.
        if (is_null($banner_id)) {
          $query = db_select('field_data_field_user_banner_id', 'fdfubi');
          $query->addField('fdfubi', 'entity_id', 'user_id');
          $query->condition('fdfubi.field_user_banner_id_value', $row['id']);

          $user_id = $query->execute()->fetchField();
        }

        if ($user_id > 0) {
          $mfcs_banner_event_roles_item['user_id'] = $user_id;
          $mfcs_banner_event_roles_item['event_role_id'] = $roles_by_name[$row['role']];
          $mfcs_banner_event_roles_item['disabled'] = 0;
          $mfcs_banner_event_roles_item['date'] = $instance;

          if (is_null($banner_id)) {
            $user_id = $query->execute()->fetchField();
          }

          $query = db_select('mfcs_banner_event_roles_to_users', 'mberu');
          $query->addExpression('count(mberu.user_id)');
          $query->condition('mberu.user_id', $user_id);
          $query->condition('mberu.event_role_id', $roles_by_name[$row['role']]);

          $mfcs_banner_event_roles_count = $query->execute()->fetchField();

          if ($mfcs_banner_event_roles_count > 0) {
            $query = db_update('mfcs_banner_event_roles_to_users');
            $query->fields($mfcs_banner_event_roles_item);
            $query->condition('user_id', $user_id);
            $query->condition('event_role_id', $roles_by_name[$row['role']]);
            $query->execute();
          }
          else {
            $query = db_insert('mfcs_banner_event_roles_to_users');
            $query->fields($mfcs_banner_event_roles_item);
            $query->execute();
          }
        }
      }

      // enforce transaction execution
      unset($transaction);
    } catch (Exception $ex) {
      $transaction->rollback();
      cf_error::on_exception($ex);

      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Executes the cron queue to recreate the oracle cache.
 *
 * This requires the ultimate_cron module to function.
 *
 * @see mfcs_cronapi()
 */
function mfcs_oracle_recache_cron() {
  mfcs_sync_banner_to_local();
}

/**
 * Executes the cron queue to send out insurance not provided reminders.
 *
 * This requires the ultimate_cron module to function.
 *
 * @see mfcs_cronapi()
 */
function mfcs_insurance_not_provided_alert_cron() {
  mfcs_include(MFCS_INCLUDE_WORKFLOW);

  $system_user = user_load(1);

  $parameters = array();
  $parameters['changed_by'] = $system_user->uid;
  $parameters['changed_type'] = 'system';
  $parameters['reminder'] = TRUE;
  $parameters['reminder_reason'] = 'insurance_provided';

  $processed = array(
    MFCS_REMINDER_INTERVAL_DAY_30 => array(),
  );

  $dates = mfcs_request_reminders_get_dates();

  foreach ($processed as $interval => &$processed_values) {
    if ($interval == MFCS_REMINDER_INTERVAL_DAY_30) {
      $from = strtotime('+30 days', $dates['today']);
      $to = strtotime('tomorrow', $from);

      $parameters['message_priority'] = MFCS_MAIL_PRIORITY_HIGH;
    }
    else {
      continue;
    }

    mfcs_clear_request_reminders(MFCS_REMINDER_TYPE_INSURANCE_NOT_PROVIDED);

    $results = mfcs_get_requests_not_providing_insurance($from, $to);
    if (!empty($results)) {
      $sent = array();

      foreach ($results as $result) {
        if (array_key_exists($result->id, $processed_values)) {
          continue;
        }

        $reminders = mfcs_get_request_reminders($dates, MFCS_REMINDER_TYPE_INSURANCE_NOT_PROVIDED, $interval, $result->id);

        // if the reminder has already been sent, do not resend.
        if (isset($reminders[$interval][$result->id])) {
          continue;
        }

        // create a new instance for every reminder e-mail.
        mfcs_instance(TRUE);

        $parameters['reminder_data'] = $result;
        $parameters['reminder_data']->interval = $interval;
        mfcs_send_workflow_emails($result->id, $parameters);

        $sent[$result->id] = array(
          'request_id' => $result->id,
          'date' => $dates['today'],
          'type' => MFCS_REMINDER_TYPE_INSURANCE_NOT_PROVIDED,
          'interval' => $interval,
        );

        $processed_values[$result->id] = $result->id;
        unset($parameters['reminder_data']);
      }

      foreach ($sent as $reminder) {

        mfcs_save_request_reminders($reminder);
      }
    }
  }
}
/**
 * Executes the cron queue to cancel requests older than the current day.
 *
 * This requires the ultimate_cron module to function.
 *
 * @see mfcs_cronapi()
 */
function mfcs_autocancel_old_requests_cron() {
  $status = array(
    MFCS_REQUEST_STATUS_UNLOCKED,
    MFCS_REQUEST_STATUS_LOCKED,
  );

  $date = strtotime('midnight today');

  $unresolved_requests = array();

  try {
    $query = db_select('mfcs_requests', 'mer');

    $query->innerJoin('mfcs_current_top', 'mct', 'mer.id = mct.request_id');
    $query->innerJoin('mfcs_field_top_status', 'mfts', 'mct.request_id = mfts.request_id AND mct.status = mfts.revision AND mfts.delta = 0');

    $query->innerJoin('mfcs_current_dates', 'mcd', 'mer.id = mcd.request_id');
    $query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mcd.request_id = mfdd.request_id AND mcd.date = mfdd.revision');

    $query->addField('mer', 'id', 'id');

    $query->condition('mfts.value', $status, 'IN');
    $query->condition('mfdd.value', $date, '<');

    $query->distinct();

    $unresolved_requests = $query->execute()->fetchAllAssoc('id');
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);

    return;
  }

  if (empty($unresolved_requests)) {
    return;
  }

  // cron jobs are considered to have been executed by the admin account as far as logs are concerned.
  $system_user = user_load(1);

  mfcs_include(MFCS_INCLUDE_WORKFLOW);

  foreach ($unresolved_requests as $request_id => $request_object) {
    // create a new instance for every unresolved request.
    mfcs_instance(TRUE);

    $cancelled = mfcs_workflow_set_status($request_id, MFCS_REQUEST_STATUS_CANCELLED, $system_user);

    if ($cancelled) {
      $parameters = array();
      $parameters['changed_by'] = $system_user->uid;
      $parameters['changed_type'] = 'user';
      $parameters['cancelled'] = TRUE;
      $parameters['auto-cancelled'] = TRUE;
      $parameters['auto-cancelled-reason'] = "One or more dates associated with the request are now in the past.";
      mfcs_send_workflow_emails($request_id, $parameters);
    }
    else {
      watchdog(MFCS_WATCHDOG_ID, "An error occured while trying to auto-cancel the request: @request_id.", array('@request_id' => $request_id), WATCHDOG_ERROR);
    }
  }
}

/**
 * Generate an array structure for a specific request item.
 *
 * @param int $request_id
 *   The id representing the specific request.
 * @param string $field_group
 *   The name of the group the values are associated with.
 * @param string $field_name
 *   The name of the field the values are associated with.
 * @param array $values
 *   An array of values associated with this field.
 * @param array $presentation
 *   A collection of variables to tweak how this value is presented.
 * @param array $request
 *   The request array containing all of the request values.
 *
 * @return array|bool|null
 *   The built array.
 *   NULL is returned when there should be no array to build.
 *   FALSE is returned on failure.
 */
function mfcs_build_request_item_structure($request_id, $field_group, $field_name, $values, $presentation, $request) {
  if (!cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  if (!is_string($field_group)) {
    cf_error::invalid_string('field_group');
    return FALSE;
  }

  if (!is_string($field_name)) {
    cf_error::invalid_string('field_name');
    return FALSE;
  }

  if (!is_array($values)) {
    cf_error::invalid_array('values');
    return FALSE;
  }

  if (!is_array($presentation)) {
    cf_error::invalid_array('presentation');
    return FALSE;
  }

  $request = mfcs_load_request_by_id($request_id);
  if (empty($request)) {
    return FALSE;
  }

  // define if the label should be displayed or not.
  $label_display = TRUE;
  if (!empty($presentation['label_display'])) {
    $label_display = (bool) $presentation['label_display'];
  }

  // define when label gets placed (prepend or postpend).
  $label_prepend = TRUE;
  if (!empty($presentation['label_prepend'])) {
    $label_prepend = (bool) $presentation['label_prepend'];
  }

  // define when label gets placed (prepend or postpend).
  $size = 'auto';
  if (!empty($presentation['size'])) {
    $size = (string) $presentation['size'];
  }

  // define the label text presented to the user.
  $label = '';
  if (isset($presentation['label'])) {
    $label = $presentation['label'];
  }

  $label_length = strlen($label);

  $output = array();
  $no_values = TRUE;
  foreach ($values as $delta => &$value) {
    $generated = mfcs_build_request_value_structure($request_id, $field_group, $field_name, $delta, $value, $presentation, $request);

    if ($generated !== FALSE && !isset($generated['no_values'])) {
      $id = 'field-request-' . $request_id . '-item-' . $field_group . '-' . $field_name . '-' . $delta;

      if ($size == 'auto') {
        $size = 'small';

        $value_length = 0;
        if (!empty($generated)) {
          foreach ($generated as $key => $generated_value) {
            if (isset($generated_value['markup']['#length'])) {
              $value_length += $generated_value['markup']['#length'];
            }
          }
        }

        if ($label_length + $value_length > 50) {
          $size = 'large';
        }
      }

      $output[$delta] = array(
        '#id' => $id,
        '#type' => 'container',
        '#attributes' => array(
          'class' => array(
            'item-delta-' . $delta,
            'item-request-' . $request_id,
            'item-group-' . $field_group,
            'item-field-' . $field_name,
            'item-size-' . $size,
            'item-request',
          ),
        ),
      );

      if ($label_display) {
        $output[$delta]['label'] = array(
          '#type' => 'container',
          '#attributes' => array(
            'class' => array(
              'item-label',
            ),
          ),
          '#weight' => ($label_prepend) ? -1 : 1,
        );

        $output[$delta]['label']['markup'] = array(
          '#markup' => $label,
        );
      }

      $output[$delta]['value'] = $generated;
      $no_values = FALSE;
    }

    unset($generated);
  }

  if ($no_values) {
    // this is added in case later on it is decided that $output should be returned.
    // the item class needs to communicate that this group has no values.
    $delta = 0;

    $class = $field_group . '-' . $field_name . '-' . $delta;
    $id = 'field-request-' . $request_id . '-item-' . $class;

    $output = array();
    $output[$delta] = array(
      '#id' => $id,
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
          'field-request-item',
          'field-request-item-' . $class,
          'field-request-item-size-' . $size,
        ),
      ),
    );

    $output['item']['#attributes']['class'][] = 'field-request-item-no_values';

    return NULL;
  }

  return $output;
}

/**
 * Generate an array structure for a specific request value.
 *
 * @param int $request_id
 *   The id representing the specific request.
 * @param string $field_group
 *   The name of the group the values are associated with.
 * @param string $field_name
 *   The name of the field the values are associated with.
 * @param int $delta
 *   This is for multiple values, each value has its own delta.
 * @param object $value
 *   The value object in the format in the database structure or in a sumulated
 *   structure.
 * @param array $presentation
 *   A collection of variables to tweak how this value is presented.
 * @param array $request
 *   The request array containing all of the request values.
 * @param array $options
 *   (optional) An array of options tweaking how this function will run.
 *   - 'no_prefix': If TRUE, don't show prefix.
 *   - 'no_suffix': If TRUE, don't show suffix.
 *   - 'print_delta_for_multiple': If TRUE, prepend the delta to the value for
 *      fields that have #multiple set to TRUE.
 *
 * @return array|bool
 *   The built array.
 *   FALSE is returend on failure.
 */
function mfcs_build_request_value_structure($request_id, $field_group, $field_name, $delta, $value, $presentation, $request, $options = array()) {
  if (!is_string($field_group)) {
    cf_error::invalid_string('field_group');
    return FALSE;
  }

  if (!is_string($field_name)) {
    cf_error::invalid_string('field_name');
    return FALSE;
  }

  if (!cf_is_integer($delta)) {
    cf_error::invalid_integer('delta');
    return FALSE;
  }

  if (!is_object($value)) {
    cf_error::invalid_object('value');
    return FALSE;
  }

  if (!is_array($presentation)) {
    cf_error::invalid_array('presentation');
    return FALSE;
  }

  $request = mfcs_load_request_by_id($request_id);
  if (empty($request)) {
    return FALSE;
  }

  if (!is_array($options)) {
    cf_error::invalid_array('options');
    return FALSE;
  }

  // define the combined option.
  $combined = FALSE;
  if (!empty($presentation['combined'])) {
    $combined = (bool) $presentation['combined'];
  }

  // define the presentation type.
  $type = array('value' => 'string');
  if (!empty($presentation['type'])) {
    $type = (array) $presentation['type'];
  }

  // define the presentation display.
  $display = array('value' => 'raw');
  if (!empty($presentation['display'])) {
    $display = (array) $presentation['display'];
  }

  // define the presentation value names.
  $value_names = array('value');
  if (!empty($presentation['value_names'])) {
    $value_names = (array) $presentation['value_names'];
  }

  // define a prefix to append before the value.
  $prefix_span_class = 'item-value-instance ';
  $prefix_span_class .= 'item-value-instance-' . $field_group . ' ';
  $prefix_span_class .= 'item-value-instance-' . $field_group . '-' . $field_name . ' ';
  $prefix_span_class .= 'item-value-instance-' . $field_group . '-' . $field_name . '-' . $delta . ' ';
  $prefix = '<span class="' . $prefix_span_class . '">';
  if (!empty($presentation['prefix'])) {
    $prefix .= $presentation['prefix'];
  }

  if (isset($options['no_prefix']) && $options['no_prefix']) {
    $prefix = '';
  }

  // define a suffix to prepend after the value.
  $suffix = '';
  if (!empty($presentation['suffix'])) {
    $suffix = $presentation['suffix'];
  }
  $suffix .= '</span>';

  if (isset($options['no_suffix']) && $options['no_suffix']) {
    $suffix = '';
  }

  $delta_prefix = '';
  if (isset($options['print_delta_for_multiple']) && $options['print_delta_for_multiple']) {
    if (isset($presentation['multiple']) && $presentation['multiple']) {
      $delta_prefix = '<span class="item-delta">[' . $delta . ']</span> ';
    }
  }

  $venue_coordinator = NULL;
  if (!empty($request['venue_coordinator']['user_id'][0]->value)) {
    $venue_coordinator = user_load($request['venue_coordinator']['user_id'][0]->value);
  }

  global $base_path;

  $id = 'field-request-' . $request_id . '-item-' . $field_group . '-' . $field_name . '-' . $delta . '-value';

  $output = array();
  $empty_value = TRUE;
  $no_values = TRUE;

  foreach ($value_names as $value_name) {
    if ($combined) {
      if (!isset($output['value']['markup']['#markup'])) {
        $output['value'] = array(
          '#id' => $id . '-' . $value_name,
          '#type' => 'container',
          '#attributes' => array(
            'class' => array(
              'item-value',
              'item-value-name-' . $value_name,
            ),
          ),
        );

        $output['value']['markup'] = array(
          '#markup' => NULL,
        );

        if (!array_key_exists('value', $type)) {
          $type['value'] = 'string';
        }

        $output['value']['#attributes']['class'][] = 'item-value-type-value';

        $output['value']['markup']['#length'] = 0;
      }

      $markup = &$output['value']['markup']['#markup'];
      $output_value = &$output['value'];
      $length = &$output['value']['markup']['#length'];
    }
    else {
      $output[$value_name] = array(
        '#id' => $id . '-' . $value_name,
        '#type' => 'container',
        '#attributes' => array(
          'class' => array(
            'item-value',
            'item-value-name-' . $value_name,
          ),
        ),
      );

      $output[$value_name]['markup'] = array(
        '#markup' => NULL,
      );

      if (!array_key_exists($value_name, $type)) {
        $type[$value_name] = 'string';
      }

      $output[$value_name]['#attributes']['class'][] = 'item-value-type-' . $type[$value_name];
      $output['value']['markup']['#length'] = 0;

      $markup = &$output[$value_name]['markup']['#markup'];
      $output_value = &$output[$value_name];
      $length = &$output['value']['markup']['#length'];
    }

    if (property_exists($value, $value_name) && (is_numeric($value->$value_name) || !empty($value->$value_name))) {
      if ($type[$value_name] == 'string' || $type[$value_name] == 'text') {
        $markup .= check_plain($value->$value_name);

        $length += strlen($value->$value_name);
      }
      elseif ($type[$value_name] == 'timestamp') {
        if (!array_key_exists($value_name, $display)) {
          $display[$value_name] = 'Y/m/d h:ia';
        }

        if ($display[$value_name] == 'stamp') {
          $markup .= check_plain($value->$value_name);
        }
        else {
          $markup .= check_plain(date($display[$value_name], $value->$value_name));
        }

        $length += strlen($value->$value_name);
      }
      elseif ($type[$value_name] == 'timestamp_linked_month') {
        if (!array_key_exists($value_name, $display)) {
          $display[$value_name] = 'Y/m/d';
        }

        if ($display[$value_name] == 'stamp') {
          $markup .= check_plain($value->$value_name);
        }
        else {
          $s_year = date('Y', $value->$value_name);
          $s_month = date('F', $value->$value_name);
          $s_title = $s_month . " " . $s_year;

          $markup .= '<a href="' . $base_path . 'requests/calendar-0/month/' . $s_year . '/' . $s_month .'" title="' . $s_title . '">' . check_plain(date($display[$value_name], $value->$value_name)) . '</a>';

          unset($s_year);
          unset($s_month);
          unset($s_title);
        }

        $length += strlen($value->$value_name);
      }
      elseif ($type[$value_name] == 'timestamp_linked_day') {
        if (!array_key_exists($value_name, $display)) {
          $display[$value_name] = 'Y/m/d';
        }

        if ($display[$value_name] == 'stamp') {
          $markup .= check_plain($value->$value_name);
        }
        else {
          $s_year = date('Y', $value->$value_name);
          $s_month = date('F', $value->$value_name);
          $s_day = date('d', $value->$value_name);
          $s_title = $s_month . ", " . $s_day . ", " . $s_year;

          $markup .= '<a href="' . $base_path . 'requests/calendar-0/day/' . $s_year . '/' . $s_month . '/' . $s_day .'" title="' . $s_title . '">' . check_plain(date($display[$value_name], $value->$value_name)) . '</a>';

          unset($s_year);
          unset($s_month);
          unset($s_day);
          unset($s_title);
        }

        $length += strlen($value->$value_name);
      }
      elseif ($type[$value_name] == 'timestamp_linked_hour') {
        if (!array_key_exists($value_name, $display)) {
          $display[$value_name] = 'h:ia';
        }

        if ($display[$value_name] == 'stamp') {
          $markup .= check_plain($value->$value_name);
        }
        else {
          $s_year = date('Y', $value->$value_name);
          $s_month = date('F', $value->$value_name);
          $s_day = date('d', $value->$value_name);
          $s_hour = date('h', $value->$value_name);
          $s_ampm = date('a', $value->$value_name);
          $s_title = $s_month . ", " . $s_day . ", " . $s_year . " at " . $s_hour . ':00' . $s_ampm;
          $s_id = 'time_slot-' . $s_hour . '_00' . $s_ampm;

          $markup .= '<a href="' . $base_path . 'requests/calendar-0/day/' . $s_year . '/' . $s_month . '/' . $s_day . '#' . $s_id .'" title="' . $s_title . '">' . check_plain(date($display[$value_name], $value->$value_name)) . '</a>';

          unset($s_year);
          unset($s_month);
          unset($s_day);
          unset($s_hour);
          unset($s_ampm);
          unset($s_title);
          unset($s_id);
        }

        $length += strlen($value->$value_name);
      }
      elseif ($type[$value_name] == 'taxonomy') {
        $term = taxonomy_term_load($value->$value_name);

        if (is_object($term)) {
          $markup .= check_plain($term->name);
          $length += strlen($term->name);
        }

        unset($term);
      }
      elseif ($type[$value_name] == 'user_id') {
        $user = user_load($value->$value_name);

        if (is_object($user)){
          if (!array_key_exists($value_name, $display)) {
            $display[$value_name] = 'name';
          }

          $user_name = check_plain($user->name);

          if (!empty($user->field_user_last_name['und'][0]['value'])) {
            $user_name = check_plain($user->field_user_last_name['und'][0]['value']) . ', ';
          }

          if (!empty($user->field_user_first_name['und'][0]['value'])) {
            $user_name .= check_plain($user->field_user_first_name['und'][0]['value']);
          }

          if ($display[$value_name] == 'account_name') {
            $markup .= '<a href="' . $base_path . 'user/' . $user->uid . '">' . $user_name . '</a>';
            $length += strlen($user_name);
          }
          elseif ($display[$value_name] != 'pass' && property_exists($user, $display)) {
            $markup .= check_plain($user->$display[$value_name]);
            $length += strlen($user->$display[$value_name]);
          }
        }

        unset($user);
      }
      elseif ($type[$value_name] == 'status') {
        mfcs_include(MFCS_INCLUDE_LIST_OPTIONS);

        $status_options = mfcs_get_request_status_list_options();

        if (isset($status_options[$value->$value_name])) {
          $markup .= $status_options[$value->$value_name];
          $length += strlen($value->$value_name);
        }
      }
      elseif ($type[$value_name] == 'step') {
        mfcs_include(MFCS_INCLUDE_LIST_OPTIONS);

        $step_options = mfcs_get_request_steps_list_options();

        if (isset($step_options[$value->$value_name])) {
          $markup .= $step_options[$value->$value_name];
          $length += strlen($step_options[$value->$value_name]);
        }
      }
      elseif ($type[$value_name] == 'location') {
        mfcs_include(MFCS_INCLUDE_LIST_OPTIONS);

        $location_options = mfcs_get_request_location_list_options(NULL, FALSE, TRUE);

        if (isset($location_options[$value->$value_name])) {
          $markup .= $location_options[$value->$value_name];
          $length += strlen($location_options[$value->$value_name]);
        }
      }
      elseif ($type[$value_name] == 'building') {
        mfcs_include(MFCS_INCLUDE_LIST_OPTIONS);

        $building_options = mfcs_get_request_building_list_options(NULL, NULL, TRUE);

        if (isset($building_options[$value->$value_name])) {
          $markup .= $building_options[$value->$value_name];
          $length += strlen($building_options[$value->$value_name]);
        }
      }
      elseif ($type[$value_name] == 'room') {
        mfcs_include(MFCS_INCLUDE_LIST_OPTIONS);

        $room_options = mfcs_get_request_room_list_options(NULL, NULL, TRUE);

        if (isset($room_options[$value->$value_name])) {
          $markup .= $room_options[$value->$value_name];
          $length += strlen($room_options[$value->$value_name]);
        }
      }
      elseif ($type[$value_name] == 'currency') {
        $currency = mfcs_convert_value_from_database_format($value->$value_name, 'currency');

        if ($currency !== FALSE) {
          $processed_markup = '$' . printf('%01.2f', $currency);
          $markup .= $processed_markup;
          $length += strlen($processed_markup);
        }
      }
      elseif ($type[$value_name] == 'boolean') {
        $boolean = (bool) $value->$value_name;

        if ($boolean) {
          $markup .= 'yes';
          $length += 3;
        }
        else {
          $markup .= 'no';
          $length += 2;
        }

        if ($display[$value_name] == 'when_true') {
          if (!$boolean) {
            continue;
          }
        }
        elseif ($display[$value_name] == 'when_false') {
          if ($boolean) {
            continue;
          }
        }
      }
      elseif ($type[$value_name] == 'requirement_personnel') {
        $markup .= ' ' . $value->$value_name . ' personnel';
        $length += strlen($value->$value_name . ' personnel');
      }
      elseif ($type[$value_name] == 'requirement_hours') {
        $hours = mfcs_convert_value_from_database_format($value->$value_name, 'currency');

        if (intval($hours) == $hours) {
          $markup .= ' ' . $hours . ' hours';
        }
        else {
          $markup .= ' ' . sprintf('%01.2f', $hours) . ' hours';
        }

        $length += strlen($hours . ' hours');
      }
      elseif ($type[$value_name] == 'requirement_days') {
        $days = mfcs_convert_value_from_database_format($value->$value_name, 'currency');

        if (intval($days) == $days) {
          $markup .= ' ' . $days . ' days';
        }
        else {
          $markup .= ' ' . sprintf('%01.2f', $days) . ' days';
        }

        $length += strlen($days . 'days');
      }
      elseif ($type[$value_name] == 'requirement_amount') {
        $amount = mfcs_convert_value_from_database_format($value->$value_name, 'currency');

        if ($amount !== FALSE) {
          $processed_markup = ' at $' . sprintf('%01.2f', $amount);

          // calculate total and append from other fields that should exist.
          $total = $amount;

          if (in_array('quantity', $value_names) && isset($value->quantity) && is_numeric($value->quantity)) {
            $total = $total * $value->quantity;
          }

          if (in_array('hours', $value_names) && isset($value->hours) && is_numeric($value->hours)) {
            $hours = mfcs_convert_value_from_database_format($value->hours, 'currency');

            if ($hours !== FALSE) {
              $total = $total * $hours;
            }
          }

          if (in_array('days', $value_names) && isset($value->days) && is_numeric($value->days)) {
            $days = mfcs_convert_value_from_database_format($value->days, 'currency');

            if ($days !== FALSE) {
              $total = $total * $days;
            }
          }

          $processed_markup .= ' = $' . sprintf('%01.2f', $total);

          $markup .= $processed_markup;
          $length += strlen($processed_markup);
        }
      }
      elseif ($type[$value_name] == 'venue_coordinator') {
        if ($display[$value_name] == 'name') {
          $processed_markup = '';

          $first_name = FALSE;
          if (!empty($venue_coordinator->field_user_last_name['und'][0]['safe_value'])) {
            $first_name = TRUE;
            $processed_markup .= $venue_coordinator->field_user_last_name['und'][0]['safe_value'];
          }

          if (!empty($venue_coordinator->field_user_first_name['und'][0]['safe_value'])) {
            if ($first_name) {
              $processed_markup .=  ', ';
            }

            $processed_markup .= $venue_coordinator->field_user_first_name['und'][0]['safe_value'];
          }

          $markup .= $processed_markup;
          $length += strlen($processed_markup);
        }
        elseif ($display[$value_name] == 'email') {
          $markup .= $venue_coordinator->mail;
          $length += strlen($venue_coordinator->mail);
        }
        elseif ($display[$value_name] == 'phone') {
          if (!empty($venue_coordinator->field_user_phone_number['und'][0]['safe_value'])) {
            $markup .= $venue_coordinator->field_user_phone_number['und'][0]['safe_value'];
            $length += strlen($venue_coordinator->field_user_phone_number['und'][0]['safe_value']);
          }
        }
      }
      elseif ($type[$value_name] == 'review_decision') {
        if ($value->$value_name == MFCS_REVIEW_DECISION_APPROVE) {
          $markup .= "Approved";
          $length += strlen("Approved");
        }
        elseif ($value->$value_name == MFCS_REVIEW_DECISION_DENY) {
          $markup .= "Denied";
          $length += strlen("Denied");
        }
      }

      if (!is_numeric($markup) && empty($markup)) {
        $output_value['#attributes']['class'][] = 'empty_value';
      }
      else {
        $empty_value = FALSE;

        if (!$combined) {
          $markup = $delta_prefix . $prefix . $markup . $suffix;
        }
      }

      $no_values = FALSE;
    }
  }

  if ($no_values) {
    $output_value['#attributes']['class'][] = 'no_value';
    $output['no_values'] = TRUE;
  }
  elseif ($combined && !$empty_value) {
    $output['value']['markup']['#markup'] = $delta_prefix . $prefix . $output['value']['markup']['#markup'] . $suffix;
  }

  return $output;
}

/***
 * Convert a given value to the appropraite database format.
 *
 * @param string $value
 *   The date or time string to convert.
 * @param string $method
 *   The method to use for converting.
 * @param string|array $option
 *   (optional) Additional options to pass to the method for conversion.
 * @param array $form_state
 *   (optional) The form state array, containing all available values.
 * @param array $delta
 *   (optional) The delta location for processing data of the same delta.
 *
 * @return
 *   The appropriate datatype suitable for storing into the database.
 *   FALSE is returned on error.
 */
function mfcs_convert_value_to_database_format($value, $method, $option = array(), $form_state = array(), $delta = array()) {
  if ($method == 'timestamp') {
    if (empty($value)) {
      return FALSE;
    }

    if (array_key_exists('relative_to', $option) && is_string($option['relative_to']) && !empty($option['relative_to'])) {
      if (!is_array($form_state) || !array_key_exists('values', $form_state)) {
        return FALSE;
      }

      $current = &$form_state['values'];

      $parts = explode('][', $option['relative_to']);
      foreach ($parts as $part) {
        if (is_array($current) && array_key_exists($part, $current)) {
          $current = &$current[$part];
        }
        else {
          return FALSE;
        }
      }

      if (is_array($current) && array_key_exists($delta, $current)) {
        $current = &$current[$delta];
      }
      else {
        return FALSE;
      }

      $date_stamp = strtotime($current, 0);
      return strtotime($value, $date_stamp);
    }

    return strtotime($value);
  }
  elseif ($method == 'timestamp_relative') {
    if (empty($value)) {
      return FALSE;
    }

    return strtotime($value, 0);
  }
  elseif ($method == 'date_popup') {
    if (!is_string($value) || empty($value)) {
      return FALSE;
    }

    // force the date to begin at the earlies time in the day.
    $date_stamp = strtotime($value);
    $date = date("Y/m/d", $date_stamp);
    return strtotime($date, 0);
  }
  elseif ($method == 'date_month') {
    if (!is_string($value) || empty($value)) {
      return FALSE;
    }

    $date_stamp = strtotime($value);
    return (int) date("m", $date_stamp);
  }
  elseif ($method == 'date_day') {
    if (!is_string($value) || empty($value)) {
      return FALSE;
    }

    $date_stamp = strtotime($value);
    return (int) date("d", $date_stamp);
  }
  elseif ($method == 'currency') {
    if (is_null($value)) {
      return FALSE;
    }

    // shift decimal over to digits.
    return floor($value * 100);
  }

  return FALSE;
}

/***
 * Convert a given value to the appropraite database format.
 *
 * @param string $value
 *   The date or time string to convert.
 * @param string $method
 *   The method to use for converting.
 * @param string|array $option
 *   (optional) Additional options to pass to the method for conversion.
 *
 * @return
 *   The appropriate datatype suitable for storing into the database.
 *   FALSE is returned on error.
 */
function mfcs_convert_value_from_database_format($value, $method, $option = array()) {
  if ($method == 'timestamp') {
    if (empty($value)) return NULL;

    return date($option['view'], $value);
  }
  elseif ($method == 'timestamp_relative') {
    if (empty($value)) return NULL;

    return date($option['view'], $value);
  }
  elseif ($method == 'date_popup') {
    if (empty($value)) return NULL;

    return date('Y-m-d', $value);
  }
  elseif ($method == 'date_month') {
    if (empty($value)) return NULL;

    return $value;
  }
  elseif ($method == 'date_day') {
    if (empty($value)) return NULL;

    return $value;
  }
  elseif ($method == 'currency') {
    if (is_null($value)) return NULL;

    return $value / 100;
  }

  return FALSE;
}

/**
 * Loads an request by its ID.
 *
 * @param int|null $request_id
 *   The numeric request id. Can be null when $reset_action is FALSE.
 * @param bool $reset_action
 *   (optional) If TRUE, the cache for the specified request is reset.
 *   If FALSE, the cache is reset, but no request is loaded.
 *   If NULL, no reset is performed.
 * @param int|NULL $revision_id
 *   (optional) If not NULL, this essentially loads all values for a given
 *   revision.
 *
 * @return array|bool
 *   An array of values associated with the request id.
 *   FALSE is returned on error.
 *   An empty array is returned when there is no request by that id.
 *   TRUE is returned when $reset_action is FALSE because there will ne no
 *   request to return.
 */
function mfcs_load_request_by_id($request_id, $reset_action = NULL, $revision_id = NULL) {
  if (!cf_is_integer($request_id)) {
    if (!($reset_action === FALSE && is_null($request_id))) {
      cf_error::invalid_integer('request_id');
      return FALSE;
    }
  }

  if (!is_null($reset_action) && !is_bool($reset_action)) {
    cf_error::invalid_bool('reset_action');
    return FALSE;
  }

  if (!is_null($revision_id) && !cf_is_integer($revision_id)) {
    cf_error::invalid_integer('revision_id');
    return FALSE;
  }

  $cache_id = __function__;
  $cached_requests = &drupal_static($cache_id, array());
  if (is_null($reset_action) && array_key_exists($request_id, $cached_requests)) {
    if (is_null($revision_id)) {
      if (array_key_exists('latest', $cached_requests[$request_id])) {
        return $cached_requests[$request_id]['latest'];
      }
    }
    else {
      if (array_key_exists($revision_id, $cached_requests[$request_id])) {
        return $cached_requests[$request_id][$revision_id];
      }
    }
  }
  elseif ($reset_action === FALSE) {
    if (is_null($request_id)) {
      $cached_requests = array();
    }
    else {
      unset($cached_requests[$request_id]);
    }

    return TRUE;
  }

  // caching these results can use a lot of memory, so put a hard limit on caching at most 3 at a time.
  if (is_array($cached_requests) && count($cached_requests) > 3) {
    $cached_requests = array();
  }
  // the 'latest' array takes up an array key, so this will have a hard limit of "4" that ends up representing "3".
  elseif (array_key_exists($request_id, $cached_requests) && count($cached_requests[$request_id]) > 4) {
    $cached_requests[$request_id] = array();
  }

  mfcs_include(MFCS_INCLUDE_TABLE);

  $request = array();
  $structure = mfcs_table_structure();

  try {
    $query = db_select('mfcs_requests', 'mer');
    $query->fields('mer');
    $query->condition('id', $request_id);

    if (!is_null($revision_id)) {
      $query->innerJoin('mfcs_request_revisions', 'mrv', 'mer.id = mrv.request_id');
      $query->addField('mrv', 'revision', 'revision');
      $query->addField('mrv', 'date', 'revision_date');
      $query->addField('mrv', 'message', 'revision_message');
      $query->condition('mrv.revision', $revision_id);
    }

    $results = $query->execute()->fetchAll();

    if (empty($results)) {
      return array();
    }

    $mer = array_pop($results);
    $revision_date = NULL;

    // manually add the request information and presentation fields.
    if (!isset($request['mer'])) {
      $request['mer'] = array();
      foreach (array('id', 'user_id', 'created', 'updated') as $key) {
        $request['mer'][$key] = array(0 => new stdClass());
        $request['mer'][$key][0]->value = $mer->$key;
      }

      if (property_exists($mer, 'revision_date')) {
        $revision_date = $mer->revision_date;
        $request['mer']['updated'][0]->value = $revision_date;
      }
    }

    unset($mer);

    foreach ($structure as $table_name => &$fields) {
      $current_table_name = 'mfcs_current_' . $table_name;

      if (!array_key_exists($table_name, $request)) {
        $request[$table_name] = array();
      }

      $query = db_select($current_table_name, 'mctn');
      $query->condition('mctn.request_id', $request_id);
      $query->fields('mctn');

      $results = $query->execute()->fetchAll();

      if (empty($results)) {
        unset($current);
        unset($executed);
        unset($query);

        continue;
      }

      $current = array_pop($results);

      // build a list of current tables so that revision ids may be processed at any point.
      if (!isset($request['current'])) {
        $request['current'] = array();
      }

      $request['current'][$table_name] = array();

      if (is_null($revision_id)) {
        foreach ((array) $current as $current_key => $current_values) {
          if ($current_key == 'request_id') continue;

          $request['current'][$table_name][$current_key] = $current_values;
        }
      }
      else {
        foreach ((array) $current as $current_key => $current_values) {
          if ($current_key == 'request_id') continue;

          $query = db_select('mfcs_field_' . $table_name . '_' . $current_key, 'mftc');
          $query->fields('mftc', array('revision'));
          $query->condition('mftc.request_id', $request_id);
          $query->condition('mftc.date', $revision_date, '<=');
          $query->orderBy('mftc.date', 'DESC');
          $query->range(0, 1);

          $result = $query->execute()->fetchField();

          $request['current'][$table_name][$current_key] = $result;
          $current->$current_key = $result;
        }
      }

      foreach ($fields as $field_name => &$field_values) {
        if (isset($structure[$table_name][$field_name]['storage']) && $structure[$table_name][$field_name]['storage'] == 'alternate' && array_key_exists('alternate', $structure[$table_name][$field_name])) {
          foreach ($structure[$table_name][$field_name]['alternate'] as $alternate_name => &$alternate_data) {
            $field_table_name = 'mfcs_field_' . $table_name . '_' . $alternate_name;

            $query = db_select($field_table_name, 'mftf');
            $query->condition('mftf.request_id', $request_id);
            $query->condition('mftf.revision', $current->$alternate_name);
            $query->fields('mftf');

            $results = $query->execute()->fetchAll();

            if (empty($results)) {
              $request[$table_name][$alternate_name] = array();
            }
            else {
              $request[$table_name][$alternate_name] = $results;
            }
          }
        }
        else {
          $field_table_name = 'mfcs_field_' . $table_name . '_' . $field_name;

          $query = db_select($field_table_name, 'mftf');
          $query->condition('mftf.request_id', $request_id);
          $query->condition('mftf.revision', $current->$field_name);
          $query->fields('mftf');

          $results = $query->execute()->fetchAll();

          if (empty($results)) {
            $request[$table_name][$field_name] = array();
          }
          else {
            $request[$table_name][$field_name] = $results;
          }
        }

        unset($results);
        unset($query);
      }

      unset($current);
      unset($results);
      unset($query);
    }
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  if (empty($request)) {
    watchdog(MFCS_WATCHDOG_ID, "Unable to find request with id of @request_id.", array('@request_id' => $request_id), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!is_null($revision_id)) {
    if (is_null($revision_date)) {
      watchdog(MFCS_WATCHDOG_ID, "Unable to find request with id of @request_id and revision id of @revision_id.", array('@request_id' => $request_id, '@revision_id' => $revision_id), WATCHDOG_ERROR);
      return FALSE;
    }

    $cached_requests[$request_id][$revision_id] = &$request;

    return $cached_requests[$request_id][$revision_id];
  }

  $cached_requests[$request_id]['latest'] = &$request;

  return $cached_requests[$request_id]['latest'];
}

/**
 * Loads request with fields matching a revision timestamp.
 *
 * @param int $request_id
 *   The numeric request id.
 * @param int $timestamp
 *   Unix Timestamp representing the exact date and time to load.
 * @param int $revision_user_id
 *   The user id of the user responsible for the revision at a given timestamp.
 * @param array $desired_fields
 *   (optional) An array of field names to load that match the specified date.
 *   These are nested by their table structure. When an empty array is
 *   provided, all values are used.
 *
 * @return array|bool
 *   An array of values associated with the request, date, and fields.
 *   FALSE is returned on error.
 *
 * @see mfcs_table_structure()
 */
function mfcs_load_request_by_timestamp($request_id, $timestamp, $revision_user_id, $desired_fields = array()) {
  if (!cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  if (!cf_is_integer($timestamp)) {
    cf_error::invalid_integer('timestamp');
    return FALSE;
  }

  if (!cf_is_integer($revision_user_id)) {
    cf_error::invalid_integer('revision_user_id');
    return FALSE;
  }

  if (!is_array($desired_fields)) {
    cf_error::invalid_array('desired_fields');
    return FALSE;
  }

  mfcs_include(MFCS_INCLUDE_TABLE);

  $request = array();
  $structure = mfcs_table_structure();

  // filter out all fields that were not requested.
  if (!empty($desired_fields)) {
    foreach ($structure as $table_name => &$fields) {
      if (!array_key_exists($table_name, $desired_fields)) {
        unset($structure[$table_name]);
        continue;
      }

      foreach ($fields as $field_name => &$field_values) {
        if (!array_key_exists($field_name, $desired_fields)) {
          unset($structure[$field_name]);
          continue;
        }
      }
    }
  }

  try {
    $query = db_select('mfcs_requests', 'mer');
    $query->innerJoin('mfcs_request_revisions', 'mrv', 'mer.id = mrv.request_id');

    $query->fields('mer');
    $query->addField('mrv', 'revision', 'revision');
    $query->addField('mrv', 'date', 'revision_date');
    $query->addField('mrv', 'message', 'revision_message');

    $query->condition('id', $request_id);
    $query->condition('mrv.date', $timestamp);
    $query->condition('mrv.user_id', $revision_user_id);

    $query->orderBy('mrv.date');

    $results = $query->execute()->fetchAll();

    // manually add the request information and presentation fields.
    $request['mer'] = array();
    if (!empty($results)) {
      foreach ($results as $index => $mer) {
        foreach (array('id', 'user_id', 'created', 'updated', 'revision_date', 'revision_message') as $key) {
          if (!isset($request['mer'][$key][$mer->revision])) {
            $request['mer'][$key][$mer->revision] = new stdClass();
          }

          $request['mer'][$key][$mer->revision]->value = $mer->$key;
        }
      }
    }

    foreach ($structure as $table_name => &$fields) {
      $current_table_name = 'mfcs_current_' . $table_name;

      if (!array_key_exists($table_name, $request)) {
        $request[$table_name] = array();
      }

      // build a list of current tables so that revision ids may be processed at any point.
      if (!isset($request['current'])) {
        $request['current'] = array();
      }

      $request['current'][$table_name] = array();

      foreach ($fields as $field_name => &$field_values) {
        if (isset($structure[$table_name][$field_name]['storage']) && $structure[$table_name][$field_name]['storage'] == 'alternate' && array_key_exists('alternate', $structure[$table_name][$field_name])) {
          foreach ($structure[$table_name][$field_name]['alternate'] as $alternate_name => &$alternate_data) {
            $field_table_name = 'mfcs_field_' . $table_name . '_' . $alternate_name;

            $query = db_select($field_table_name, 'mftf');
            $query->condition('mftf.request_id', $request_id);
            $query->condition('mftf.date', $timestamp);
            $query->condition('mftf.user_id', $revision_user_id);
            $query->fields('mftf');

            $results = $query->execute()->fetchAll();

            if (empty($results)) {
              $request[$table_name][$alternate_name] = array();

              $request['current'][$table_name][$field_name] = NULL;
            }
            else {
              $request[$table_name][$alternate_name] = $results;

              $first_result = reset($results);
              $request['current'][$table_name][$field_name] = $first_result->revision;
            }
          }
        }
        else {
          $field_table_name = 'mfcs_field_' . $table_name . '_' . $field_name;

          $query = db_select($field_table_name, 'mftf');
          $query->condition('mftf.request_id', $request_id);
          $query->condition('mftf.date', $timestamp);
          $query->condition('mftf.user_id', $revision_user_id);
          $query->fields('mftf');

          #$results = $query->execute()->fetchAll();
          $executed = $query->execute();
          $results = $executed->fetchAll();

          if (empty($results)) {
            $request[$table_name][$field_name] = array();

            $request['current'][$table_name][$field_name] = NULL;
          }
          else {
            $request[$table_name][$field_name] = $results;

            $first_result = reset($results);
            $request['current'][$table_name][$field_name] = $first_result->revision;
          }
        }

        unset($results);
        unset($query);
      }

      unset($results);
      unset($query);
    }
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  return $request;
}

/**
 * Loads the request revision number.
 *
 * @param int $request_id
 *   The numeric request id.
 * @param string $table_field_name
 *   (optional) The name of a specific table to load a revision number from.
 *   When not specified, this returns the latest revision number of a given
 *   request.
 *
 * @return int|bool
 *  FALSE is returned on error.
 *  NULL is returned when there is no existing revision number.
 */
function mfcs_load_request_revision_number($request_id, $table_field_name = NULL) {
  if (!cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  if (is_null($table_field_name)) {
    try {
      $query = db_select('mfcs_request_revisions', 'mrv');
      $query->addField('mrv', 'revision', 'revision');
      $query->condition('mrv.request_id', $request_id);
      $query->orderBy('mrv.revision', 'DESC');
      $query->range(0, 1);

      $field = $query->execute()->fetchfield();

      if ($field === FALSE) {
        return NULL;
      }

      return $field;
    }
    catch (Exception $ex) {
      cf_error::on_query_execution($ex);
    }

    return FALSE;
  }

  if (!is_string($table_field_name)) {
    cf_error::invalid_string('table_field_name');
    return FALSE;
  }

  try {
    $query = db_select($table_field_name, 'tfn');
    $query->fields('tfn', array('revision'));
    $query->condition('tfn.request_id', $request_id);
    $query->orderBy('tfn.revision', 'DESC');
    $query->range(0, 1);

    $result = $query->execute()->fetchField();

    return $result;
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  return FALSE;
}

/**
 * Loads a system user by its Banner ID.
 *
 * @param int $banner_id
 *   The numeric banner id.
 * @param bool $reset
 *   (optional) If TRUE, the cache for the specified user is reset.
 *
 * @return object|null|bool
 *   The
 *   FALSE is returned on error.
 *   An empty array is returned when there is no request by that id.
 */
function mfcs_load_user_by_banner_id($banner_id, $reset = FALSE) {
  if (!cf_is_integer($banner_id)) {
    cf_error::invalid_integer('banner_id');
    return FALSE;
  }

  $cache_id = __function__;
  $cached_user = &drupal_static($cache_id, NULL);
  if (!$reset && is_array($cached_user) && array_key_exists($banner_id, $cached_user)) {
    return $cached_user[$banner_id];
  }

  try {
    $query = db_select('users', 'u');

    $query->innerJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
    $query->innerJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND fdfuln.delta = 0');
    $query->innerJoin('field_data_field_user_banner_id', 'fdfubi', 'u.uid = fdfubi.entity_id AND fdfubi.delta = 0');

    $query->addField('u', 'uid', 'user_id');
    $query->addField('u', 'name', 'name');
    $query->addField('u', 'created', 'created');
    $query->addField('u', 'status', 'status');
    $query->addField('u', 'mail', 'email');

    $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
    $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');
    $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

    $query->condition('field_user_banner_id_value', $banner_id);

    $results = $query->execute()->fetchAll();
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  if (empty($results)) {
    return NULL;
  }

  $cached_user[$banner_id] = array_pop($results);

  return $cached_user[$banner_id];
}

/**
 * Build the table structure for saving new or existing information.
 *
 * @param array $structure
 *   Describes how the secondary tables are populated and processed.
 * @param array $structure_tables
 *   A collection of 'current' tables to create or update.
 * @param array $structure_field_tables
 *   A collection of 'field' tables to create or update.
 * @param string $table_name
 *   Name of the current table being processed.
 * @param string $field_name
 *   Name of the current field being processed.
 * @param string $db_table
 *   The name of the 'current' table as defined the SQL database.
 * @param string $db_table_field
 *   The name of the 'field' table as defined the SQL database.
 * @param array $user_data
 *   An array of user related information:
 *   - 'user_id': The users ID.
 * @param array $form_state
 *   The form state for advanced processing of fields that depend on other
 *   fields when they are converted into the database format.
 * @param array|null $request
 *   (optional) When NULL, this created tables are new tables.
 *   When an array, the created tables are updates to existing values.
 *   The array should be populated by mfcs_load_request_by_id().
 *
 * @see mfcs_table_structure()
 * @see mfcs_load_request_by_id()
 */
function mfcs_build_table_structure($structure, &$structure_tables, &$structure_field_tables, $table_name, $field_name, $db_table, $db_table_field, $user_data, $values, $form_state, $request = NULL) {
  $instance = mfcs_instance();

  if (is_null($request)) {
    $request_id = NULL;
    $revision = 0;
  }
  else {
    $request_id = $request['mer']['id'][0]->value;
    $structure_tables[$db_table]['request_id'] = $request_id;

    $revision = mfcs_load_request_revision_number($request_id, $db_table_field);
    if ($revision === FALSE) {
      watchdog(MFCS_WATCHDOG_ID, "Failed to load revision number for request %request_id while building the table structure, forcing revision number to be 0.", array('%request_id' => $request_id), WATCHDOG_ERROR);
      $revision = 0;
    }
    elseif (is_null($revision)) {
      $revision = 0;
    }
    else {
      $revision++;
    }
  }

  if (!isset($structure_field_tables[$db_table_field])) {
    $structure_field_tables[$db_table_field] = array();
  }

  if (array_key_exists('storage', $structure[$table_name][$field_name])) {
    if (!is_string($structure[$table_name][$field_name]['storage']) || empty($structure[$table_name][$field_name]['storage'])) {
      watchdog(MFCS_WATCHDOG_ID, "Invalid storage structure specification for the field %field_name in the table %table_name. This must be a non-empty string.", array('%field_name' => $field_name, '%table_name' => $table_name), WATCHDOG_ERROR);
      return;
    }

    $storage_key = $structure[$table_name][$field_name]['storage'];
    if (!array_key_exists($storage_key, $structure[$table_name][$field_name]) || empty($structure[$table_name][$field_name][$storage_key])) {
      watchdog(MFCS_WATCHDOG_ID, "The storage key %storage_key was not found in the structure specification for the field %field_name in the table %table_name. This must be a non-empty string.", array('%storage_key' => $storage_key, '%field_name' => $field_name, '%table_name' => $table_name), WATCHDOG_ERROR);
      return;
    }

    // alternate is used for handling fields that are stored in multiple separate tables.
    if ($storage_key == 'alternate') {
      unset($structure_tables[$db_table][$field_name]);
      unset($structure_field_tables[$db_table_field]);

      foreach ($values as $delta => $value) {
        $alternate_values = array();
        if (!empty($structure[$table_name][$field_name]['alternate_method'])) {
          foreach ($structure[$table_name][$field_name]['alternate_method'] as $method_name => $method_values) {
            if ($method_name == 'explode') {
              $alternate_values = explode($method_values[0], $value, $method_values[1]);
            }

            break;
          }
        }

        foreach ($structure[$table_name][$field_name]['alternate'] as $alternate_name => &$alternate_data) {
          if (!array_key_exists('key', $alternate_data)) continue;

          $db_table_field = 'mfcs_field_' . $table_name . '_' . $alternate_name;

          if (!isset($structure_field_tables[$db_table_field])) {
            $structure_field_tables[$db_table_field] = array();
          }

          $structure_field_tables[$db_table_field][$delta] = array();
          $structure_field_tables[$db_table_field][$delta]['user_id'] = $user_data['user_id'];
          $structure_field_tables[$db_table_field][$delta]['date'] = $instance;
          $structure_field_tables[$db_table_field][$delta]['delta'] = $delta;
          $structure_field_tables[$db_table_field][$delta]['revision'] = $revision;

          if (isset($alternate_values[$alternate_data['key']]) && (is_numeric($alternate_values[$alternate_data['key']]) || !empty($alternate_values[$alternate_data['key']]))) {
            $structure_field_tables[$db_table_field][$delta]['value'] = $alternate_values[$alternate_data['key']];
          }

          if (!is_null($request_id)) {
            $structure_field_tables[$db_table_field][$delta]['request_id'] = $request_id;
          }

          $structure_tables[$db_table][$alternate_name] = $revision;
        }
      }
    }
    else {
      $structure_tables[$db_table][$field_name] = $revision;

      foreach ($values as $delta => $value) {
        $structure_field_tables[$db_table_field][$delta] = array();
        $structure_field_tables[$db_table_field][$delta]['user_id'] = $user_data['user_id'];
        $structure_field_tables[$db_table_field][$delta]['date'] = $instance;
        $structure_field_tables[$db_table_field][$delta]['delta'] = $delta;
        $structure_field_tables[$db_table_field][$delta]['revision'] = $revision;

        if (!is_null($request)) {
          $structure_field_tables[$db_table_field][$delta]['request_id'] = $request_id;
        }

        $storage_values = FALSE;
        if (isset($structure[$table_name][$field_name][$storage_key]) && is_array($structure[$table_name][$field_name][$storage_key])) {
          $storage_values = mfcs_convert_value_to_database_format($value, $storage_key, $structure[$table_name][$field_name][$storage_key], $form_state, $delta);
        }

        if ($storage_values !== FALSE && !is_null($storage_values)) {
          $structure_field_tables[$db_table_field][$delta]['value'] = $storage_values;
        }

        if (isset($structure[$table_name][$field_name]['type'])) {
          // exception case: the time type is also stored in a field with the y/m/d set to 0 for quick and easy relative searches at the cost of extra space usage.
          if ($structure[$table_name][$field_name]['type'] == 'time' && $storage_key == 'timestamp') {
            $storage_values = FALSE;
            if (isset($structure[$table_name][$field_name][$storage_key]) && is_array($structure[$table_name][$field_name][$storage_key])) {
              $storage_options = $structure[$table_name][$field_name][$storage_key];
              unset($storage_options['relative_to']);
              $storage_values = mfcs_convert_value_to_database_format($value, 'timestamp_relative', $storage_options);
              unset($storage_options);
            }

            if ($storage_values !== FALSE && !is_null($storage_values)) {
              $structure_field_tables[$db_table_field][$delta]['value_relative'] = $storage_values;
            }
          }
          // exception case: the date_popup type is also stored in a month and a day field for quick and easy relative searches at the cost of extra space usage.
          elseif ($structure[$table_name][$field_name]['type'] == 'date' && $storage_key == 'date_popup') {
            $storage_values = FALSE;
            if (isset($structure[$table_name][$field_name][$storage_key]) && is_array($structure[$table_name][$field_name][$storage_key])) {
              $storage_options = $structure[$table_name][$field_name][$storage_key];
              unset($storage_options['relative_to']);
              $storage_values = mfcs_convert_value_to_database_format($value, 'date_month', $storage_options);
              unset($storage_options);
            }

            if ($storage_values !== FALSE && !is_null($storage_values)) {
              $structure_field_tables[$db_table_field][$delta]['value_month'] = $storage_values;
            }

            $storage_values = FALSE;
            if (isset($structure[$table_name][$field_name][$storage_key]) && is_array($structure[$table_name][$field_name][$storage_key])) {
              $storage_options = $structure[$table_name][$field_name][$storage_key];
              unset($storage_options['relative_to']);
              $storage_values = mfcs_convert_value_to_database_format($value, 'date_day', $storage_options);
              unset($storage_options);
            }

            if ($storage_values !== FALSE && !is_null($storage_values)) {
              $structure_field_tables[$db_table_field][$delta]['value_day'] = $storage_values;
            }
          }
        }
      }
    }
  }
  else {
    $structure_tables[$db_table][$field_name] = $revision;

    foreach ($values as $delta => $value) {
      $structure_field_tables[$db_table_field][$delta] = array();
      $structure_field_tables[$db_table_field][$delta]['user_id'] = $user_data['user_id'];
      $structure_field_tables[$db_table_field][$delta]['date'] = $instance;
      $structure_field_tables[$db_table_field][$delta]['delta'] = $delta;
      $structure_field_tables[$db_table_field][$delta]['revision'] = $revision;

      if (!is_null($request)) {
        $structure_field_tables[$db_table_field][$delta]['request_id'] = $request_id;
      }

      if (isset($structure[$table_name][$field_name]['columns'])) {
        foreach ($structure[$table_name][$field_name]['columns'] as $special_field_id => &$special_field_name) {
          if (isset($value[$special_field_id]) && $value[$special_field_id] > 0) {
            $structure_field_tables[$db_table_field][$delta][$special_field_name] = $special_field_id;
          }
        }
      }
      elseif (is_numeric($value) || !empty($value)) {
        $structure_field_tables[$db_table_field][$delta]['value'] = $value;
      }
    }
  }
}

/**
 * Returns the reviewers.
 *
 * @param array $conditions
 *   An array containing select conditions, such as:
 *   - 'mr.id': reviewer id.
 *   - 'mr.user_id': user id (uid).
 *   - 'mr.request_classification': request classification.
 *   - 'mr.review_step': request review step.
 *   - 'mr.reviewer_classification': reviewer classification.
 * @param bool $join
 *   (optional) When TRUE, the drupal user table is joined to the reviewers table.
 *   Only select portions of the user table is joined.
 *   This also joins custom field tables for user first and last name.
 * @param array $sort
 *   (optional) When specified, representings the database sorting.
 *
 * @return array|false
 *   An array of database objects representing the reviewers.
 *   FALSE is returned on error.
 */
function mfcs_get_reviewers($conditions = array(), $join = FALSE, $sort = array()) {
  if (!is_array($conditions)) {
    cf_error::invalid_array('conditions');
    return FALSE;
  }

  if (!is_bool($join)) {
    cf_error::invalid_bool('join');
    return FALSE;
  }

  if (!is_array($sort)) {
    cf_error::invalid_sort('sort');
    return FALSE;
  }

  try {
    $query = db_select('mfcs_reviewers', 'mr');
    $query->fields('mr');

    if ($join) {
      $query->innerJoin('users', 'u', 'u.uid = mr.user_id');
      $query->innerJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
      $query->innerJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND fdfuln.delta = 0');
      $query->innerJoin('field_data_field_user_banner_id', 'fdfubi', 'u.uid = fdfubi.entity_id AND fdfubi.delta = 0');

      $query->innerJoin('taxonomy_term_data', 'ttd1', 'ttd1.vid = 1 AND mr.request_classification = ttd1.tid');
      $query->innerJoin('taxonomy_term_data', 'ttd2', 'ttd2.vid = 19 AND mr.review_step = ttd2.tid');
      $query->innerJoin('taxonomy_term_data', 'ttd3', 'ttd3.vid = 17 AND mr.reviewer_classification = ttd3.tid');

      $query->addField('u', 'name', 'name');
      $query->addField('u', 'created', 'created');
      $query->addField('u', 'status', 'status');
      $query->addField('u', 'mail', 'email');

      $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
      $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');
      $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

      $query->addField('ttd1', 'name', 'request_classification_name');
      $query->addField('ttd2', 'name', 'review_step_name');
      $query->addField('ttd3', 'name', 'reviewer_classification_name');
    }

    if (!empty($conditions)) {
      foreach ($conditions as $condition_id => $condition) {
        $query->condition($condition_id, $condition);
      }
    }

    if (!empty($sort)) {
      foreach ($sort as $sort_name => $sort_value) {
        $query->orderBy($sort_name, $sort_value);
      }
    }

    $results = $query->execute()->fetchAll();
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);

    return FALSE;
  }

  if (is_array($results)) {
    return $results;
  }

  return FALSE;
}

/**
 * Checks to see if the given room is available at the given times.
 *
 * For the dates and times to work properly, it is expected that:
 * - unix timestamps are used.
 * - date values have their time reset to 0 (aka: 12:00:00am).
 * - time values have their dates set to the same day as the date value.
 *
 * @param string $room
 *   The room string.
 * @param array $dates
 *   An array containing the date values.
 * @param array $time_start
 *   An array containing the time start values.
 * @param array $time_stop
 *   An array containing the time stop values.
 * @param int|null $request_id
 *   (optional) When not NULL, this represents the request_id to ignore.
 *   Use this so that when editing an existing request, it does not report
 *   itself as the request using the room.
 *
 * @return array|false
 *   An array containing any requests currently using the room at the specified date and time.
 *   FALSE on error.
 */
function mfcs_check_room_availability($room, $date, $time_start, $time_stop, $request_id = NULL) {
  if (!is_string($room) || empty($room)) {
    cf_error::invalid_string('room');
    return FALSE;
  }

  if (!is_array($date) || empty($date)) {
    cf_error::invalid_array('date');
    return FALSE;
  }

  if (!is_array($time_start) || empty($time_start)) {
    cf_error::invalid_array('time_start');
    return FALSE;
  }

  if (!is_array($time_stop) || empty($time_stop)) {
    cf_error::invalid_array('time_stop');
    return FALSE;
  }

  if (!is_null($request_id) && !cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  try {
    $query = db_select('mfcs_requests', 'mer');

    $query->innerJoin('mfcs_current_top', 'mct', 'mer.id = mct.request_id');
    $query->innerJoin('mfcs_current_dates', 'mcd', 'mer.id = mcd.request_id AND mct.request_id = mcd.request_id');

    $query->innerJoin('mfcs_field_top_status', 'mfts', 'mct.request_id = mfts.request_id AND mcd.request_id = mfts.request_id AND mct.status = mfts.revision AND mfts.delta = 0');
    $query->innerJoin('mfcs_field_top_step', 'mftsp', 'mct.request_id = mftsp.request_id AND mcd.request_id = mftsp.request_id AND mct.step = mftsp.revision AND mftsp.delta = 0');
    $query->innerJoin('mfcs_field_top_room', 'mftr', 'mct.request_id = mftr.request_id AND mcd.request_id = mftr.request_id AND mct.room = mftr.revision AND mftr.delta = 0');

    $query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mct.request_id = mfdd.request_id AND mcd.request_id = mfdd.request_id AND mcd.date = mfdd.revision');

    $query->addField('mer', 'id', 'request_id');
    $query->addField('mfts', 'value', 'status');
    $query->addField('mftsp', 'value', 'step');
    $query->addField('mfdd', 'value', 'date');
    $query->addField('mcd', 'date', 'date_revision');
    $query->addField('mcd', 'time_start', 'time_start_revision');
    $query->addField('mcd', 'time_stop', 'time_stop_revision');

    $query->distinct();

    $statuses = array(
      MFCS_REQUEST_STATUS_LOCKED,
      MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    );

    $query->condition('mfts.value', $statuses, 'IN');
    $query->condition('mftr.value', $room);
    $query->condition('mfdd.value', $date, 'IN');

    if (!is_null($request_id)) {
      $query->condition('mer.id', $request_id, '<>');
    }

    $results = $query->execute()->fetchAll();

    // no rooms in use.
    if (empty($results)) {
      return array();
    }

    $matched_requests = array();

    // the results contain all locked requests that have something in the given room during the given date.
    // however, this does not mention the time, so loop through the times and see if they are all valid.
    foreach ($results as $result) {
      $query = db_select('mfcs_field_dates_date', 'mfdd');

      $query->innerJoin('mfcs_field_dates_time_start', 'mfdts', 'mfdd.request_id = mfdts.request_id AND mfdd.delta = mfdts.delta');
      $query->innerJoin('mfcs_field_dates_time_stop', 'mfdtsp', 'mfdd.request_id = mfdtsp.request_id AND mfdd.delta = mfdtsp.delta');

      $query->addField('mfdd', 'request_id', 'request_id');
      $query->addField('mfdd', 'revision', 'revision');
      $query->addField('mfdd', 'delta', 'delta');
      $query->addField('mfdd', 'value', 'date');
      $query->addField('mfdts', 'value', 'time_start');
      $query->addField('mfdtsp', 'value', 'time_stop');

      $query->condition('mfdd.request_id', $result->request_id);
      $query->condition('mfdts.request_id', $result->request_id);
      $query->condition('mfdtsp.request_id', $result->request_id);

      $query->condition('mfdd.revision', $result->date_revision);
      $query->condition('mfdts.revision', $result->time_start_revision);
      $query->condition('mfdtsp.revision', $result->time_stop_revision);

      if (!is_null($request_id)) {
        $query->condition('mfdd.request_id', $request_id, '<>');
      }

      $or = db_or();

      // all day requests match, they have NULL for start and stop time values.
      $and = db_and();
      $and->condition('mfdd.value', $date, 'IN');
      $and->isNull('mfdts.value');
      $and->isNull('mfdtsp.value');

      $or->condition($and);

      foreach ($date as $key => $value) {
        // all day requests match, they have NULL for start and stop time values.
        if (is_null($time_start[$key]) && is_null($time_stop[$key])) {
          $matched_requests[] = $result;
        }

        $and = db_and();
        $and->condition('mfdd.value', $value);
        $and->condition('mfdts.value', $time_start[$key], '<=');
        $and->condition('mfdtsp.value', $time_start[$key], '>');
        $or->condition($and);

        $and = db_and();
        $and->condition('mfdd.value', $value);
        $and->condition('mfdts.value', $time_stop[$key], '<');
        $and->condition('mfdtsp.value', $time_stop[$key], '>=');
        $or->condition($and);
      }

      $query->condition($or);

      $matches = $query->execute()->fetchAll();

      foreach ($matches as $match) {
        $matched_requests[] = $result;
      }
    }
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);
    return FALSE;
  }

  return $matched_requests;
}

/**
 * Prints a warning message about the room being unavailable.
 *
 * @see mfcs_check_room_availability()
 */
function mfcs_display_room_unavailable_message() {
  $unavailable_message = '';
  $unavailable_message .= '<span class="uppercase">Warning</span>: The specified room is currently unavailable. ';
  $unavailable_message .= 'You may still submit this request and your request attempt will still be logged. ';
  drupal_set_message($unavailable_message, 'warning');
}

/**
 * Load a listing of requests.
 *
 * This can be used as a very simple and straightforward search.
 *
 * This will load a total results of $limit +1 to communicate when a given
 * result set has more results than the limit. This should help with
 * implementing next and previous options.
 *
 * @param string|null|array $search
 *   (optional) When not NULL, this is either the string of text to search for.
 *   or an array of possible field values.
 * @param bool $sensitive
 *   (optional) TRUE for case sensitive and FALSE otherwise.
 * @param int $start
 *   (optional) The starting range.
 * @param bool $limit
 *   (optional) The total number of search results to load.
 *   If -1 is provided, then this will become a count query instead of a listing.
 * @param array $sorting
 *   (optional) Table sort options.
 * @param null|bool $review_restrictions
 *   (optional) When NULL, no review restrictions are applied.
 *   When FALSE, review view restrictions are applied.
 *   When TRUE, review edit restrictions are applied.
 * @param array $extra_fields
 *   (optional) An array of extra fields that should be loaded.
 *   The array will have a key of the table name and a value of an array.
 *   The value array will contain an 'alias' string, an 'on' string, a 'join'
 *   string, and a 'columns' array.
 *
 * @return array|FALSE
 *   An array of all items found or FALSE on error.
 */
function mfcs_request_load_listing($search = NULL, $sensitive = FALSE, $start = 0, $limit = 20, $sorting = array(), $review_restrictions = NULL, $extra_fields = array()) {
  if (!is_null($search) && !is_string($search) && !is_array($search)) {
    cf_error::invalid_string('search');
    return FALSE;
  }

  if (is_array($search) && empty($search)) {
    $search = NULL;
  }

  if (!is_bool($sensitive)) {
    cf_error::invalid_bool('sensitive');
    return FALSE;
  }

  if (!cf_is_integer($start) || $start < 0) {
    cf_error::invalid_integer('start');
    return FALSE;
  }

  if (!cf_is_integer($limit) || $limit < -1) {
    cf_error::invalid_integer('limit');
    return FALSE;
  }

  if (!is_array($sorting)) {
    cf_error::invalid_array('sorting');
    return FALSE;
  }

  if (!is_null($review_restrictions) && !is_bool($review_restrictions)) {
    cf_error::invalid_bool('review_restrictions');
    return FALSE;
  }

  if (!is_array($extra_fields)) {
    cf_error::invalid_array('extra_fields');
    return FALSE;
  }

  $count = FALSE;
  if ($limit == -1) {
    $count = TRUE;
    $limit = 0;
  }

  $user = cf_current_user();

  $manager = user_access('mfcs manage', $user);
  $reviewer = user_access('mfcs review', $user);
  $requester = user_access('mfcs request', $user);

  $s = 'i';
  $like = 'ILIKE';
  if ($sensitive) {
    $s = '';
    $like = 'LIKE';
  }

  // load sorting information
  $order = NULL;
  if (isset($sorting['order'])) {
    $order = strtolower($sorting['order']);
  }

  $sort = NULL;
  if (isset($sorting['sort'])) {
    $sort = strtoupper($sorting['sort']);

    if ($sort != 'ASC' && $sort != 'DESC') {
      $sort = NULL;
    }
  }

  // load search options
  if (is_null($search)) {
    // nothing to do
  }
  elseif (is_string($search)) {
    $fixed_text = preg_replace('/(\s)/i', ' ', $search);

    // don't search when there is nothing to search for.
    if (empty($fixed_text)) {
      return array();
    }
  }

  $show_status_venue_coordinator = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_UNLOCKED,
  );

  $show_step_venue_coordinator = array(
    MFCS_REVIEW_STEP_VENUE_AVAILABLE,
    MFCS_REVIEW_STEP_MAKE_DECISIONS,
  );

  $show_status_reviewer = array(
    MFCS_REQUEST_STATUS_LOCKED,
  );

  $show_step_reviewer = array(
    MFCS_REVIEW_STEP_REVIEW,
    MFCS_REVIEW_STEP_REQUIREMENTS,
  );

  $show_decision = array(
    MFCS_REVIEW_DECISION_APPROVE,
    MFCS_REVIEW_DECISION_DENY,
  );

  if (is_null($review_restrictions)) {
    $reviewer_classifications = array();
    $reviewer_steps = array();
    $reviewer_settings = mfcs_get_reviewers(array('mr.user_id' => $user->uid));
    if (is_array($reviewer_settings)) {
      foreach ($reviewer_settings as $reviewer_setting) {
        $reviewer_classifications[$reviewer_setting->reviewer_classification] = $reviewer_setting->reviewer_classification;
        $reviewer_steps[$reviewer_setting->review_step] = $reviewer_setting->review_step;
      }
    }
    unset($reviewer_settings);
  }

  $already_joined_count = 0;
  $already_joined = array();

  $already_added = array();

  $found = array();
  try {
    $query = db_select('mfcs_requests', 'mer');

    $query->innerJoin('mfcs_current_top', 'mct', 'mer.id = mct.request_id');
    $query->innerJoin('mfcs_current_information', 'mci', 'mer.id = mci.request_id');

    $already_joined['mfcs_current_top'] = 'mct';
    $already_joined['mfcs_current_information'] = 'mci';

    $query->innerJoin('mfcs_field_top_status', 'mfts', 'mct.request_id = mfts.request_id AND mct.status = mfts.revision AND mfts.delta = 0');
    $query->innerJoin('mfcs_field_top_location', 'mftl', 'mct.request_id = mftl.request_id AND mct.location = mftl.revision AND mftl.delta = 0');
    $query->innerJoin('mfcs_field_top_room', 'mftr', 'mct.request_id = mftr.request_id AND mct.room = mftr.revision AND mftr.delta = 0');

    $already_joined['mfcs_field_top_status'] = 'mfts';
    $already_joined['mfcs_field_top_location'] = 'mftl';
    $already_joined['mfcs_field_top_room'] = 'mftr';

    // request step is only required when review_restrictions are non-null.
    if (!is_null($review_restrictions)) {
      $query->innerJoin('mfcs_field_top_step', 'mftsp', 'mct.request_id = mftsp.request_id AND mct.step = mftsp.revision AND mftsp.delta = 0');

      $already_joined['mfcs_field_top_step'] = 'mftsp';
    }

    $query->innerJoin('mfcs_banner_rooms', 'mbr', 'mftr.value = mbr.id');
    $query->innerJoin('mfcs_banner_buildings', 'mbb', 'mbr.building = mbb.id');
    $query->innerJoin('mfcs_banner_locations', 'mbl', 'mftl.value = mbl.id');

    $already_joined['mfcs_banner_rooms'] = 'mbr';
    $already_joined['mfcs_banner_buildings'] = 'mbb';
    $already_joined['mfcs_banner_locations'] = 'mbl';

    $query->innerJoin('mfcs_field_information_title', 'mfit', 'mci.request_id = mfit.request_id AND mci.title = mfit.revision AND mfit.delta = 0');
    $query->innerJoin('mfcs_field_information_type', 'mfitp', 'mci.request_id = mfitp.request_id AND mci.type = mfitp.revision AND mfitp.delta = 0');

    $already_joined['mfcs_field_information_title'] = 'mfit';
    $already_joined['mfcs_field_information_type'] = 'mfitp';

    // when using simple search, include a few additional textarea fields.
    if (is_string($search)) {
      $query->distinct();

      $query->innerJoin('mfcs_current_dates', 'mcd', 'mer.id = mcd.request_id');

      $already_joined['mfcs_current_dates'] = 'mcd';

      $query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mcd.request_id = mfdd.request_id AND mcd.date = mfdd.revision');
      $query->innerJoin('mfcs_field_dates_time_start', 'mfdts', 'mcd.request_id = mfdts.request_id AND mcd.time_start = mfdts.revision');
      $query->innerJoin('mfcs_field_dates_time_stop', 'mfdtsp', 'mcd.request_id = mfdtsp.request_id AND mcd.time_stop = mfdtsp.revision');
      $query->innerJoin('mfcs_field_dates_category', 'mfdc', 'mcd.request_id = mfdc.request_id AND mcd.category = mfdc.revision AND mfdc.delta = 0');

      $already_joined['mfcs_field_dates_date'] = 'mfdd';
      $already_joined['mfcs_field_dates_time_start'] = 'mfdts';
      $already_joined['mfcs_field_dates_time_stop'] = 'mfdtsp';
      $already_joined['mfcs_field_dates_category'] = 'mfdc';

      $already_added['date'] = 'mfdd.value';
      $already_added['time_start'] = 'mfdts.value';
      $already_added['time_stop'] = 'mfdtsp.value';
      $already_added['category'] = 'mfdc.value';

      $query->innerJoin('mfcs_field_top_additional', 'mfta', 'mct.request_id = mfta.request_id AND mct.additional = mfta.revision AND mfta.delta = 0');
      $query->innerJoin('mfcs_field_information_organization', 'mfio', 'mci.request_id = mfio.request_id AND mci.organization = mfio.revision AND mfta.delta = 0');

      $already_joined['mfcs_field_top_additional'] = 'mfta';
      $already_joined['mfcs_field_information_organization'] = 'mfio';

      $query->innerJoin('mfcs_current_plans', 'mcp', 'mer.id = mcp.request_id');
      $query->innerJoin('mfcs_field_plans_activities', 'mfpa', 'mcp.request_id = mfpa.request_id AND mcp.activities = mfpa.revision AND mfpa.delta = 0');
      $query->innerJoin('mfcs_field_plans_description', 'mfpd', 'mcp.request_id = mfpd.request_id AND mcp.description = mfpd.revision AND mfpd.delta = 0');

      $already_joined['mfcs_current_plans'] = 'mcp';
      $already_joined['mfcs_field_plans_activities'] = 'mfpa';
      $already_joined['mfcs_field_plans_description'] = 'mfpd';
    }

    if ($count) {
      $query->addExpression('count(mer.id)');
    }
    else {
      $query->fields('mer');
    }

    if (!$count) {
      $query->addField('mfit', 'value', 'title');
      $query->addField('mfitp', 'value', 'type');

      $query->addField('mbr', 'id', 'room');
      $query->addField('mbb', 'id', 'building');
      $query->addField('mbl', 'id', 'location');

      $query->addField('mbr', 'human_name', 'room_name');
      $query->addField('mbb', 'human_name', 'building_name');
      $query->addField('mbl', 'human_name', 'location_name');

      $query->addField('mfts', 'value', 'status');

      if (!is_null($review_restrictions)) {
        $query->addField('mftsp', 'value', 'step');
      }
    }

    $already_added['title'] = 'mfit.value';
    $already_added['type'] = 'mfitp.value';

    $already_added['location'] = 'mbr.room';
    $already_added['building'] = 'mbb.building';
    $already_added['room'] = 'mbl.location';

    $already_added['room_name'] = 'mbr.human_name';
    $already_added['building_name'] = 'mbb.human_name';
    $already_added['location_name'] = 'mbl.human_name';

    $already_added['status'] = 'mfts.value';

    if (!is_null($review_restrictions)) {
      $already_added['step'] = 'mftsp.value';
    }

    // add custom fields to the select results as requested by the caller.
    if (!empty($extra_fields) && !$count) {
      foreach ($extra_fields as $extra_table_name => $extra_values) {
        if (!array_key_exists('alias', $extra_values) || !array_key_exists('join', $extra_values) || !array_key_exists('columns', $extra_values)) {
          continue;
        }

        if (array_key_exists($extra_table_name, $already_joined)) {
          continue;
        }

        if ($extra_values['join'] == 'inner') {
          $query->innerJoin($extra_table_name, $extra_values['alias'], $extra_values['on']);
        }
        elseif ($extra_values['join'] == 'left') {
          $query->leftJoin($extra_table_name, $extra_values['alias'], $extra_values['on']);
        }
        elseif ($extra_values['join'] == 'right') {
          $query->rightJoin($extra_table_name, $extra_values['alias'], $extra_values['on']);
        }

        $already_joined[$extra_table_name] = $extra_values['alias'];
        foreach ($extra_values['columns'] as $column_external_name => $column_internal_name) {
          if (array_key_exists($column_external_name, $already_added)) {
            continue;
          }

          $query->addField($extra_values['alias'], $column_internal_name, $column_external_name);
          $already_added[$column_external_name] = $extra_values['alias'] . '.' . $column_internal_name;
        }
      }
    }

    if (is_array($search)) {
      $operand = db_and();
      $result = mfcs_request_process_listing_search_array($query, $operand, $already_joined, $already_joined_count, $already_added, $search, 1, $like);

      if ($result) {
        $query->condition($operand);
      }
    }

    if ($limit > 0) {
      $query->range($start, $limit + 1);
    }

    if ($reviewer || $manager) {
      if (!array_key_exists('mfcs_current_request_coordinator', $already_joined)) {
        $query->innerJoin('mfcs_current_request_coordinator', 'mcrc', 'mer.id = mcrc.request_id');
      }

      if (!array_key_exists('mfcs_field_request_coordinator_classification', $already_joined)) {
        $query->innerJoin('mfcs_field_request_coordinator_classification', 'mfrcc', 'mcrc.request_id = mfrcc.request_id AND mcrc.classification = mfrcc.revision AND mfrcc.delta = 0');
      }

      if (!array_key_exists('mfcs_current_venue_coordinator', $already_joined)) {
        $query->innerJoin('mfcs_current_venue_coordinator', 'mcvc', 'mer.id = mcvc.request_id');
      }

      if (!array_key_exists('mfcs_field_venue_coordinator_user_id', $already_joined)) {
        $query->innerJoin('mfcs_field_venue_coordinator_user_id', 'mfvcui', 'mcvc.request_id = mfvcui.request_id AND mcvc.user_id = mfvcui.revision AND mfvcui.delta = 0');
      }

      $or = NULL;

      if ($review_restrictions === TRUE) {
        if (is_null($or)) {
          $or = db_or();
        }

        // process venue coordinator access.
        $already_venue_coordinated_query = db_select('mfcs_reviewed', 'mrd_vc');
        $already_venue_coordinated_query->addField('mrd_vc', 'request_id', 'request_id');
        $already_venue_coordinated_query->where('mrd_vc.request_id = mftsp.request_id');
        $already_venue_coordinated_query->condition('mrd_vc.classification', MFCS_REVIEW_CLASSIFICATION_VENUE_COORDINATOR);

        $and = db_and();
        $and->condition('mfts.value', $show_status_venue_coordinator, 'IN');
        $and->condition('mftsp.value', $show_step_venue_coordinator, 'IN');
        $and->condition('mftsp.request_id', $already_venue_coordinated_query, 'NOT IN');
        $and->condition('mfvcui.value', $user->uid);

        $or->condition($and);

        // process review access.
        if (!empty($reviewer_classifications)) {
          $already_reviewed_query = db_select('mfcs_reviewers', 'mr_r');
          $already_reviewed_query->innerJoin('mfcs_reviewed', 'mrd_r', 'mr_r.reviewer_classification = mrd_r.classification');
          $already_reviewed_query->addField('mrd_r', 'request_id', 'request_id');
          $already_reviewed_query->where('mr_r.request_classification = mfrcc.value AND mr_r.review_step = mftsp.value');
          $already_reviewed_query->condition('mr_r.user_id', $user->uid);
          $already_reviewed_query->condition('mr_r.disabled', 0);

          $and = db_and();
          $and->condition('mfts.value', $show_status_reviewer, 'IN');
          $and->condition('mftsp.value', $show_step_reviewer, 'IN');
          $and->condition('mftsp.value', $reviewer_steps, 'IN');
          $and->condition('mftsp.request_id', $already_reviewed_query, 'NOT IN');

          $or->condition($and);
        }
      }
      elseif ($review_restrictions === FALSE) {
        if (!$manager) {
          if (is_null($or)) {
            $or = db_or();
          }

          // always show completed and accepted requests when there are no restrictions.
          $and = db_and();
          $and->condition('mfts.value', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);
          $and->condition('mftsp.value', MFCS_REVIEW_STEP_COMPLETED);
          $or->condition($and);

          // process venue coordinator access.
          $or->condition('mfvcui.value', $user->uid);

          // process reviewer access.
          if (!empty($reviewer_steps)) {
            $and = db_and();
            $and->condition('mfts.value', MFCS_REQUEST_STATUS_LOCKED);
            $and->condition('mftsp.value', $show_step_reviewer, 'IN');
            $or->condition($and);
          }
        }
      }

      // always show accepted requests when there are no restrictions.
      if (is_null($review_restrictions)) {
        // if there are no conditions, then don't add any!
        if (!is_null($or)) {
          $and = db_and();
          $and->condition('mfts.value', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);

          $or->condition($and);
        }
      }

      if (!is_null($or)) {
        $query->condition($or);
      }
    }
    elseif ($requester) {
      // always show accepted requests when there are no restrictions.
      if (is_null($review_restrictions)) {
        $and = db_and();
        $and->condition('mfts.value', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);

        $or = db_or();
        $or->condition($and);
        $or->condition('mer.user_id', $user->uid);

        $query->condition($or);
      }
      else {
        $query->condition('mer.user_id', $user->uid);
      }
    }
    else {
      // failsafe, should never happen.
      return FALSE;
    }

    // do not include deleted requests.
    $query->condition('mfts.value', MFCS_REQUEST_STATUS_DELETED, '<>');

    if (!is_null($search) && is_string($search)) {
      $or = db_or();

      $like_part = db_like($fixed_text);

      $or->condition('mfit.value', $like_part, $like);
      $or->condition('mfit.value', '%' . $like_part . '%', $like);

      $or->condition('mfio.value', $like_part, $like);
      $or->condition('mfio.value', '%' . $like_part . '%', $like);

      $or->condition('mfta.value', $like_part, $like);
      $or->condition('mfta.value', '%' . $like_part . '%', $like);

      $or->condition('mfpa.value', $like_part, $like);
      $or->condition('mfpa.value', '%' . $like_part . '%', $like);

      $or->condition('mfpd.value', $like_part, $like);
      $or->condition('mfpd.value', '%' . $like_part . '%', $like);

      $or->condition('mbl.human_name', $like_part, $like);
      $or->condition('mbl.human_name', '%' . $like_part . '%', $like);

      $or->condition('mbb.human_name', $like_part, $like);
      $or->condition('mbb.human_name', '%' . $like_part . '%', $like);

      $or->condition('mbr.human_name', $like_part, $like);
      $or->condition('mbr.human_name', '%' . $like_part . '%', $like);

      $query->condition($or);
    }

    if (!$count) {
      if (is_null($order)) {
        $query->orderBy('created', 'DESC');
      }
      else {
        if ($order == 'id') {
          $query->orderBy('mer.id', is_null($sort) ? 'DESC' : $sort);
        }
        elseif ($order == 'title') {
          $query->orderBy('title', is_null($sort) ? 'ASC' : $sort);
        }
        elseif ($order == 'status') {
          $query->orderBy('status', is_null($sort) ? 'ASC' : $sort);
        }
        elseif ($order == 'step') {
          $query->orderBy('step', is_null($sort) ? 'ASC' : $sort);
        }
        elseif ($order == 'location') {
          $query->orderBy('location_name', is_null($sort) ? 'ASC' : $sort);
        }
        elseif ($order == 'building') {
          $query->orderBy('building_name', is_null($sort) ? 'ASC' : $sort);
        }
        elseif ($order == 'room') {
          $query->orderBy('room_name', is_null($sort) ? 'ASC' : $sort);
        }
        elseif ($order == 'date') {
          // dates are sorted later on, outside of the query.

          if (array_key_exists('mfcs_field_dates_date', $already_joined) && array_key_exists('mfcs_field_dates_time_start', $already_joined)) {
            $query->orderBy($already_joined['mfcs_field_dates_date'] . '.value', is_null($sort) ? 'ASC' : $sort);
            $query->orderBy($already_joined['mfcs_field_dates_time_start'] . '.value', is_null($sort) ? 'ASC' : $sort);
          }
          else {
            $query->innerJoin('mfcs_view_dates_asc_distinct', 'mvdad', 'mer.id = mvdad.request_id');

            $query->orderBy('mvdad.date', is_null($sort) ? 'ASC' : $sort);
            $query->orderBy('mvdad.time_start', is_null($sort) ? 'ASC' : $sort);
          }
        }
        elseif ($order == 'submitted by') {
          $query->orderBy('user_id', is_null($sort) ? 'ASC' : $sort);
        }
        elseif ($order == 'submitted on') {
          $query->orderBy('created', is_null($sort) ? 'DESC' : $sort);
        }
      }
    }



    if ($count) {
      $result = $query->execute()->fetchField();

      return $result;
    }

    $results = $query->execute()->fetchAllAssoc('id');

    if (is_null($order) || $order != 'date') {
      $found = $results;
    }

    $result_ids = array();
    $date_order = array();
    if (is_array($results)) {
      $result_ids = array_keys($results);
    }

    // fetch all available dates.
    if (!empty($result_ids)) {
      $sub_query = db_select('mfcs_current_dates', 'mcd');
      $sub_query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mcd.request_id = mfdd.request_id AND mcd.date = mfdd.revision');
      $sub_query->leftjoin('mfcs_field_dates_time_start', 'mfdts', 'mcd.request_id = mfdts.request_id AND mcd.time_start = mfdts.revision AND mfdd.delta = mfdts.delta');
      $sub_query->leftjoin('mfcs_field_dates_time_stop', 'mfdtsp', 'mcd.request_id = mfdtsp.request_id AND mcd.time_stop = mfdtsp.revision AND mfdts.delta = mfdtsp.delta');
      $sub_query->leftjoin('mfcs_field_dates_category', 'mfdc', 'mcd.request_id = mfdc.request_id AND mcd.category = mfdc.revision AND mfdts.delta = mfdc.delta');

      $sub_query->addField('mfdd', 'request_id', 'id');
      $sub_query->addField('mfdd', 'value', 'date');
      $sub_query->addField('mfdd', 'delta', 'delta');
      $sub_query->addField('mfdts', 'value', 'time_start');
      $sub_query->addField('mfdtsp', 'value', 'time_stop');
      $sub_query->addField('mfdc', 'value', 'category');

      $sub_query->condition('mfdd.request_id', $result_ids, 'IN');

      $sub_query->orderBy('date', 'ASC');
      $sub_query->orderBy('time_start', 'ASC');

      $sub_results = $sub_query->execute()->fetchAll();

      foreach ($sub_results as $delta => $sub_result) {
        if (!array_key_exists($sub_result->id, $found)) {
          $found[$sub_result->id] = $results[$sub_result->id];
          $found[$sub_result->id]->date = array();
          $found[$sub_result->id]->time_start = array();
          $found[$sub_result->id]->time_stop = array();
          $found[$sub_result->id]->category = array();
        }

        $found[$sub_result->id]->date[$sub_result->delta] = $sub_result->date;
        $found[$sub_result->id]->time_start[$sub_result->delta] = $sub_result->time_start;
        $found[$sub_result->id]->time_stop[$sub_result->delta] = $sub_result->time_stop;
        $found[$sub_result->id]->category[$sub_result->delta] = $sub_result->category;

        if (is_null($sub_result->time_start)) {
          if (!isset($date_order['start'][$sub_result->date][$sub_result->id])) {
            $date_order['start'][$sub_result->date][$sub_result->id] = $found[$sub_result->id];
          }
        }
        else {
          if (!isset($date_order['start'][$sub_result->time_start][$sub_result->id])) {
            $date_order['start'][$sub_result->time_start][$sub_result->id] = $found[$sub_result->id];
          }
        }
      }

      unset($sub_results);
    }
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);

    return FALSE;
  }

  if (!is_null($order)) {
    $ordered = array();

    if ($order == 'date' && isset($date_order['start'])) {
      $ordered = $date_order['start'];
    }

    if (!empty($ordered)) {
      if ($sort == 'DESC') {
        krsort($ordered);
      }
      else {
        ksort($ordered);
      }

      $found = array();
      foreach ($ordered as $key => $fields) {
        foreach ($fields as $field_key => $field) {
          $found[$field_key] = $field;
        }
      }
    }
  }

  return $found;
}

/**
 * Recursively append search conditions for loading a list of requests.
 *
 * @param object $query
 *   The query object.
 * @param object $operand
 *   The query operand, such as and, or or for processing the conditions.
 * @param array $already_joined
 *   An array of table names that have already been joined in the query object.
 * @param int $already_joined_count
 *   A counter for uniquely generating table alias names.
 * @param array $already_added
 *   An array of field names that have already been added as select parameters
 *   for the query object.
 * @param string $like
 *   The appropriate SQL like or ilike string for sensitive and insensitive.
 *
 * @param bool
 *   TRUE when a valid field is found and added to the $operand and FALSE
 *   otherwise.
 *
 * @see mfcs_request_load_listing()
 */
function mfcs_request_process_listing_search_array(&$query, &$operand, &$already_joined, &$already_joined_count, &$already_added, $search, $recurse_count, $like) {
  if (!is_object($query)) {
    cf_error::invalid_object('query');
    return FALSE;
  }

  if (!is_object($operand)) {
    cf_error::invalid_object('operand');
    return FALSE;
  }

  if (!is_array($search)) {
    cf_error::invalid_array('search');
    return FALSE;
  }

  if (!cf_is_integer($recurse_count)) {
    cf_error::invalid_integer('recurse_count');
    return FALSE;
  }

  if (!is_array($already_joined)) {
    cf_error::invalid_array('already_joined');
    return FALSE;
  }

  if (!cf_is_integer($already_joined_count)) {
    cf_error::invalid_integer('already_joined_count');
    return FALSE;
  }

  if (!is_array($already_added)) {
    cf_error::invalid_array('already_added');
    return FALSE;
  }

  if (!is_string($like)) {
    cf_error::invalid_string('like');
    return FALSE;
  }

  if ($recurse_count > MFCS_MAX_SEARCH_RECURSION) {
    return FALSE;
  }
  $found_values = FALSE;

  // process the inner fields, can be either a 'field_+', 'or_+', 'and_+', 'nor_+', or 'nand_+'.
  foreach ($search as $search_operand_or_field => $search_values) {
    $search_op = explode('_', $search_operand_or_field, 2);

    if (count($search_op) != 2) {
      // not valid, just skip.
      continue;
    }

    if (!is_array($search_values) || empty($search_values)) {
      // not valid, just skip.
      continue;
    }

    if ($search_op[0] == 'field') {
      if (empty($search_values['group_name'])) {
        // not valid, just skip.
        continue;
      }

      if (empty($search_values['field_name'])) {
        // not valid, just skip.
        continue;
      }

      if (empty($search_values['column'])) {
        // not valid, just skip.
        continue;
      }

      $join = 'innerJoin';
      if (isset($search_values['join'])) {
        if ($search_values['join'] == MFCS_JOIN_LEFT) {
          $join = 'leftJoin';
        }
        elseif ($search_values['join'] == MFCS_JOIN_RIGHT) {
          $join = 'rightJoin';
        }
        elseif ($search_values['join'] == MFCS_JOIN_OUTER) {
          $join = 'outerJoin';
        }
      }

      if ($search_values['group_name'] == 'mer') {
        // handle special case of the 'mer' fields, which are already joined and available.
        $field_alias = 'mer';
        $search_values['column'] = $search_values['field_name'];
      }
      else {
        $mfcs_current = 'mfcs_current_' . $search_values['group_name'];
        $mfcs_field = 'mfcs_field_' . $search_values['group_name'] . '_' . $search_values['field_name'];

        if (!array_key_exists($mfcs_current, $already_joined)) {
          $already_joined[$mfcs_current] = 'mc_c_' . $already_joined_count;
          $already_joined_count++;

          $current_alias = $already_joined[$mfcs_current];

          $query->$join($mfcs_current, $current_alias, 'mer.id = ' . $current_alias . '.request_id');
        }
        else {
          $current_alias = $already_joined[$mfcs_current];
        }

        if (!array_key_exists($mfcs_field, $already_joined)) {
          $already_joined[$mfcs_field] = 'mfg_c_' . $already_joined_count;
          $already_joined_count++;

          $field_alias = $already_joined[$mfcs_field];

          if (isset($search_values['multiple']) && $search_values['multiple']) {
            $query->$join($mfcs_field, $field_alias, $current_alias . '.request_id = ' . $field_alias . '.request_id AND ' . $current_alias . '.' . $search_values['field_name'] . ' = ' . $field_alias . '.revision');
          }
          else {
            $query->$join($mfcs_field, $field_alias, $current_alias . '.request_id = ' . $field_alias . '.request_id AND ' . $current_alias . '.' . $search_values['field_name'] . ' = ' . $field_alias . '.revision AND ' . $field_alias . '.delta = 0');
          }
        }
        else {
          $field_alias = $already_joined[$mfcs_field];
        }

        if (!array_key_exists($search_values['field_name'], $already_added)) {
          $query->addField($field_alias, $search_values['column'], $search_values['group_name'] . '_' . $search_values['field_name']);
        }
      }

      $operator = '=';
      $search_string = $search_values['search'];
      if ($search_values['operator'] == MFCS_OPERATOR_LESS_THAN) {
        $operator = '<';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_LESS_THAN_EQUAL) {
        $operator = '<=';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_EQUAL) {
        $operator = '=';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_LIKE) {
        if ($search_string == "") {
          $operator = '=';
        }
        else {
          $operator = $like;
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_GREATER_THAN_EQUAL) {
        $operator = '>=';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_GREATER_THAN) {
        $operator = '>';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_EQUAL) {
        $operator = '<>';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_LIKE) {
        if ($search_string == "") {
          $operator = '=';
        }
        else {
          $operator = 'NOT ' . $like;
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_NULL) {
        $operand->isNull($field_alias . '.' . $search_values['column']);

        $found_values = TRUE;
        continue;
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_NOT_NULL) {
        $operand->isNotNull($field_alias . '.' . $search_values['column']);

        $found_values = TRUE;
        continue;
      }

      $operand->condition($field_alias . '.' . $search_values['column'], $search_string, $operator);

      $found_values = TRUE;
      continue;
    }
    elseif ($search_op[0] == 'or') {
      $inner_operand = db_or();
    }
    elseif ($search_op[0] == 'and') {
      $inner_operand = db_and();
    }
    elseif ($search_op[0] == 'nor') {
      $inner_operand = db_or();
      $inner_operand->not();
    }
    elseif ($search_op[0] == 'nand') {
      $inner_operand = db_and();
      $inner_operand->not();
    }
    else {
      // not valid, just skip.
      continue;
    }

    $next_count = $recurse_count + 1;
    $result = mfcs_request_process_listing_search_array($query, $inner_operand, $already_joined, $already_joined_count, $already_added, $search_values, $next_count, $like);

    if ($result) {
      $operand->condition($inner_operand);
      $found_values = TRUE;
    }

    unset($next_count);
  }

  return $found_values;
}

/**
 * Loads the reviews by step, classification, and date.
 *
 * @parem int $request_id
 *   The numeric request id representing the request to process.
 * @parem array $steps
 *   (optional) Limit the results to only the provided steps.
 * @parem array $decisions
 *   (optional) An array of decisions to limit the results to.
 *
 * @return array|bool
 *   An array of reviews by order of step, classification, and then date
 *   (with the date descending). FALSE is returned on error.
 */
function mfcs_get_latest_reviews($request_id, $steps = array(), $decisions = array()) {
  if (!cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  if (!is_array($steps)) {
    cf_error::invalid_array('steps');
    return FALSE;
  }

  if (!is_array($decisions)) {
    cf_error::invalid_array('decisions');
    return FALSE;
  }

  $reviews = array();
  try {
    $query = db_select('mfcs_field_review_review', 'mfrr');

    $query->innerJoin('mfcs_review_classifications', 'mrc', 'mfrr.id = mrc.review_id');
    $query->innerJoin('mfcs_current_review', 'mcr', 'mfrr.request_id = mcr.request_id and mfrr.revision = mcr.review');

    $query->addField('mfrr', 'id', 'id');
    $query->addField('mfrr', 'user_id', 'user_id');
    $query->addField('mfrr', 'date', 'date');
    $query->addField('mfrr', 'step', 'step');
    $query->addField('mfrr', 'decision', 'decision');
    $query->addField('mrc', 'classification', 'classification');

    $query->condition('mfrr.request_id', $request_id);

    if (!empty($steps)) {
      $query->condition('mfrr.step', $steps, 'IN');
    }

    if (!empty($decisions)) {
      $query->condition('mfrr.decision', $decisions, 'IN');
    }

    // some classifications are only allowed in certain steps.
    $and = db_and();
    $and->condition('mfrr.step', array(MFCS_REVIEW_STEP_REVIEW, MFCS_REVIEW_STEP_REQUIREMENTS), 'IN');
    $and->condition('mrc.classification', array(MFCS_REVIEW_CLASSIFICATION_VENUE_COORDINATOR, MFCS_REVIEW_CLASSIFICATION_SYSTEM_ADMINISTRATOR, MFCS_REVIEW_CLASSIFICATION_MANAGER, MFCS_REVIEW_CLASSIFICATION_FAILSAFE_COORDINATOR), 'IN');
    $and->not();
    $query->condition($and);

    $query->orderBy('mfrr.step');
    $query->orderBy('mrc.classification');
    $query->orderBy('mfrr.date', 'DESC');

    $results = $query->execute()->fetchAll();
    if (is_array($results)) {
      foreach ($results as $result) {

        if (!isset($reviews[$result->step])) {
          $reviews[$result->step] = array();
        }

        if (!isset($reviews[$result->step][$result->classification])) {
          $reviews[$result->step][$result->classification] = array();
        }

        $reviews[$result->step][$result->classification][$result->id] = $result;
      }
    }
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);

    return FALSE;
  }

  return $reviews;
}

/**
 * Builds a table listing of requests.
 *
 * @param array $items
 *   An array of items to add to the table as returned by
 *   mfcs_request_load_listing().
 * @param int $max_rows
 *   The number of items allowed to be listed on the table at one time.
 * @param array|null $columns
 *   (optional) specify the columns to use. NULL means use default.
 *
 * @return array
 *   A generated table array structure for passing to theme_table().
 *   Additional keys are added to the table structure:
 *   - 'error': TRUE on success, FALSE on error.
 *
 * @see: mfcs_request_load_listing()
 * @see: theme_table()
 */
function mfcs_build_request_table($items, $max_rows, $columns = NULL, $user = NULL, $extra = array()) {
  if (is_null($columns)) {
    $columns = array('id' => "ID", 'title' => "Title", 'building' => "Building", 'room' => "Room", 'date' => "Date", 'submitted_on' => "Submitted On", 'operations' => "Operations");
  }

  if (!is_array($columns)) {
    cf_error::invalid_array('columns');
    $table['error'] = TRUE;
    return $table;
  }


  if (!is_array($items) && $items !== FALSE) {
    cf_error::invalid_array('items');
    $table['error'] = TRUE;
    return $table;
  }

  if (is_null($user) || !is_object($user)) {
    $user = cf_current_user();
  }

  if (!is_array($extra)) {
    cf_error::invalid_array('extra');
    $table['error'] = TRUE;
    return $table;
  }

  $table_sort = TRUE;
  if (array_key_exists('table_sort', $extra) && !$extra['table_sort']) {
    $table_sort = FALSE;
  }

  $table = array();
  foreach ($columns as $column_name => $column_title) {
    $column_class = array();

    if ($column_name == 'operations') {
      $column_class[] = 'no-print';

      $table['header'][$column_name] = array(
        'data' => $column_title,
        'align' => 'center',
        'class' => $column_class,
      );
    }
    else {
      $table['header'][$column_name] = array(
        'data' => $column_title,
        'align' => 'center',
        'class' => $column_class,
      );

      if ($table_sort) {
        $table['header'][$column_name]['field'] = $column_name;
      }
    }
  }

  $table['attributes'] = array();
  $table['attributes']['summary'] = "A listing of requests associated by ID.";
  $table['rows'] = array();
  $table['empty'] = t("No requests were found.");
  $table['caption'] = "Requests";

  global $base_path;

  $rows = array();
  $rows_count = 0;

  if (empty($items)) {
    return $table;
  }

  $manager = user_access('mfcs manage', $user);

  $item_ids = array_keys($items);
  $can_create_requests = mfcs_page_request_access('create', $item_ids, $user);
  $can_edit_requests = mfcs_page_request_access('edit', $item_ids, $user);
  $can_review_requests = mfcs_page_request_access('review', $item_ids, $user);
  $can_log_requests = mfcs_page_request_access('log', $item_ids, $user);
  $can_history_requests = mfcs_page_request_access('history', $item_ids, $user);
  #$can_delete_requests = mfcs_page_request_access('delete', $item_ids, $user);
  $can_delete_requests = FALSE;

  if (!is_array($can_create_requests)) {
    $can_create_requests = array();
  }

  if (!is_array($can_edit_requests)) {
    $can_edit_requests = array();
  }

  if (!is_array($can_review_requests)) {
    $can_review_requests = array();
  }

  if (!is_array($can_log_requests)) {
    $can_log_requests = array();
  }

  if (!is_array($can_history_requests)) {
    $can_history_requests = array();
  }

  if (!is_array($can_delete_requests)) {
    $can_delete_requests = array();
  }

  $status_options = mfcs_get_request_status_list_options();
  $step_options = mfcs_get_request_steps_list_options();
  $location_options = mfcs_get_request_location_list_options(NULL, FALSE, TRUE);
  $room_options = mfcs_get_request_room_list_options(NULL, NULL, TRUE);
  $building_options = array();

  foreach ($items as $item) {
    $row = array();
    $rows_count++;

    // Rows per page + 1 is loaded so that it can be detected whether or not a 'next' link needs to be provided.
    if ($rows_count > $max_rows) {
      break;
    }

    if (isset($columns['id'])) {
      $row['id'] = array(
        'data' => $item->id,
        'class' => 'column-id',
      );
    }

    if (isset($columns['title'])) {
      $row['title'] = array(
        'data' => check_plain($item->title),
        'class' => 'column-title',
      );
    }

    if (!array_key_exists($item->location, $building_options)) {
      $building_options[$item->location] = mfcs_get_request_building_list_options($item->location, NULL, TRUE);
    }

    if (isset($columns['location'])) {
      $row['location'] = array(
        'data' => '',
        'class' => 'column-location',
      );

      if (!empty($item->location)) {
        if (isset($location_options[$item->location])) {
          $row['location']['data'] = check_plain($location_options[$item->location]);
        }
      }
    }

    if (isset($columns['building'])) {
      $row['building'] = array(
        'data' => '',
        'class' => 'column-building',
      );

      if (!empty($item->building)) {
        if (isset($building_options[$item->location][$item->building])) {
          $row['building']['data'] = check_plain($building_options[$item->location][$item->building]);
        }
      }
    }

    if (isset($columns['room'])) {
      $row['room'] = array(
        'data' => '',
        'class' => 'column-room',
      );

      if (!empty($item->room)) {
        if (isset($room_options[$item->room])) {
          $row['room']['data'] = check_plain($room_options[$item->room]);
        }
      }
    }

    if (isset($columns['date'])) {
      $row['date'] = array(
        'data' => NULL,
        'class' => 'column-date',
      );

      foreach ($item->date as $delta => $date) {
        if (is_null($row['date']['data'])) {
          $row['date']['data'] = '';
        }
        else {
          $row['date']['data'] .= '<br>';
        }

        $row['date']['data'] .= check_plain(date("Y/m/d", $date));

        if (array_key_exists($delta, $item->time_start) && !is_null($item->time_start[$delta]) && array_key_exists($delta, $item->time_stop) && !is_null($item->time_stop[$delta])) {
          $row['date']['data'] .= ' ' . check_plain(date("h:i a", $item->time_start[$delta]));
          $row['date']['data'] .= ' to ' . check_plain(date("h:i a", $item->time_stop[$delta]));
        }
      }
    }

    if (isset($columns['status'])) {
      $row['status'] = array(
        'data' => $status_options[$item->status],
        'class' => 'column-status',
      );
    }

    if (isset($columns['step'])) {
      $row['step'] = array(
        'data' => $step_options[$item->step],
        'class' => 'column-step',
      );
    }

    if (isset($columns['submitted_by'])) {
      $row['submitted_by'] = array(
        'data' => '',
        'class' => 'column-submitted_by',
      );

      $submitter = user_load($item->user_id);

      if (is_object($submitter)) {
        $name = $submitter->name;

        if (!empty($submitter->field_user_first_name['und'][0]['value'])) {
          $name = $submitter->field_user_first_name['und'][0]['value'];

          if (!empty($submitter->field_user_last_name['und'][0]['value'])) {
            $name .= ' ' . $submitter->field_user_last_name['und'][0]['value'];
          }

          $name .= ' (' . $submitter->name . ')';
        }

        if ($manager) {
          $row['submitted_by']['data'] = '<a href="' . $base_path . 'user/' . $submitter->uid . '">' . $name . '</a>';
        }
        else {
          $row['submitted_by']['data'] = $name;
        }
      }
      else {
        watchdog(MFCS_WATCHDOG_ID, "Failed to load the submitter a user id of %user_id. No submitter name can be provided.", array('%user_id' => $item->user_id), WATCHDOG_WARNING);
        $row['submitter_name'] = '';
      }

      unset($submitter);
    }

    if (isset($columns['submitted_on'])) {
      $date_stamp = $item->created;

      $row['submitted_on'] = array(
        'data' => check_plain(date("Y/m/d h:i a", $date_stamp)),
        'class' => 'column-submitted_on',
      );
    }

    if (isset($columns['operations'])) {
      $row['operations'] = array(
        'data' => '',
        'class' => 'column-operations no-print',
      );

      $row['operations']['data'] = '';

      $row['operations']['data'] .= '<a href="' . $base_path . 'requests/view-0/' . $item->id . '" class="operation-link operation-link-view">View</a> ';

      if (array_key_exists($item->id, $can_edit_requests) && $can_edit_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/edit-0/' . $item->id . '/request" class="operation-link operation-link-edit">Edit</a> ';
      }

      if (array_key_exists($item->id, $can_review_requests) && $can_review_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/view-0/' . $item->id . '/' . MFCS_VIEW_MODE_OPERATIONS . '" class="operation-link operation-link-review">Review</a> ';
      }

      if (array_key_exists($item->id, $can_log_requests) && $can_log_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/view-0/' . $item->id . '/' . MFCS_VIEW_MODE_LOG . '" class="operation-link operation-link-log">Log</a> ';
      }

      if (array_key_exists($item->id, $can_history_requests) && $can_history_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/history-0/' . $item->id . '" class="operation-link operation-link-history">History</a> ';
      }

      if (array_key_exists($item->id, $can_delete_requests) && $can_delete_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/delete-0/' . $item->id . '" class="operation-link operation-link-delete">Delete</a> ';
      }

      if (array_key_exists($item->id, $can_create_requests) && $can_create_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/create-0/' . $item->id . '" class="operation-link operation-link-clone">Copy</a> ';
      }
    }

    $rows[$item->id] = $row;
  }

  $table['rows'] = $rows;
  $table['error'] = FALSE;

  return $table;
}

/**
 * Load venue coordinators that are available.
 *
 * @return array|bool
 *   An array of venue coordinators or FALSE on error.
 */
function mfcs_request_get_available_venue_coordinators() {
  $ilike = 'LIKE';
  if (db_driver() == 'pgsql') {
    $ilike = 'ILIKE';
  }

  try {
    $query = db_select('users', 'u');
    $query->innerJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
    $query->innerJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND u.uid = fdfuln.entity_id AND fdfufn.entity_id = fdfuln.entity_id AND fdfuln.delta = 0');

    $query->addField('u', 'uid', 'user_id');
    $query->addField('u', 'name', 'name');
    $query->addField('u', 'mail', 'email');

    $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
    $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');

    $subquery = db_select('mfcs_banner_rooms', 'mbr');
    $subquery->addField('mbr', 'coordinator_id', 'coordinator_id');
    $subquery->condition('mbr.disabled', 0);
    $subquery->distinct();

    $query->condition('u.uid', $subquery, 'IN');
    $query->condition('u.status', 0, '<>');
    $query->condition('u.uid', 1, '>');

    $query->orderBy('last_name');
    $query->orderBy('first_name');
    $query->orderBy('name');
    $query->orderBy('uid');

    $results = $query->execute()->fetchAll();
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);
    return FALSE;
  }

  $matches = array();
  foreach ($results as $result) {
    $name = "";
    if (!empty($result->last_name)) {
      $name .= $result->last_name;
    }

    if (!empty($result->last_name)) {
      if (!empty($name)) {
        $name .= ", ";
      }
      $name .= $result->first_name;
    }

    $name_value = $name;

    if (!empty($name)) {
      $name = '"' . $name . '" ';
    }

    $value = $name . $result->email;
    $matches[$result->user_id] = $value;
  }

  return $matches;
}

/**
 * Loads a list of reviewers who have yet to review the given request.
 *
 * This only applies to the current active review state.
 *
 * @param int $request_id
 *   The request id of the request to operate on.
 *
 * @return array|bool
 *   An array of reviewers, with their reviewer classifications, who have not
 *   yet reviewed the given request. FALSE is returned on error.
 */
function mfcs_get_reviewers_yet_to_review($request_id) {
  $request = mfcs_load_request_by_id($request_id);

  if (empty($request)) {
    return FALSE;
  }

  $conditions = array(
    'mr.request_classification' => $request['request_coordinator']['classification'][0]->value,
    'mr.review_step' => $request['top']['step'][0]->value,
    'mr.disabled' => 0,
  );

  $reviewers = mfcs_get_reviewers($conditions);
  if (empty($reviewers)) {
    return array();
  }

  mfcs_include(MFCS_INCLUDE_LIST_OPTIONS);

  $reviewer_classification_options = mfcs_get_reviewer_classification_list_options();

  $review_classifications = array();
  $reviewer_ids = array();
  $yet_to_review = array();

  foreach ($reviewers as $reviewer) {
    if (!isset($review_classifications[$reviewer->user_id])) {
      $review_classifications[$reviewer->user_id] = array();
    }

    $review_classifications[$reviewer->user_id][$reviewer->reviewer_classification] = $reviewer->reviewer_classification;
    $reviewer_ids[$reviewer->user_id] = $reviewer->user_id;
    $yet_to_review[$reviewer->reviewer_classification] = $reviewer_classification_options[$reviewer->reviewer_classification];
  }
  unset($reviewers);

  try {
    $query = db_select('mfcs_field_review_review', 'mfrr');
    $query->innerJoin('mfcs_current_review', 'mcr', 'mfrr.request_id = mcr.request_id and mfrr.revision = mcr.review');

    $query->addField('mfrr', 'user_id', 'user_id');

    $query->condition('mfrr.request_id', $request_id);
    $query->condition('mfrr.step', $request['top']['step'][0]->value);
    $query->condition('mfrr.user_id', $reviewer_ids, 'IN');
    $query->condition('mfrr.decision', array(MFCS_REVIEW_DECISION_APPROVE, MFCS_REVIEW_DECISION_DENY), 'IN');
    $query->distinct();

    $results = $query->execute()->fetchAll();

    if (!empty($results)) {
      foreach ($results as $result) {
        if (array_key_exists($result->user_id, $review_classifications)) {
          foreach ($review_classifications[$result->user_id] as $review_classification) {
            unset($yet_to_review[$review_classification]);
          }
        }
      }
    }
  }
  catch (Exception $ex) {
    cf_error::on_query_execution($ex);

    return FALSE;
  }

  return $yet_to_review;
}

/**
 * Loads a list of requests that did not provide insurance.
 *
 * This only loads requests that require insurance.
 * This only loads requests that have been accepted.
 *
 * @param int|null $date_from
 *   When specified, a unix timestamp representing a current date to load
 *   requests within a certain amount of time.
 *   When not specified, all results are loaded.
 *   An = is performed on this value when $date_to is null.
 *   A >= is performed on this value when $date_to is an integer.
 * @param int|null $date_to
 *   When specified, a unix timestamp representing a current date to load
 *   requests within a certain amount of time.
 *   When not specified, all results are loaded.
 *   If specified, this requires $date_from to be non-null.
 *   A < is performed on this value.
 *
 * @return array|bool
 *   An array of requests. FALSE is returned on error.
 */
function mfcs_get_requests_not_providing_insurance($date_from = NULL, $date_to = NULL) {
  if (!is_null($date_from)) {
    if (!cf_is_integer($date_from)) {
      cf_error::invalid_integer('date_from');
      return FALSE;
    }

    if (!is_null($date_to) && !cf_is_integer($date_to)) {
      cf_error::invalid_integer('date_to');
      return FALSE;
    }
  }

  $results = array();

  try {
    $query = db_select('mfcs_requests', 'mer');

    $query->innerJoin('mfcs_current_top', 'mct', 'mer.id = mct.request_id');
    $query->innerJoin('mfcs_current_information', 'mci', 'mer.id = mci.request_id');
    $query->innerJoin('mfcs_current_dates', 'mcd', 'mer.id = mcd.request_id');
    $query->innerJoin('mfcs_current_insurance', 'mcie', 'mer.id = mci.request_id');
    $query->innerJoin('mfcs_current_request_coordinator', 'mcrc', 'mer.id = mcrc.request_id');

    $query->innerJoin('mfcs_field_top_status', 'mfts', 'mct.request_id = mfts.request_id AND mct.status = mfts.revision AND mfts.delta = 0');
    $query->innerJoin('mfcs_field_top_step', 'mftsp', 'mct.request_id = mftsp.request_id AND mct.step = mftsp.revision AND mftsp.delta = 0');

    $query->innerJoin('mfcs_field_information_title', 'mfit', 'mci.request_id = mfit.request_id AND mci.title = mfit.revision AND mfit.delta = 0');

    $query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mcd.request_id = mfdd.request_id AND mcd.date = mfdd.revision');

    $query->innerJoin('mfcs_field_insurance_contractor', 'mfic', 'mcie.request_id = mfic.request_id AND mcie.contractor = mfic.revision AND mfic.delta = 0');
    $query->innerJoin('mfcs_field_insurance_unaffiliated', 'mfiu', 'mcie.request_id = mfiu.request_id AND mcie.unaffiliated = mfiu.revision AND mfiu.delta = 0');
    $query->innerJoin('mfcs_field_insurance_provided', 'mfip', 'mcie.request_id = mfip.request_id AND mcie.provided = mfip.revision AND mfip.delta = 0');

    $query->innerJoin('mfcs_field_request_coordinator_name', 'mfrcn', 'mcrc.request_id = mfrcn.request_id AND mcrc.name = mfrcn.revision AND mfrcn.delta = 0');
    $query->innerJoin('mfcs_field_request_coordinator_email', 'mfrce', 'mcrc.request_id = mfrce.request_id AND mcrc.email = mfrce.revision AND mfrce.delta = 0');


    $query->addField('mer', 'id', 'id');
    $query->addField('mfit', 'value', 'title');
    $query->addField('mfdd', 'value', 'date');
    $query->addField('mfrcn', 'value', 'coordinator_name');
    $query->addField('mfrce', 'value', 'coordinator_email');


    $allowed_status = array(
      MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    );

    $query->condition('mfts.value', $allowed_status, 'IN');

    $allowed_steps = array(
      MFCS_REVIEW_STEP_COMPLETED,
    );

    $query->condition('mftsp.value', $allowed_steps, 'IN');

    $or = db_or();
    $or->condition('mfic.value', 1);
    $or->condition('mfiu.value', 1);
    $query->condition($or);

    $nand = db_and();
    $nand->not();
    $nand->condition('mfip.value', 1);
    $query->condition($nand);

    if (!is_null($date_from)) {
      if (is_null($date_to)) {
        $query->condition('mfdd.value', $date_from);
      }
      else {
        $query->condition('mfdd.value', $date_from, '>=');
        $query->condition('mfdd.value', $date_to, '<');
      }
    }


    $query->orderBy('mfdd.value');


    $results = $query->execute()->fetchAll();

    if (empty($results)) {
      return array();
    }
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  return $results;
}

/**
 * Determines the current dates for reminders relative to the current day.
 *
 * There are a number of problems with the PHP date system that forced me
 * to write this function.
 *
 * The usage of the word 'this' is broken in php's strtotime function.
 * In regards to weeks, the word 'this' is treated as if it were the word
 * 'next', except for then the current day is today.
 *
 * To get the current day for 'this' week, one must use 'first sunday this
 * week' and compare the value to 'today'.
 *
 * If the value of 'today' is identical to 'this week', then that value can
 * be used.
 *
 * If the value of 'today' is different from 'this week', then take the
 * _previous_ weeks date!
 *
 * strtotime also does not support 'first day of week', which actually gives
 * the first day of the month!
 *
 * strtotime also does not process the word 'of' in the same manner, thus
 * 'first sunday this week' != 'first sunday of this week'.
 *
 * strotime also treats 'last week' and '-1 week' differently, last week might
 * return monday even when working with sunday.
 * - This is probably true for 'this week', and 'next week' as well.
 *
 * @return array
 *   An array containing dates relative to today.
 *   - 'today': contains the current day at 00:00.
 *   - 'week_day': contains the first day of the current week at 00:00.
 *   - 'first_day_this_week': contains the proper first day 'this' week at
 *     00:00.
 */
function mfcs_request_reminders_get_dates() {
  $dates = array();

  $dates['today'] = strtotime('today');
  $dates['yesterday'] = strtotime('yesterday', $dates['today']);
  $dates['tomorrow'] = strtotime('tomorrow', $dates['today']);

  $dates['week_day'] = strtotime('first sunday this week');
  #$dates['week_day'] = strtotime('first monday this week'); // iso-8601

  if ($dates['week_day'] == $dates['today']) {
    $dates['first_day_this_week'] = $dates['week_day'];
  }
  else {
    $dates['first_day_this_week'] = strtotime('-1 week', $dates['week_day']);
  }

  return $dates;
}

/**
 * Clears the cache for request reminders that are old.
 *
 * @param int $type
 *   The reminder type to clear all old data for.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_clear_request_reminders($type) {
  if (!cf_is_integer($type)) {
    cf_error::invalid_integer('type');
    return FALSE;
  }

  $dates = mfcs_request_reminders_get_dates();

  try {
    $query = db_delete('mfcs_request_reminders');

    $query->condition('type', $type);

    $or = db_or();

    $days_30 = strtotime('-30 days', $dates['today']);
    $and = db_and();
    $and->condition('interval', MFCS_REMINDER_INTERVAL_DAY_30);
    $and->condition('date', $days_30, '<');
    $or->condition($and);

    $query->condition($or);

    $query->execute();
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  return TRUE;
}

/**
 * Loads the request reminders for a certain reminder type and request.
 *
 * @param array $dates
 *   Should be the dates as defined by mfcs_request_reminders_get_dates().
 *   Provided as an argument here rather than calling the function for
 *   performance reasons.
 * @param int $type
 *   The reminder type to clear all old data for.
 * @param int|null $interval
 *   (optional) When specified, loads reminders only for the specified inteval.
 * @param int|null $request_id
 *   (optional) When specified, loads reminders only for the specified request.
 *
 * @return array|bool
 *   An array of reminders or FALSE on failure.
 *
 * @see: mfcs_request_reminders_get_dates()
 */
function mfcs_get_request_reminders($dates, $type, $interval = NULL, $request_id = NULL) {
  if (!is_array($dates)) {
    cf_error::invalid_array('dates');
    return FALSE;
  }

  if (!cf_is_integer($type)) {
    cf_error::invalid_integer('type');
    return FALSE;
  }

  if (!is_null($interval) && !cf_is_integer($interval)) {
    cf_error::invalid_integer('interval');
    return FALSE;
  }

  if (!is_null($request_id) && !cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  $results = array(
    MFCS_REMINDER_INTERVAL_DAY_30 => array(),
  );

  try {
    $query = db_select('mfcs_request_reminders', 'mrr');

    $query->fields('mrr');
    $query->condition('type', $type);

    if (!is_null($request_id)) {
      $query->condition('request_id', $request_id);
    }

    // perform separate queries instead of doing a php loop to rebuild the results in the desired structure.
    // this puts the work onto the database, which is generally more efficient at such tasks at the cost of multiple queries.
    // when $interval is specified, then only one of these queries is performed.

    if (is_null($interval) || $interval == MFCS_REMINDER_INTERVAL_DAY_30) {
      $days_30 = strtotime('-30 days', $dates['today']);
      $query_day_30 = clone $query;
      $query_day_30->condition('interval', MFCS_REMINDER_INTERVAL_DAY_30);
      $query_day_30->condition('date', $days_30, '>=');
      $results[MFCS_REMINDER_INTERVAL_DAY_30] = $query_day_30->execute()->fetchAllAssoc('request_id');
    }
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  return $results;
}

/**
 * Saves the request reminder into the cache.
 *
 * @param array $reminder
 *   An array containing the reminder values.
 *
 * @param bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_save_request_reminders($reminder) {
  if (!is_array($reminder)) {
    cf_error::invalid_array('reminder');
    return FALSE;
  }

  if (!isset($reminder['request_id']) || !cf_is_integer($reminder['request_id'])) {
    cf_error::invalid_integer('reminder[request_id]');
    return FALSE;
  }

  if (!isset($reminder['date']) || !cf_is_integer($reminder['date'])) {
    cf_error::invalid_integer('reminder[date]');
    return FALSE;
  }

  if (!isset($reminder['type']) || !cf_is_integer($reminder['type'])) {
    cf_error::invalid_integer('reminder[type]');
    return FALSE;
  }

  if (!isset($reminder['interval']) || !cf_is_integer($reminder['interval'])) {
    cf_error::invalid_integer('reminder[interval]');
    return FALSE;
  }

  try {
    $query = db_insert('mfcs_request_reminders');

    $query->fields($reminder);
    $query->execute();
  }
  catch (Exception $ex) {
    cf_error::on_exception($ex);
    return FALSE;
  }

  return TRUE;
}

/**
 * Adds canonical and short url links to the http meta and headers.
 *
 * Will also add the content-location http header via the unique path.
 *
 * @param string $unique_path
 *   The canonical path used to uniquely identify this page.
 * @param string $short_path
 *   (optional) A short version of the unique path. If not specified, then the
 *   unique path is also specified as the short path.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_add_canonical_headers($unique_path, $short_path = NULL) {
  if (!is_string($unique_path)) {
    cf_error::invalid_string('unique_path');
    return FALSE;
  }

  if (!is_null($short_path) && !is_string($short_path)) {
    cf_error::invalid_string('short_path');
    return FALSE;
  }

  if (is_null($short_path)) {
    $short_path = $unique_path;
  }

  global $base_path;

  // expose settings as a static variable so that the theme can find and process.
  $mfcs_canonical = &drupal_static('mfcs_canonical', array());

  $mfcs_canonical[] = array(
    'rel' => 'canonical',
    'href' => $base_path . $unique_path,
  );

  $mfcs_canonical[] = array(
    'rel' => 'shortlink',
    'href' => $base_path . $short_path,
  );

  // provide content-location http header.
  drupal_add_http_header('content-location', $base_path . $unique_path, FALSE);

  return TRUE;
}

/**
 * Load a unix timestamp instance.
 *
 * This functions similar to REQUEST_TIME, except it is updatable within a
 * single script execution. This is necessary when performing multiple tasks
 * that are not grouped togethor.
 *
 * @param bool $reset
 *   (optional) When TRUE, will reset the instance to the current timestamp.
 *
 * @return int
 *   The instance timestamp.
 */
function mfcs_instance($reset = FALSE) {
  $instance = &drupal_static(__function__, NULL);

  if (is_null($instance)) {
    $instance = REQUEST_TIME;
  }
  elseif ($reset === TRUE) {
    $instance = strtotime('now');
  }

  return $instance;
}

/**
 * @} End of '@defgroup mfcs McNeese Facilities Use'.
 */
