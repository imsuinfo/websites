<?php

/**
 * @file
 * McNeese State University Facilities Use module.
 */

/**
 * @defgroup mfcs McNeese Facilities Use
 * @{
 * Provides Workflow specific module functionality for the Requests Workflow
 * System.
 */

/**
 * Defines request status codes.
 */
define('MFCS_REQUEST_STATUS_DELETED', 0);
define('MFCS_REQUEST_STATUS_LOCKED', 1);
define('MFCS_REQUEST_STATUS_UNLOCKED', 2);
define('MFCS_REQUEST_STATUS_CLOSED_ACCEPTED', 3);
define('MFCS_REQUEST_STATUS_CLOSED_DENIED', 4);
define('MFCS_REQUEST_STATUS_CLOSED_UNAVAILABLE', 5);
define('MFCS_REQUEST_STATUS_CLOSED_DUE_TO_LOCK', 6);
define('MFCS_REQUEST_STATUS_CANCELLED', 7);
define('MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED', 8);

/**
 * Defines Taxonomy VIDs.
 */
 define('MFCS_VID_REQUEST_CLASSIFICATION', 1);
 define('MFCS_VID_REQUEST_STEPS', 19);
 define('MFCS_VID_REQUEST_LOCATION', 7);
 define('MFCS_VID_REQUEST_AUDIENCE', 9);
 define('MFCS_VID_REQUEST_REVENUE_GENERATED', 15);
 define('MFCS_VID_REQUEST_REQUEST_TYPE', 8);
 define('MFCS_VID_REQUEST_PUBLICITY_DETAILS', 11);
 define('MFCS_VID_REQUEST_DESIGNING_MATERIAL', 16);
 define('MFCS_VID_REQUEST_TECHNICAL_EQUIPMENT_DETAILS', 10);
 define('MFCS_VID_REQUEST_REVIEWER_CLASSIFICATION', 17);
 define('MFCS_VID_REQUEST_REVIEWER_DECISION', 18);
 define('MFCS_VID_REQUEST_DATES_CATEGORY', 20);

/**
 * Defines Taxonomy TIDs for review steps.
 */
 define('MFCS_REVIEW_STEP_CHANGES_REQUIRED', 140);
 define('MFCS_REVIEW_STEP_COMPLETED', 134);
 define('MFCS_REVIEW_STEP_MAKE_DECISIONS', 117);
 define('MFCS_REVIEW_STEP_RELEASE_HOLD', 118);
 define('MFCS_REVIEW_STEP_REVIEW', 132);
 define('MFCS_REVIEW_STEP_REQUIREMENTS', 133);
 define('MFCS_REVIEW_STEP_VENUE_AVAILABLE', 116);

/**
 * Defines Taxonomy TID for review decisions.
 */
 define('MFCS_REVIEW_DECISION_MANAGER_RECHECK', -1);
 define('MFCS_REVIEW_DECISION_AMENDMENT', 141);
 define('MFCS_REVIEW_DECISION_APPROVE', 115);
 define('MFCS_REVIEW_DECISION_COMMENT', 113);
 define('MFCS_REVIEW_DECISION_COMMENT_ALL', 152);
 define('MFCS_REVIEW_DECISION_DENY', 114);
 define('MFCS_REVIEW_DECISION_WAIVE', 135);
 define('MFCS_REVIEW_DECISION_REQUIREMENT', 136);
 define('MFCS_REVIEW_DECISION_AVAILABLE', 148);
 define('MFCS_REVIEW_DECISION_UNAVAILABLE', 149);
 define('MFCS_REVIEW_DECISION_ISSUES', 150);
 define('MFCS_REVIEW_DECISION_ISSUES_NONE', 151);

 /**
 * Defines restrictions review decisions.
 */
 define('MFCS_RESTRICTION_DECISION_NONE', 0);
 define('MFCS_RESTRICTION_DECISION_REQUESTER', 1);
 define('MFCS_RESTRICTION_DECISION_VENUE_COORDINATOR', 2);
 define('MFCS_RESTRICTION_DECISION_REVIEWER', 3);
 define('MFCS_RESTRICTION_DECISION_APPROVER', 4);
 define('MFCS_RESTRICTION_DECISION_MANAGER', 5);
 define('MFCS_RESTRICTION_DECISION_ADMINISTER', 6);
 define('MFCS_RESTRICTION_DECISION_COMMENT_ONLY', 7);

 // These are hidden/reserved and are used to populate the review log when certain operations have been performed.
 define('MFCS_REVIEW_DECISION_CLOSED', 1);
 define('MFCS_REVIEW_DECISION_CANCELLED', 2);
 define('MFCS_REVIEW_DECISION_UNCANCELLED', 3);
 define('MFCS_REVIEW_DECISION_REASSIGNED', 4);
 define('MFCS_REVIEW_DECISION_OVERRIDE', 5);

/**
 * Defines Taxonomy TIDs for review classifications.
 */
 define('MFCS_REVIEWER_CLASSIFICATION_ADMINISTRATIVE_ACCOUNTING', 105);
 define('MFCS_REVIEWER_CLASSIFICATION_CUSTODIAL', 147);
 define('MFCS_REVIEWER_CLASSIFICATION_EVENT_COORDINATOR', 99);
 define('MFCS_REVIEWER_CLASSIFICATION_FACILITIES_CUSTODIAL', 104);
 define('MFCS_REVIEWER_CLASSIFICATION_FACILITIES', 146);
 define('MFCS_REVIEWER_CLASSIFICATION_FACULTY_ADVISOR', 100);
 define('MFCS_REVIEWER_CLASSIFICATION_FOOD_SERVICES', 108);
 define('MFCS_REVIEWER_CLASSIFICATION_HOUSING', 107);
 define('MFCS_REVIEWER_CLASSIFICATION_MAINTENANCE', 103);
 define('MFCS_REVIEWER_CLASSIFICATION_PURCHASING', 106);
 define('MFCS_REVIEWER_CLASSIFICATION_SECURITY', 102);
 define('MFCS_REVIEWER_CLASSIFICATION_STUDENT_SERVICE_ADMINISTRATION', 145);
 define('MFCS_REVIEWER_CLASSIFICATION_UNIVERSITY_SERVICES', 101);
 define('MFCS_REVIEWER_CLASSIFICATION_VENUE_COORDINATOR', 112);
 define('MFCS_REVIEWER_CLASSIFICATION_VENUE_COORDINATOR_PROXY', 144);

 // these are not taxonomy-created classifications, they are instead unique ids.
 define('MFCS_REVIEWER_CLASSIFICATION_SYSTEM_ADMINISTRATOR', 1);
 define('MFCS_REVIEWER_CLASSIFICATION_MANAGER', 2);
 define('MFCS_REVIEWER_CLASSIFICATION_REQUESTER', 3);
 define('MFCS_REVIEWER_CLASSIFICATION_SYSTEM', 4);

/**
 * Defines Taxonomy TIDs for request classifications.
 */
 define('MFCS_REQUEST_CLASSIFICATION_STUDENT', 1);
 define('MFCS_REQUEST_CLASSIFICATION_CAMPS', 2);
 define('MFCS_REQUEST_CLASSIFICATION_FACULTY', 3);
 define('MFCS_REQUEST_CLASSIFICATION_EXTERNAL', 4);

/**
 * Defines Taxonomy TIDs for user classifications.
 */
 define('MFCS_USER_CLASSIFICATION_STUDENT', 87);
 define('MFCS_USER_CLASSIFICATION_CAMPS', 88);
 define('MFCS_USER_CLASSIFICATION_FACULTY', 89);
 define('MFCS_USER_CLASSIFICATION_EXTERNAL', 90);

/**
 * Defines Taxonomy TIDs for request dates categories.
 */
 define('MFCS_REQUEST_DATES_CATEGORY_ACTUAL', 137);
 define('MFCS_REQUEST_DATES_CATEGORY_SETUP', 138);
 define('MFCS_REQUEST_DATES_CATEGORY_CLEANUP', 139);

/**
 * Defines operator codes for building search queries.
 */
 define('MFCS_OPERATOR_LESS_THAN', 1);
 define('MFCS_OPERATOR_LESS_THAN_EQUAL', 2);
 define('MFCS_OPERATOR_EQUAL', 3);
 define('MFCS_OPERATOR_LIKE', 4);
 define('MFCS_OPERATOR_SLIKE', 5);
 define('MFCS_OPERATOR_ILIKE', 6);
 define('MFCS_OPERATOR_GREATER_THAN_EQUAL', 7);
 define('MFCS_OPERATOR_GREATER_THAN', 8);
 define('MFCS_OPERATOR_NOT_EQUAL', 9);
 define('MFCS_OPERATOR_NOT_LIKE', 10);
 define('MFCS_OPERATOR_NOT_SLIKE', 11);
 define('MFCS_OPERATOR_NOT_ILIKE', 12);
 define('MFCS_OPERATOR_IS_NULL', 13);
 define('MFCS_OPERATOR_IS_NOT_NULL', 14);
 define('MFCS_OPERATOR_IS_IN', 15);
 define('MFCS_OPERATOR_IS_NOT_IN', 16);

/**
 * Defines table join codes for building search queries.
 */
 define('MFCS_JOIN_INNER', 1);
 define('MFCS_JOIN_LEFT', 2);
 define('MFCS_JOIN_RIGHT', 3);
 define('MFCS_JOIN_OUTER', 4);

/**
 * Defines a recursion limit for the search and/or operations.
 */
 define('MFCS_MAX_SEARCH_RECURSION', 3);

/**
 * Defines a standardized string for consiting watchdog error reporting.
 */
 define('MFCS_WATCHDOG_ID', 'mfcs');

/**
 * Defines standard view modes.
 */
 define('MFCS_VIEW_MODE_NORMAL', 'normal');
 define('MFCS_VIEW_MODE_DISPLAY', 'display');
 define('MFCS_VIEW_MODE_LOG', 'log');
 define('MFCS_VIEW_MODE_OPERATIONS', 'operations');

/**
 * Defines PDF types.
 */
 define('MFCS_PDF_TYPE_REQUEST', 0);
 define('MFCS_PDF_TYPE_AGREEMENT', 1);

/**
 * Defines e-mail reminder types.
 */
 define('MFCS_REMINDER_TYPE_INSURANCE_NOT_PROVIDED', 0);

/**
 * Defines e-mail reminder intervals.
 */
 define('MFCS_REMINDER_INTERVAL_DAY_0', 0);
 define('MFCS_REMINDER_INTERVAL_DAY_1', 1);
 define('MFCS_REMINDER_INTERVAL_DAY_2', 2);
 define('MFCS_REMINDER_INTERVAL_DAY_3', 3);
 define('MFCS_REMINDER_INTERVAL_DAY_4', 4);
 define('MFCS_REMINDER_INTERVAL_DAY_5', 5);
 define('MFCS_REMINDER_INTERVAL_DAY_6', 6);
 define('MFCS_REMINDER_INTERVAL_DAY_7', 7);
 define('MFCS_REMINDER_INTERVAL_DAY_8', 8);
 define('MFCS_REMINDER_INTERVAL_DAY_9', 9);
 define('MFCS_REMINDER_INTERVAL_DAY_10', 10);
 define('MFCS_REMINDER_INTERVAL_DAY_11', 11);
 define('MFCS_REMINDER_INTERVAL_DAY_12', 12);
 define('MFCS_REMINDER_INTERVAL_DAY_30', 30);
 define('MFCS_REMINDER_INTERVAL_WEEK_0', 1000);
 define('MFCS_REMINDER_INTERVAL_WEEK_1', 1001);
 define('MFCS_REMINDER_INTERVAL_WEEK_2', 1002);
 define('MFCS_REMINDER_INTERVAL_WEEK_3', 1003);
 define('MFCS_REMINDER_INTERVAL_WEEK_4', 1004);
 define('MFCS_REMINDER_INTERVAL_WEEK_5', 1005);
 define('MFCS_REMINDER_INTERVAL_WEEK_6', 1006);
 define('MFCS_REMINDER_INTERVAL_WEEK_7', 1007);
 define('MFCS_REMINDER_INTERVAL_WEEK_8', 1008);
 define('MFCS_REMINDER_INTERVAL_WEEK_9', 1009);
 define('MFCS_REMINDER_INTERVAL_WEEK_10', 1010);
 define('MFCS_REMINDER_INTERVAL_WEEK_11', 1011);
 define('MFCS_REMINDER_INTERVAL_WEEK_12', 1012);

/**
 * Defines e-mail priority codes.
 */
 define('MFCS_MAIL_PRIORITY_HIGHEST', 1);
 define('MFCS_MAIL_PRIORITY_HIGH', 2);
 define('MFCS_MAIL_PRIORITY_NORMAL', 3);
 define('MFCS_MAIL_PRIORITY_LOW', 4);
 define('MFCS_MAIL_PRIORITY_LOWEST', 5);

/**
 * Defines Taxonomy TIDs for review steps.
 */
 define('MFCS_REQUEST_TYPE_ATHLETIC', 66);
 define('MFCS_REQUEST_TYPE_BANQUET', 61);
 define('MFCS_REQUEST_TYPE_CEREMONY', 64);
 define('MFCS_REQUEST_TYPE_FAIR', 65);
 define('MFCS_REQUEST_TYPE_LECTURE', 59);
 define('MFCS_REQUEST_TYPE_MEETING', 57);
 define('MFCS_REQUEST_TYPE_OTHER', 67);
 define('MFCS_REQUEST_TYPE_PERFORMANCE', 58);
 define('MFCS_REQUEST_TYPE_QUICK_MEETING', 142);
 define('MFCS_REQUEST_TYPE_RECEPTION', 60);
 define('MFCS_REQUEST_TYPE_TALENT', 63);
 define('MFCS_REQUEST_TYPE_WORKSHOP', 62);

/**
 * Defines Taxonomy TIDs for request classifications.
 */
 define('MFCS_REQUEST_AUDIENCE_FACULTY_AND_STAFF', 71);
 define('MFCS_REQUEST_AUDIENCE_GUESTS_ONLY', 68);
 define('MFCS_REQUEST_AUDIENCE_STUDENTS_AND_EMPLOYEES', 70);
 define('MFCS_REQUEST_AUDIENCE_PUBLIC', 72);
 define('MFCS_REQUEST_AUDIENCE_STUDENTS_ONLY', 69);

/**
 * Defines file include codes.
 */
define('MFCS_INCLUDE_TABLE', 0);
define('MFCS_INCLUDE_STRUCTURE', 1);
define('MFCS_INCLUDE_VALIDATION', 2);
define('MFCS_INCLUDE_AUTOCOMPLETE', 3);
define('MFCS_INCLUDE_LIST_OPTIONS', 4);
define('MFCS_INCLUDE_WORKFLOW', 5);
define('MFCS_INCLUDE_HOOKS', 6);
define('MFCS_INCLUDE_OUTPUT', 7);
define('MFCS_INCLUDE_MISCELLANEOUS', 8);
define('MFCS_INCLUDE_ACCESS', 9);
define('MFCS_INCLUDE_ICAL', 10);
define('MFCS_INCLUDE_REQUEST_CANCEL', 11);
define('MFCS_INCLUDE_REQUEST_CREATE', 12);
define('MFCS_INCLUDE_REQUEST_VIEW', 13);
define('MFCS_INCLUDE_REQUEST_LIST', 14);
define('MFCS_INCLUDE_REQUEST_OVERRIDE', 21);
define('MFCS_INCLUDE_REQUEST_REASSIGN', 18);
define('MFCS_INCLUDE_REQUEST_ICAL', 19);
define('MFCS_INCLUDE_REQUEST_USERS', 20);
define('MFCS_INCLUDE_TESTING', 15);
define('MFCS_INCLUDE_VIEW', 16);
define('MFCS_INCLUDE_MANAGEMENT', 17);

/**
 * Defines review restrictions.
 */
define('MFCS_REVIEW_RESTRICTION_NONE', 0);
define('MFCS_REVIEW_RESTRICTION_VIEW', 1);
define('MFCS_REVIEW_RESTRICTION_REVIEW', 2);
define('MFCS_REVIEW_RESTRICTION_COMMENT', 3);

/**
 * Defines troubleshoot codes.
 */
define('MFCS_TROUBLESHOOT_NONE', 0);
define('MFCS_TROUBLESHOOT_REQUESTS_REVIEW_RECHECK', 1);
define('MFCS_TROUBLESHOOT_MER_CACHE_SYNCHRONIZE', 2);
define('MFCS_TROUBLESHOOT_BANNER_CACHE_SYNCHRONIZE', 3);
define('MFCS_TROUBLESHOOT_BANNER_ROLE_SYNCHRONIZE', 4);
define('MFCS_TROUBLESHOOT_BANNER_INFORMATION', 5);
define('MFCS_TROUBLESHOOT_REQUESTS_PROBLEM_CHECK', 6);

/**
 * Defines problems log codes.
 */
define('MFCS_LOG_PROBLEMS_NONE', 0);
define('MFCS_LOG_PROBLEMS_INSERT', 1);
define('MFCS_LOG_PROBLEMS_UPDATE', 2);
define('MFCS_LOG_PROBLEMS_DELETE', 3);
define('MFCS_LOG_PROBLEMS_RESYNC', 4);
define('MFCS_LOG_PROBLEMS_IGNORE', 5);
define('MFCS_LOG_PROBLEMS_UNIGNORE', 6);
define('MFCS_LOG_PROBLEMS_RECHECK', 7);
define('MFCS_LOG_PROBLEMS_REASSIGN_VENUE_COORDINATOR', 8);
define('MFCS_LOG_PROBLEMS_REASSIGN_REQUESTER', 9);
define('MFCS_LOG_PROBLEMS_REASSIGN_REBUILD_CACHE', 10);

/**
 * Defines some hard-limits.
 */
define('MFCS_EMAIL_MAX_SUBJECT_LENGTH', 384);
define('MFCS_EMAIL_MAX_DESTINATION_LENGTH', 255);

/**
 * Define a default range (in seconds) for nearby requests.
 */
define('MFCS_NEARBY_REQUESTS_RANGE_SECONDS', 1800);

/**
 * Defines a series of bitwise values for designating problems a particular user is having.
 */
define('MFCS_USER_PROBLEM_NONE', 0);
define('MFCS_USER_PROBLEM_MASK', 18446744073709551615);
define('MFCS_USER_PROBLEM_SYSTEM', 1);
define('MFCS_USER_PROBLEM_MFCS', 2);
define('MFCS_USER_PROBLEM_ACCOUNT_CREATE_BANNER_UNAVAILABLE', 4);
define('MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE', 8);
define('MFCS_USER_PROBLEM_ACCOUNT_LOGIN_PROBLEMS_MULTIPLE', 16);
define('MFCS_USER_PROBLEM_FORM_ERROR_USER', 32);
define('MFCS_USER_PROBLEM_FORM_ERROR_SYSTEM', 64);
define('MFCS_USER_PROBLEM_ACCOUNT_REVIEWER_NOT_ALLOWED', 128);
define('MFCS_USER_PROBLEM_ACCOUNT_DUPLICATES', 256);
define('MFCS_USER_PROBLEM_ACCOUNT_DISABLED_IN_USE', 512);
define('MFCS_USER_PROBLEM_ACCOUNT_BANNER_INVALID', 1024);
define('MFCS_USER_PROBLEM_ACCOUNT_NO_ACCESS', 2048);

/**
 * Defines a series of request problems.
 */
define('MFCS_REQUEST_PROBLEM_NONE', 0);
define('MFCS_REQUEST_PROBLEM_CONFLICT', 1); // multiple requests with the same date and time.
define('MFCS_REQUEST_PROBLEM_STALE', 2); // request is past its date and time and is considered stale (or lost).
define('MFCS_REQUEST_PROBLEM_STUCK', 3); // the request is stuck in its current state or step and cannot continue.
define('MFCS_REQUEST_PROBLEM_BLOCKED', 4); // the request is blocked by another request from continuing (similar to both stuck and conflict).
define('MFCS_REQUEST_PROBLEM_COORDINATOR', 5); // coordinator no longer exists, is disabled, or is otherwise invalid.
define('MFCS_REQUEST_PROBLEM_REQUESTER', 6); // requestor no longer exists, is disabled, or is otherwise invalid.
define('MFCS_REQUEST_PROBLEM_ROOM', 7); // room no longer exists, is disabled, or is otherwise invalid.
define('MFCS_REQUEST_PROBLEM_BUILDING', 8); // building no longer exists, is disabled, or is otherwise invalid.
define('MFCS_REQUEST_PROBLEM_LOCATION', 9); // location no longer exists, is disabled, or is otherwise invalid.
define('MFCS_REQUEST_PROBLEM_CACHE_REQUEST', 10); // The mfcs_requests caches are inconsistend with the mfcs_current data.

/**
 * Define codes that represent what the e-mail represents.
 */
define('MFCS_EMAIL_CODE_NORMAL', 0);
define('MFCS_EMAIL_CODE_RESEND', 1);
define('MFCS_EMAIL_CODE_FORWARD', 2);

/**
 * Define codes used to designate cancelling and uncancelling individual dates and times.
 */
define('MFCS_CANCELLING_NOTHING', 0);
define('MFCS_CANCELLING_CANCEL', 1);
define('MFCS_CANCELLING_UNCANCEL', 2);
define('MFCS_CANCELLING_UNAVAILABLE', 3);

/**
 * Define codes representing how to load a listings cancelled content.
 */
define('MFCS_LOAD_CANCELLED_NONE', 0);
define('MFCS_LOAD_CANCELLED_INDIVIDUAL', 1);
define('MFCS_LOAD_CANCELLED_REQUEST', 2);
define('MFCS_LOAD_CANCELLED_ALL', 3);

/**
 * Banner ID constants.
 */
define('MFCS_BANNER_ID_LENGTH', 9);

/**
 * Defines synchronize types.
 */
define('MFCS_SYNCHRONIZE_TYPE_NONE', 0);
define('MFCS_SYNCHRONIZE_TYPE_ICAL', 1);

/**
 * Simulated user accounts.
 */
define('MFCS_USER_ANONYMOUS', 0);
define('MFCS_USER_SYSTEM', 1);
define('MFCS_USER_REQUEST', -1);

/**
 * View/Access restrictions for review log and related e-mails.
 */
define('MFCS_REVIEW_RESTRICTIONS_NONE', 0);
define('MFCS_REVIEW_RESTRICTIONS_REQUESTER', 1);
define('MFCS_REVIEW_RESTRICTIONS_REVIEWER', 2);
define('MFCS_REVIEW_RESTRICTIONS_MANAGERS', 3);


/**
 * Implements hook_init().
 */
function mfcs_init() {
  global $base_path;
  $module_path = drupal_get_path('module', 'mfcs');

  drupal_add_js($module_path . '/js/printing-fieldsets.js', array('type' => 'file', 'group' => JS_DEFAULT, 'preprocess' => TRUE));

  mfcs_determine_url_arguments();
}

/**
 * Implements hook_permission().
 */
function mfcs_permission() {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_permission();
}

/**
 * Implements hook_menu().
 */
function mfcs_menu() {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_menu();
}

/**
 * Implements hook_user_login().
 */
function mfcs_user_login(&$edit, $account, $category) {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_user_login($edit, $account, $category);
}

/**
 * Implements hook_user_insert().
 */
function mfcs_user_insert(&$edit, $account, $category) {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_user_insert($edit, $account, $category);
}

/**
 * Implements hook_user_presave().
 */
function mfcs_user_presave(&$edit, $account, $category) {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_user_presave($edit, $account, $category);
}

/**
 * Implements hook_user_update().
 */
function mfcs_user_update(&$edit, $account, $category) {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_user_update($edit, $account, $category);
}


/**
 * Access callback for facilities use dashboard page.
 *
 * @param null|string $operation
 *   (optional) When specified, performs access check based on operation.
 * @param null|int|array $request_id
 *   (optional) When specified, performs access check based the provided id.
 *   Can be an array for 'review'.
 * @param null|object $user
 *   (optional) The user object to obtain access for.
 * @param null|string $section
 *   (optional) Check whether or not the user is allowed to perform a certain
 *   operation for a specific section. This is primarily used for the edit
 *   pages.
 *
 * @param bool|array
 *   TRUE on access granted, FALSE otherwise.
 *   An array of boolean values is returned when request_id is an array.
 */
function mfcs_page_dashboard_access() {
  $user = cf_current_user();

  // Manually deny access here because drupals callback is being explicitly blocked.
  if (!is_object($user) || $user->uid == 0 || $user->status == 0) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Access callback for facilities use pages.
 *
 * For already loaded requests, use: mfcs_request_access().
 *
 * This static caches the results in 'mfcs_request_access'.
 *
 * @param null|string $operation
 *   (optional) When specified, performs access check based on operation.
 * @param null|int|array $request_id
 *   (optional) When specified, performs access check based the provided id.
 *   Can be an array for 'review'.
 * @param null|object $user
 *   (optional) The user object to obtain access for.
 * @param null|string $section
 *   (optional) Check whether or not the user is allowed to perform a certain
 *   operation for a specific section. This is primarily used for the edit
 *   pages.
 *
 * @param bool|array
 *   TRUE on access granted, FALSE otherwise.
 *   An array of boolean values is returned when request_id is an array.
 *
 * @see: mfcs_request_access()
 */
function mfcs_page_request_access($operation = NULL, $request_id = NULL, $user = NULL, $section = NULL) {
  if (is_null($user) || !is_object($user)) {
    $user = cf_current_user();
  }

  // anonymous user is denied access to requests as a whole.
  if ($user->uid == 0) {
    return FALSE;
  }

  // allow for request_id to be an array of ids.
  $processed = array();
  if (is_array($request_id)) {
    $request_ids = array();

    foreach ($request_id as $id) {
      $request_ids[$id] = $id;
    }

    // only allow the null array key to be specified by this function.
    unset($request_ids[NULL]);
  }
  elseif (is_null($request_id)) {
    $request_ids = array(NULL => NULL);
  }
  elseif (cf_is_integer($request_id)) {
    $request_ids = array($request_id => $request_id);
  }
  else {
    return FALSE;
  }

  // nothing to check access for.
  if (empty($request_ids)) {
    return FALSE;
  }


  // use advanced static cache for increased performance.
  static $mfcs_request_access_static;

  if (!isset($mfcs_request_access_static)) {
    $mfcs_request_access_static[$operation] = &drupal_static('mfcs_request_access');
  }

  if (!isset($mfcs_request_access_static[$operation][$section][$user->uid])) {
    $mfcs_request_access_static[$operation][$section][$user->uid] = array();
  }

  $access = &$mfcs_request_access_static[$operation][$section][$user->uid];

  if (is_string($request_id) || is_numeric($request_id)) {
    if (array_key_exists($request_id, $access)) {
      return $access[$request_id];
    }
  }
  elseif (is_array($request_id)) {
    $request_ids_copy = $request_ids;
    foreach ($request_ids_copy as $id => $value) {
      if (array_key_exists($id, $access)) {
        $processed[$id] = $access[$id];
        unset($request_ids[$id]);
      }
    }
    unset($request_ids_copy);

    // if all of the requests have been processed, then return.
    if (empty($request_ids)) {
      return $processed;
    }
  }
  elseif (is_null($request_id)) {
    // the request id is allowed to be NULL.
  }
  else {
    return FALSE;
  }

  $request_status = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_UNLOCKED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    MFCS_REQUEST_STATUS_CLOSED_DENIED,
    MFCS_REQUEST_STATUS_CLOSED_UNAVAILABLE,
    MFCS_REQUEST_STATUS_CLOSED_DUE_TO_LOCK,
    MFCS_REQUEST_STATUS_CANCELLED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED,
  );

  $roles = array(
    'manager' => user_access('mfcs manage', $user),
    'reviewer' => user_access('mfcs review', $user),
    'requester' => user_access('mfcs request', $user),
    'administer' => user_access('mfcs administer', $user),

    // @fixme: these roles are hardcoded, implement a more dynamic approach.
    'role_student' => array_search('student role', $user->roles),
    'role_camp' => array_search('camp role', $user->roles),
    'role_employee' => array_search('employee role', $user->roles),
    'role_external' => array_search('external role', $user->roles),
    'bannerless_exception' => array_search('bannerless exception', $user->roles),
    'reviewer_exception' => array_search('reviewer exception', $user->roles),
  );

  // Access will only be granted to administrators, managers, and requesters.
  if (!$roles['administer'] && !$roles['manager'] && !$roles['reviewer'] && !$roles['requester']) {
    return FALSE;
  }

  // Deny access to requesters and reviewers who do not have a student, camp, employee, or external role.
  if (!$roles['administer'] && !$roles['manager']) {
    if (($roles['reviewer'] || $roles['requester']) && !$roles['role_student'] && !$roles['role_camp'] && !$roles['role_employee'] && !$roles['role_external']) {
      return FALSE;
    }
  }

  mfcs_include(MFCS_INCLUDE_ACCESS);

  if ($operation == 'create') {
    $operation_result = mfcs_page_request_access_operation_create($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'edit') {
    $operation_result = mfcs_page_request_access_operation_edit($request_ids, $processed, $access, $roles, $user, $section);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'view') {
    $operation_result = mfcs_page_request_access_operation_view($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'list') {
    if ($roles['requester'] || $roles['reviewer'] || $roles['manager'] || $roles['administer']) {
      if (is_array($request_id)) {
        foreach ($request_ids as $id) {
          $access[$id] = TRUE;
          $processed[$id] = TRUE;
        }

        return $processed;
      }

      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'search') {
    if ($roles['requester'] || $roles['reviewer'] || $roles['manager'] || $roles['administer']) {
      if (is_array($request_id)) {
        foreach ($request_ids as $id) {
          $access[$id] = TRUE;
          $processed[$id] = TRUE;
        }

        return $processed;
      }

      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'reviewers') {
    if ($roles['manager'] || $roles['administer']) {
      if (is_array($request_id)) {
        foreach ($request_ids as $id) {
          $access[$id] = TRUE;
          $processed[$id] = TRUE;
        }

        return $processed;
      }

      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'review') {
    // managers and administers are always allowed to review.
    if ($roles['manager'] || $roles['administer']) {
      if (is_array($request_id)) {
        foreach ($request_ids as $id) {
          $access[$id] = TRUE;
          $processed[$id] = TRUE;
        }

        return $processed;
      }

      $access[$request_id] = TRUE;
      return TRUE;
    }

    $operation_result = mfcs_page_request_access_operation_review($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'comment') {
    $operation_result = mfcs_page_request_access_operation_comment($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'log') {
    $operation_result = mfcs_page_request_access_operation_log($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'delete') {
    $operation_result = mfcs_page_request_access_operation_delete($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'cancel') {
    $operation_result = mfcs_page_request_access_operation_cancel($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'uncancel') {
    $operation_result = mfcs_page_request_access_operation_uncancel($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'cancelling') {
    $operation_result = mfcs_page_request_access_operation_cancelling($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'manage') {
    $operation_result = mfcs_page_request_access_operation_manage($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'override') {
    $operation_result = mfcs_page_request_access_operation_override($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'reassign') {
    $operation_result = mfcs_page_request_access_operation_reassign($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'history') {
    $operation_result = mfcs_page_request_access_operation_history($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'agreement') {
    $operation_result = mfcs_page_request_access_operation_agreement($request_ids, $processed, $access, $roles, $user);

    // if something went wrong with the operation check, return FALSE but do not cache.
    if ($operation_result === FALSE) {
      return FALSE;
    }

    if (is_array($request_id)) {
      return $processed;
    }

    return $processed[$request_id];
  }
  elseif ($operation == 'statistics') {
    if (is_null($request_id)) {
      if ($roles['reviewer'] || $roles['manager'] || $roles['administer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'email_log') {
    if (is_null($request_id)) {
      if ($roles['manager'] || $roles['administer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'email_log-resend') {
    if (is_null($request_id)) {
      if ($roles['manager'] || $roles['administer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'proxy') {
    if (is_null($request_id)) {
      if ($roles['manager'] || $roles['administer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'troubleshoot') {
    if (is_null($request_id)) {
      if ($roles['manager'] || $roles['administer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'problems') {
    if (is_null($request_id)) {
      if ($roles['manager'] || $roles['administer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'help') {
    if (is_null($request_id)) {
      if ($user->uid > 0) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'users') {
    if (is_null($request_id)) {
      if ($roles['manager'] || $roles['administer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }

  if (is_array($request_id)) {
    foreach ($request_ids as $id) {
      $access[$id] = FALSE;
      $processed[$id] = FALSE;
    }

    return $processed;
  }

  $access[$request_id] = FALSE;
  return FALSE;
}

/**
 * Access callback for facilities use synchronize related operations.
 *
 * This is a simple access check and is not cached like the other access checks.
 *
 * @param int|null $type
 *   (optional) When NULL, access to synchronize page is checked.
 *   When not NULL, access to a specific synchronize type is checked.
 * @param string|null $password
 *   (optional) When NULL, this is ignored unless required by the given type.
 *   When not NULL, a string representing the code needed to grant access to the synchronization option.
 * @param int|null $user_id
 *   (optional) When NULL, the id of the current user is used.
 *   When not NULL, the provided user id is used.
 *
 * @param return bool
 *   TRUE on granted, FALSE otherwise.
 */
function mfcs_synchronize_request_access($type = NULL, $password = NULL, $user_id = NULL) {
  if (!is_null($type) && !cf_is_integer($type)) {
    cf_error::invalid_integer('type');
    return FALSE;
  }

  if (!is_null($password) && (!is_string($password) || empty($password))) {
    cf_error::invalid_string('password');
    return FALSE;
  }

  if (is_null($user_id)) {
    $user = cf_current_user();
  }
  else {
    $user = user_load($user_id);
  }

  if (!is_object($user)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  if (is_null($type)) {
    if (user_access('mfcs manage', $user)) {
      return TRUE;
    }

    if (user_access('mfcs administer', $user)) {
      return TRUE;
    }
  }
  elseif ($type == MFCS_SYNCHRONIZE_TYPE_ICAL) {
    if (is_null($password)) {
      return FALSE;
    }

    if (!isset($_SERVER['REMOTE_ADDR']) || empty($_SERVER['REMOTE_ADDR'])) {
      return FALSE;
    }

    // require HTTPS for validity.
    if (!isset($_SERVER['HTTPS'])) {
      return FALSE;
    }

    try {
      $query = db_select('mfcs_synchronize', 'ms');
      $query->addField('ms', 'address', 'address');
      $query->condition('type', MFCS_SYNCHRONIZE_TYPE_ICAL);
      $query->condition('password', $password);

      $results = $query->execute()->fetchAll();

      if (empty($results) && is_object($results)) {
        return FALSE;
      }

      $ip_client = trim($_SERVER['REMOTE_ADDR']);
      foreach ($results as $result) {
        if (!isset($result->address)) {
          continue;
        }

        $ip_valid = trim($result->address);
        if ($ip_client == $ip_valid) {
          return TRUE;
        }
      }
    }
    catch (Error $e) {
      cf_error::on_query_execution($e);

      return FALSE;
    }
    catch (Exception $e) {
      cf_error::on_query_execution($e);

      return FALSE;
    }
  }

  return FALSE;
}

/**
 * Access callback for facilities use unavailability related operations.
 *
 * This is a simple access check and is not cached like the other access checks.
 *
 * @param string $operation
 *   The operation to check access against.
 * @param int|null $year
 *   (optional) When not NULL, the current year is checked.
 *   Years in the past are denied access, depending on operation.
 * @param int|null $holiday_id
 *   (optional) When NULL, this is ignored.
 *   When not NULL, access to a specific holiday id is checked.
 * @param int|null $user_id
 *   (optional) When NULL, the id of the current user is used.
 *   When not NULL, the provided user id is used.
 *
 * @param return bool
 *   TRUE on granted, FALSE otherwise.
 */
function mfcs_holiday_request_access($operation, $year = NULL, $holiday_id = NULL, $user_id = NULL) {
  if (!is_string($operation)) {
    cf_error::invalid_integer('operation');
    return FALSE;
  }

  if (!is_null($year) && !cf_is_integer($year)) {
    cf_error::invalid_integer('year');
    return FALSE;
  }

  if (!is_null($holiday_id) && !cf_is_integer($holiday_id)) {
    cf_error::invalid_integer('holiday_id');
    return FALSE;
  }

  if (is_null($user_id)) {
    $user = cf_current_user();
  }
  else {
    $user = user_load($user_id);
  }

  if (!is_object($user)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  // must be a requester to gain any access.
  $is_requester = user_access('mfcs request', $user);
  if (!$is_requester) {
    return FALSE;
  }

  $is_manager = user_access('mfcs manage', $user);
  $is_administer = user_access('mfcs administer', $user);

  $is_power = FALSE;
  if ($is_manager || $is_administer) {
    $is_power = TRUE;
  }

  $enabled = FALSE;
  $check_year = FALSE;
  switch ($operation) {
    case 'view':
    case 'manage':
      if (is_null($holiday_id)) {
        // all users can view holidays and holiday management page.
        return TRUE;
      }

      if (!$is_power) {
        $enabled = TRUE;
      }

      break;
    case 'create':
    case 'edit':
    case 'delete':
      // only certain roles will ever be allowed to manage, add, edit, or delete.
      if (!($is_manager || $is_administer)) {
        return FALSE;
      }

      if (!is_null($year)) {
        $check_year = TRUE;
      }

      break;
    default:
      // not a valid operation.
      return FALSE;
  }

  if ($check_year) {
    $instance = mfcs_instance();
    $current_year = date('Y', $instance);

    if ($year < $current_year) {
      return FALSE;
    }
  }

  if (!is_null($holiday_id)) {
    try {
      $query = db_select('mfcs_holiday', 'mh');
      $query->addField('mh', 'id', 'id');

      if (!is_null($holiday_id)) {
        $query->condition('id', $holiday_id);
      }

      if ($enabled) {
        $query->condition('enabled', 1);
      }

      if (!is_null($year)) {
        $query->condition('year', $year, '>=');
      }

      // prohibit access to soft-deleted rows.
      $query->condition('deleted', 0);

      $results = $query->execute()->fetchAll();
      if (empty($results)) {
        return FALSE;
      }

      return TRUE;
    }
    catch (Error $e) {
      cf_error::on_query_execution($e);

      return FALSE;
    }
    catch (Exception $e) {
      cf_error::on_query_execution($e);

      return FALSE;
    }
  }

  // managers and adminsiters are allowed access even if they are not the coordinator.
  if ($is_manager || $is_administer) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Access callback for facilities use unavailability related operations.
 *
 * This is a simple access check and is not cached like the other access checks.
 *
 * @param string $operation
 *   The operation to check access against.
 * @param int|null $year
 *   (optional) When not NULL, the current year is checked.
 *   Years in the past are denied access, depending on operation.
 * @param int|null $room_id
 *   (optional) When NULL, access to unavailability management page is checked.
 *   When not NULL, access to a specific room id is checked.
 * @param int|null $availability_id
 *   (optional) When NULL, this is ignored.
 *   When not NULL, access to a specific unavailability id is checked.
 * @param int|null $user_id
 *   (optional) When NULL, the id of the current user is used.
 *   When not NULL, the provided user id is used.
 *
 * @param return bool
 *   TRUE on granted, FALSE otherwise.
 */
function mfcs_unavailability_request_access($operation, $year = NULL, $room_id = NULL, $availability_id = NULL, $user_id = NULL) {
  if (!is_string($operation)) {
    cf_error::invalid_integer('operation');
    return FALSE;
  }

  if (!is_null($year) && !cf_is_integer($year)) {
    cf_error::invalid_integer('year');
    return FALSE;
  }

  if (!is_null($room_id) && !cf_is_integer($room_id)) {
    cf_error::invalid_integer('room_id');
    return FALSE;
  }

  if (!is_null($availability_id) && !cf_is_integer($availability_id)) {
    cf_error::invalid_integer('availability_id');
    return FALSE;
  }

  if (is_null($user_id)) {
    $user = cf_current_user();
  }
  else {
    $user = user_load($user_id);
  }

  if (!is_object($user)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  // must be a requester to gain any access.
  $is_requester = user_access('mfcs request', $user);
  if (!$is_requester) {
    return FALSE;
  }

  $is_manager = user_access('mfcs manage', $user);
  $is_administer = user_access('mfcs administer', $user);
  $is_reviewer = user_access('mfcs review', $user);

  $is_coordinator_or_proxy_or_power = FALSE;
  if ($is_manager || $is_administer) {
    $is_coordinator_or_proxy_or_power = TRUE;
  }
  elseif ($is_reviewer) {
    // reviewers must have venue coordinator or venue coordinator proxy access for the room to be able to access this.
    $proxy_as = mfcs_get_proxy_venue_coordinator($user->uid);
    if (!is_array($proxy_as)) {
      $proxy_as = array();
    }
    $proxy_as[$user->uid] = (int) $user->uid;

    $room_coordinators = mfcs_load_room_coordinators($room_id, TRUE);
    if (is_array($room_coordinators)) {
      foreach ($room_coordinators as $room_coordinator) {
        if (array_key_exists($room_coordinator, $proxy_as)) {
          $is_coordinator_or_proxy_or_power = TRUE;
          break;
        }
      }
    }
  }

  $enabled = FALSE;
  $check_year = FALSE;
  switch ($operation) {
    case 'manage':
    case 'view':
      if (is_null($availability_id)) {
        // all users can view unavailabilities and unavailability management page.
        return TRUE;
      }

      if (!$is_coordinator_or_proxy_or_power) {
        $enabled = TRUE;
      }

      break;
    case 'create':
    case 'edit':
    case 'delete':
      // only certain roles will ever be allowed to add, edit, or delete.
      if (!$is_coordinator_or_proxy_or_power) {
        return FALSE;
      }

      if (!is_null($year)) {
        $check_year = TRUE;
      }

      break;
    default:
      // not a valid operation.
      return FALSE;
  }

  if ($check_year) {
    $instance = mfcs_instance();
    $current_year = date('Y', $instance);

    if ($year < $current_year) {
      return FALSE;
    }
  }

  if (!is_null($availability_id)) {
    try {
      $query = db_select('mfcs_unavailability', 'mu');
      $query->addField('mu', 'id', 'id');

      if (!is_null($availability_id)) {
        $query->condition('id', $availability_id);
      }

      if (!is_null($year)) {
        $query->condition('year', $year);
      }

      if ($enabled) {
        $query->condition('enabled', 1);
      }

      // prohibit access to soft-deleted rows.
      $query->condition('deleted', 0);

      $results = $query->execute()->fetchAll();
      if (empty($results)) {
        return FALSE;
      }
    }
    catch (Error $e) {
      cf_error::on_query_execution($e);

      return FALSE;
    }
    catch (Exception $e) {
      cf_error::on_query_execution($e);

      return FALSE;
    }
  }

  // this restriction happens only during the view operation in which all requesters are alllowed access.
  if ($enabled) {
    return TRUE;
  }

  // managers and adminsiters are allowed access even if they are not the coordinator.
  if ($is_manager || $is_administer) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Check access for already loaded facilities use requests.
 *
 * This is used to reduce database calls for when a request is already loaded.
 * If the request has not yet been loaded, either load it or directly call
 * mfcs_page_request_access() for access checks.
 *
 * This static caches the results in 'mfcs_request_access_static'.
 *
 * @param string $operation
 *   Operation to perform access check against.
 * @param array $request
 *   An already loaded request array to perform access checks against.
 * @param object $user
 *   (optional) The user object to obtain access for.
 * @param string $section
 *   (optional) Check whether or not the user is allowed to perform a certain
 *   operation for a specific section. This is primarily used for the edit
 *   pages.
 *
 * @param bool
 *   TRUE on access granted, FALSE otherwise.
 *
 * @see: mfcs_page_request_access()
 */
function mfcs_request_access($operation, $request, $user = NULL, $section = NULL) {
  if (!is_string($operation)) {
    cf_error::invalid_string('operation');
    return FALSE;
  }

  if (!is_array($request)) {
    cf_error::invalid_array('request');
    return FALSE;
  }

  if (is_null($user) || !is_object($user)) {
    $user = cf_current_user();
  }

  // anonymous user is denied access to requests as a whole.
  if ($user->uid == 0) {
    return FALSE;
  }

  global $conf;


  // use advanced static cache for increased performance.
  static $mfcs_request_access_static;

  if (!isset($mfcs_request_access_static)) {
    $mfcs_request_access_static[$operation] = &drupal_static('mfcs_request_access');
  }

  if (!isset($mfcs_request_access_static[$operation][$section][$user->uid])) {
    $mfcs_request_access_static[$operation][$section][$user->uid] = array();
  }

  $access = &$mfcs_request_access_static[$operation][$section][$user->uid];

  if (empty($request['mer']['id'][0]->value)) {
    return FALSE;
  }
  $request_id = $request['mer']['id'][0]->value;

  if (array_key_exists($request_id, $access)) {
    return $access[$request_id];
  }

  if (!isset($request['top']['status'][0]->value) || !isset($request['top']['step'][0]->value)) {
    $access[$request_id] = FALSE;
    return FALSE;
  }

  $request_status = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_UNLOCKED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    MFCS_REQUEST_STATUS_CLOSED_DENIED,
    MFCS_REQUEST_STATUS_CLOSED_UNAVAILABLE,
    MFCS_REQUEST_STATUS_CLOSED_DUE_TO_LOCK,
    MFCS_REQUEST_STATUS_CANCELLED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED,
  );

  $roles = array(
    'manager' => user_access('mfcs manage', $user),
    'reviewer' => user_access('mfcs review', $user),
    'requester' => user_access('mfcs request', $user),
    'administer' => user_access('mfcs administer', $user),

    // @fixme: these roles are hardcoded, implement a more dynamic approach.
    'role_student' => array_search('student role', $user->roles),
    'role_camp' => array_search('camp role', $user->roles),
    'role_employee' => array_search('employee role', $user->roles),
    'role_external' => array_search('external role', $user->roles),
    'bannerless_exception' => array_search('bannerless exception', $user->roles),
    'reviewer_exception' => array_search('reviewer exception', $user->roles),
  );

  // Access will only be granted to administrators, managers, reviewers, and requesters.
  if (!$roles['administer'] && !$roles['manager'] && !$roles['reviewer'] && !$roles['requester']) {
    return FALSE;
  }

  // Deny access to requesters and reviewers who do not have a student, camp, employee, or external role.
  if (!$roles['administer'] && !$roles['manager']) {
    if (($roles['reviewer'] || $roles['requester']) && !$roles['role_student'] && !$roles['role_camp'] && !$roles['role_employee'] && !$roles['role_external']) {
      return FALSE;
    }
  }

  $proxies = mfcs_get_proxy_venue_coordinator($user->uid);
  $venue_coordinator_ids = array();
  if (!empty($proxies)) {
    $venue_coordinator_ids = $proxies;
  }
  $venue_coordinator_ids[$user->uid] = $user->uid;

  if ($operation == 'create') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // create operations on a specific request is actually a clone/copy operation, which only needs view access to clone/copy.
    $access[$request_id] = mfcs_request_access('view', $request, $user);
    return $access[$request_id];
  }
  elseif ($operation == 'edit') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $edit_request_status = array(
      MFCS_REQUEST_STATUS_UNLOCKED,
      MFCS_REQUEST_STATUS_LOCKED,
    );

    // when quick meeting is enabled, a section is not null, then additional checks are required.
    if (!is_null($request_id) && !is_null($section) && ($roles['manager'] || $roles['requester'] || $roles['reviewer'] || $roles['administer'])) {
      if (isset($request['information']['type'][0]->value) && $request['information']['type'][0]->value == MFCS_REQUEST_TYPE_QUICK_MEETING) {
        // deny access to sections that are not allowed to be edited for a quick meeting.
        $allowed_sections_quick_meeting = array(
          'request',
          'information',
          'coordinator',
          'dates',
        );

        if (!in_array($section, $allowed_sections_quick_meeting)) {
          return FALSE;
        }
      }
    }

    if (!in_array($request['top']['status'][0]->value, $edit_request_status)) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($roles['manager'] || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
    elseif ($roles['requester'] || $roles['reviewer']) {
      if ($roles['requester']) {
        if (isset($request['mer']['user_id'][0]->value) && $request['mer']['user_id'][0]->value == $user->uid) {
          $access[$request_id] = TRUE;
          return TRUE;
        }
      }

      if ($roles['reviewer']) {
        if (isset($request['venue_coordinator']['user_id'][0]->value) && $request['venue_coordinator']['user_id'][0]->value == $user->uid) {
          $access[$request_id] = TRUE;
          return TRUE;
        }
      }

      $access[$request_id] = FALSE;
      return FALSE;
    }
  }
  elseif ($operation == 'view') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($roles['manager'] || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
    elseif ($roles['reviewer']) {
      // due to its complexity, the database calling function for reviewer access will be used.
      $review_access = mfcs_page_request_reviewer_access($user, $request_id, MFCS_REVIEW_RESTRICTION_VIEW);

      if (is_array($review_access) && array_key_exists($request_id, $review_access)) {
        $access[$request_id] = $review_access[$request_id];
        return $review_access[$request_id];
      }
    }
    elseif ($roles['requester']) {
      if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_CLOSED_ACCEPTED && $request['top']['step'][0]->value == MFCS_REVIEW_STEP_COMPLETED) {
        // always show completed and accepted requests when there are no restrictions
        $access[$request_id] = TRUE;
        return TRUE;
      }
      elseif (in_array($request['top']['status'][0]->value, $request_status)) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'review') {
    if (!$roles['reviewer']) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // managers adn administers are always allowed to review.
    if ($roles['manager'] || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }

    // due to its complexity, the database calling function for reviewer access will be used.
    $review_access = mfcs_page_request_reviewer_access($user, $request_id, MFCS_REVIEW_RESTRICTION_REVIEW);

    if (is_array($review_access) && array_key_exists($request_id, $review_access)) {
      $access[$request_id] = $review_access[$request_id];
      return $review_access[$request_id];
    }
  }
  elseif ($operation == 'comment') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // managers and administration should always be able to comment.
    if ($roles['manager'] || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
    elseif ($roles['requester'] && $request['mer']['user_id'][0]->value == $user->uid) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
    elseif ($roles['reviewer']) {
      // due to its complexity, the database calling function for reviewer access will be used.
      $comment_access = mfcs_page_request_reviewer_access($user, $request_id, MFCS_REVIEW_RESTRICTION_COMMENT);

      if (is_array($comment_access) && array_key_exists($request_id, $comment_access)) {
        $access[$request_id] = $comment_access[$request_id];
        return $comment_access[$request_id];
      }
    }
    else {
      $access[$request_id] = FALSE;
      return FALSE;
    }
  }
  elseif ($operation == 'log') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($roles['manager'] || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
    elseif ($roles['requester'] && $request['mer']['user_id'][0]->value == $user->uid) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
    elseif ($roles['reviewer']) {
      // due to its complexity, the database calling function for reviewer access will be used.
      $log_access = mfcs_page_request_reviewer_access($user, $request_id, MFCS_REVIEW_RESTRICTION_VIEW);

      if (is_array($log_access) && array_key_exists($request_id, $log_access)) {
        $access[$request_id] = $log_access[$request_id];
        return $log_access[$request_id];
      }
    }
  }
  elseif ($operation == 'delete') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($operation == 'delete') {
      if ($roles['administer']) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'cancel') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $not_cancellable_status = array(
      MFCS_REQUEST_STATUS_DELETED,
      MFCS_REQUEST_STATUS_CANCELLED,
      MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED,
      MFCS_REQUEST_STATUS_CLOSED_DENIED,
      MFCS_REQUEST_STATUS_CLOSED_UNAVAILABLE,
    );

    // no matter who the user is, if the request has one of these status', then do not allow cancelling.
    if (in_array($request['top']['status'][0]->value, $not_cancellable_status)) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($roles['manager'] || array_key_exists($request['venue_coordinator']['user_id'][0]->value, $venue_coordinator_ids) || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }

    if ($roles['requester'] && $request['mer']['user_id'][0]->value == $user->uid) {
      $cancellable_status = array(
        MFCS_REQUEST_STATUS_UNLOCKED,
        MFCS_REQUEST_STATUS_LOCKED,
        MFCS_REQUEST_STATUS_CLOSED_DUE_TO_LOCK,
        MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
      );

      if (in_array($request['top']['status'][0]->value, $cancellable_status)) {
        $access[$request_id] = TRUE;
        return TRUE;
      }

      $access[$request_id] = FALSE;
      return FALSE;
    }
  }
  elseif ($operation == 'uncancel') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $uncancellable_status = array(
      MFCS_REQUEST_STATUS_CANCELLED,
      MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED,
    );

    if (!in_array($request['top']['status'][0]->value, $uncancellable_status)) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // managers, venue coordinators, and administers can uncancel an request at any point in the process.
    if ($roles['manager'] || array_key_exists($request['venue_coordinator']['user_id'][0]->value, $venue_coordinator_ids) || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'cancelling') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // no matter who the user is, if the request has is not accepted and completed, then cancelling functionality is unneeded and not allowed.
    if ($request['top']['status'][0]->value != MFCS_REQUEST_STATUS_CLOSED_ACCEPTED || $request['top']['step'][0]->value != MFCS_REVIEW_STEP_COMPLETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // support manually disabling of accounts based on specific roles.
    $disable_cancelling_for = array();
    if (isset($conf['disable_cancelling_for']) && is_array($conf['disable_cancelling_for'])) {
      $disable_cancelling_for = $conf['disable_cancelling_for'];
    }

    if (!isset($disable_cancelling_for['reviewer']) || !is_bool($disable_cancelling_for['reviewer'])) {
      $disable_cancelling_for['reviewer'] = FALSE;
    }

    if (!isset($disable_cancelling_for['requester']) || !is_bool($disable_cancelling_for['requester'])) {
      $disable_cancelling_for['requester'] = FALSE;
    }

    // must be either an administer, a manager, a venue coordinator, or a requester for the specific request to perform cancelling.
    if ($roles['manager'] || $roles['administer']) {
      // no restrictions applied.
    }
    elseif ($roles['reviewer']) {
      if (!array_key_exists($request['venue_coordinator']['user_id'][0]->value, $venue_coordinator_ids) || $disable_cancelling_for['reviewer']) {
        // also check for requester access.
        if (!$roles['requester'] || $request['mer']['user_id'][0]->value != $user->uid || $disable_cancelling_for['requester']) {
          $access[$request_id] = FALSE;
          return FALSE;
        }
      }
    }
    elseif ($roles['requester']) {
      if ($request['mer']['user_id'][0]->value != $user->uid || $disable_cancelling_for['requester']) {
        $access[$request_id] = FALSE;
        return FALSE;
      }
    }
    else {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $instance = mfcs_instance();
    foreach ($request['dates']['date'] as $key => $date) {
      // if a single date (all day, or date and time) is in the future, then cancelling is allowed.
      if ($date->value > $instance) {
        $access[$request_id] = TRUE;
        return TRUE;
      }

      if (isset($request['dates']['time_start'][$key]->value) && !is_null($request['dates']['time_start'][$key]->value) && $request['dates']['time_start'][$key]->value > $instance) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
  }
  elseif ($operation == 'manage') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // only managers and administers are allowed to override the status of a request.
    if ($roles['manager'] || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'override') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    // only managers and administers are allowed to override the status of a request.
    if ($roles['manager'] || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'reassign') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $reassignable_status = array(
      MFCS_REQUEST_STATUS_LOCKED,
      MFCS_REQUEST_STATUS_UNLOCKED,
    );

    // no matter who the user is, if the request is not one of these status', then do not allow re-assignment.
    if (!in_array($request['top']['status'][0]->value, $reassignable_status)) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($roles['manager'] || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'history') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED && !$roles['administer']) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    if ($roles['manager'] || $roles['administer']) {
      $access[$request_id] = TRUE;
      return TRUE;
    }
  }
  elseif ($operation == 'agreement') {
    if ($request['top']['status'][0]->value == MFCS_REQUEST_STATUS_DELETED) {
      $access[$request_id] = FALSE;
      return FALSE;
    }

    $agreement_request_status = array(
      MFCS_REQUEST_STATUS_LOCKED,
      MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
      MFCS_REQUEST_STATUS_CLOSED_DENIED,
      MFCS_REQUEST_STATUS_CANCELLED,
      MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED,
    );

    if ($roles['manager'] || $roles['reviewer'] || $roles['administer']) {
      $agreement_request_step = array(
        MFCS_REVIEW_STEP_COMPLETED,
        MFCS_REVIEW_STEP_REVIEW,
        MFCS_REVIEW_STEP_REQUIREMENTS,
      );

      if (in_array($request['top']['status'][0]->value, $agreement_request_status) && in_array($request['top']['step'][0]->value, $agreement_request_step)) {
        $access[$request_id] = TRUE;
        return TRUE;
      }
    }
    else {
      $agreement_request_step = array(
        MFCS_REVIEW_STEP_COMPLETED,
      );

      if (in_array($request['top']['status'][0]->value, $agreement_request_status) && in_array($request['top']['step'][0]->value, $agreement_request_step)) {
        // the submitter should be the only non-manager/non-reviewer that can access the agreement.
        if ($request['mer']['user_id'][0]->value == $user->uid) {
          $access[$request_id] = TRUE;
          return TRUE;
        }
      }
    }
  }

  $access[$request_id] = FALSE;
  return FALSE;
}

/**
 * Check to see if a given user is allowed to review a given request.
 *
 * @param object $user
 *   User to check if is a valid reviewer of the given request.
 * @param int|array $request_id
 *   ID of the request to check review access for.
 *   This can be an array of request ids.
 *   Using multiple ids can improve performance instead of doing a check
 *   against each individual request id.
 * @param int $review_restrictions
 *   The review restrictions to use.
 *
 * @return bool|array
 *   An array of access grants by access id, FALSE otherwise.
 */
function mfcs_page_request_reviewer_access($user, $request_id, $review_restrictions) {
  if (!is_object($user)) {
    cf_error::invalid_object('user');
    return FALSE;
  }

  if (!cf_is_integer($request_id)) {
    if (!is_array($request_id) || empty($request_id)) {
      cf_error::invalid_integer('request_id');
      return FALSE;
    }
  }

  if (!cf_is_integer($review_restrictions)) {
    cf_error::invalid_integer('review_restrictions');
    return FALSE;
  }

  // managers get special review access.
  $manager = user_access('mfcs manage', $user);

  $request_ids = $request_id;
  if (!is_array($request_id)) {
    $request_ids = array($request_id);
  }

  $access = array();
  foreach ($request_ids as $id) {
    $access[$id] = FALSE;
  }

  $show_status_venue_coordinator = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_UNLOCKED,
  );

  $show_step_venue_coordinator = array(
    MFCS_REVIEW_STEP_VENUE_AVAILABLE,
  );

  // if the reviewer is associated with the requests classification, then allow access when in these statuses.
  $show_status_reviewer = array(
    MFCS_REQUEST_STATUS_UNLOCKED,
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    MFCS_REQUEST_STATUS_CLOSED_DENIED,
    MFCS_REQUEST_STATUS_CLOSED_UNAVAILABLE,
    MFCS_REQUEST_STATUS_CLOSED_DUE_TO_LOCK,
    MFCS_REQUEST_STATUS_CANCELLED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED,
  );

  // if the reviewer is associated with the requests and the request is in one of these status, then the reviewer can review.
  $show_status_reviewer_review = array(
    MFCS_REQUEST_STATUS_LOCKED,
  );

  // allow comments when the request is assigned any of these status codes.
  $show_status_comments_allowed = array(
    MFCS_REQUEST_STATUS_UNLOCKED,
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    MFCS_REQUEST_STATUS_CLOSED_DENIED,
    MFCS_REQUEST_STATUS_CLOSED_UNAVAILABLE,
    MFCS_REQUEST_STATUS_CLOSED_DUE_TO_LOCK,
    MFCS_REQUEST_STATUS_CANCELLED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED,
  );

  $show_step_reviewer = array(
    MFCS_REVIEW_STEP_REVIEW,
    MFCS_REVIEW_STEP_REQUIREMENTS,
  );

  $show_step_manager = array(
    MFCS_REVIEW_STEP_VENUE_AVAILABLE,
    MFCS_REVIEW_STEP_REVIEW,
    MFCS_REVIEW_STEP_REQUIREMENTS,
  );

  $show_step_insurance = array(
    MFCS_REVIEW_STEP_REVIEW,
    MFCS_REVIEW_STEP_REQUIREMENTS,
    MFCS_REVIEW_STEP_COMPLETED,
  );

  $show_status_insurance = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED,
  );

  $proxies = mfcs_get_proxy_venue_coordinator($user->uid);
  $venue_coordinator_ids = array();
  if (!empty($proxies)) {
    $venue_coordinator_ids = $proxies;
  }
  $venue_coordinator_ids[$user->uid] = $user->uid;

  $reviewer_settings = mfcs_get_reviewer_settings_by_user_id($user->uid);

  try {
    $query = db_select('mfcs_requests', 'mer');

    $query->addField('mer', 'id', 'id');

    $query->condition('mer.id', array($request_ids), 'IN');
    $query->condition('mer.status', MFCS_REQUEST_STATUS_DELETED, '<>');

    $or = null;

    if ($review_restrictions == MFCS_REVIEW_RESTRICTION_REVIEW) {
      if ($manager) {
        // Manager is allowed both venue coordinator and reviewer step review access.
        $query->condition('mer.step', $show_step_manager, 'IN');
        $query->condition('mer.status', $show_status_reviewer, 'IN');
      }
      else {
        if (is_null($or)) {
          $or = db_or();
        }

        // process venue coordinator access.
        $already_venue_coordinated_query = db_select('mfcs_reviewed', 'mrd_vc');
        $already_venue_coordinated_query->addField('mrd_vc', 'request_id', 'request_id');
        $already_venue_coordinated_query->where('mrd_vc.request_id = mer.id');
        $already_venue_coordinated_query->condition('mrd_vc.classification', MFCS_REVIEWER_CLASSIFICATION_VENUE_COORDINATOR);

        $and = db_and();
        $and->condition('mer.status', $show_status_venue_coordinator, 'IN');
        $and->condition('mer.step', $show_step_venue_coordinator, 'IN');
        $and->condition('mer.id', $already_venue_coordinated_query, 'NOT IN');
        $and->condition('mer.venue_coordinator', $venue_coordinator_ids, 'IN');

        $or->condition($and);

        // process review access.
        if (empty($reviewer_settings['classifications'])) {
          // if the 'reviewer' has no reviewer classifications, then they cannot review, remove all requests associated with reviewer steps.
          $query->condition('mer.step', $show_step_reviewer, 'NOT IN');
        }
        else {
          $and = db_and();
          $and->condition('mer.status', $show_status_reviewer_review, 'IN');
          $and->condition('mer.step', $show_step_reviewer, 'IN');

          // check each and every single reviewer classification separately.
          // while this is more expensive, this allows for reviewing when some (but not all) of the classifications have not yet reviewed.
          // example:
          // - user 1, with roles A, B and C, has reviewed request Z.
          // - user 2, with roles B, C, and D, wants to review request Z.
          // - user 2 should still be allowed to review as D, but not as B or C.
          $reviewed_or = db_or();
          foreach ($reviewer_settings['classifications'] as $reviewer_classification) {
            $already_reviewed_query = db_select('mfcs_reviewers', 'mr_r');
            $already_reviewed_query->innerJoin('mfcs_reviewed', 'mrd_r', 'mr_r.reviewer_classification = mrd_r.classification');
            $already_reviewed_query->addField('mrd_r', 'request_id', 'request_id');
            $already_reviewed_query->where('mr_r.request_classification = mer.classification AND mr_r.review_step = mer.step');
            $already_reviewed_query->condition('mr_r.user_id', $user->uid);
            $already_reviewed_query->condition('mr_r.disabled', 0);
            $already_reviewed_query->condition('mrd_r.classification', $reviewer_classification);
            $reviewed_or->condition('mer.id', $already_reviewed_query, 'NOT IN');
            unset($already_reviewed_query);
          }
          $and->condition($reviewed_or);
          unset($reviewed_or);

          $sub_or = db_or();
          foreach ($reviewer_settings['for_step'] as $for_step => $step_classifications) {
            $sub_and = db_and();
            $sub_and->condition('mer.step', $for_step);
            $sub_and->condition('mer.classification', $step_classifications, 'IN');

            $sub_or->condition($sub_and);
            unset($sub_and);
          }

          $and->condition($sub_or);
          $or->condition($and);

          // special case reviewer access: insurance provided
          if (array_key_exists(MFCS_REVIEWER_CLASSIFICATION_PURCHASING, $reviewer_settings['request_classifications'])) {
            $has_insurance_query = db_select('mfcs_current', 'mc');
            $has_insurance_query->leftJoin('mfcs_field_insurance_contractor', 'mfic', 'mc.request_id = mfic.request_id AND mc.insurance_contractor = mfic.revision AND mfic.delta = 0');
            $has_insurance_query->leftJoin('mfcs_field_insurance_unaffiliated', 'mfiu', 'mc.request_id = mfiu.request_id AND mc.insurance_unaffiliated = mfiu.revision AND mfiu.delta = 0');
            $has_insurance_query->leftJoin('mfcs_field_insurance_provided', 'mfip', 'mc.request_id = mfip.request_id AND mc.insurance_provided = mfip.revision AND mfip.delta = 0');

            // $query->countQuery() does not appear to be functioning as expected, so manually count.
            $has_insurance_query->addExpression('count(mc.request_id)');

            $has_insurance_query->where('mer.id = mc.request_id');

            $nand = db_and();
            $nand->not();
            $nand->condition('mfip.value', 1);
            $has_insurance_query->condition($nand);

            $another_or = db_or();
            $another_or->condition('mfic.value', 1);
            $another_or->condition('mfiu.value', 1);
            $has_insurance_query->condition($another_or);

            $and = db_and();
            $and->condition('mer.status', $show_status_insurance, 'IN');
            $and->condition('mer.step', $show_step_insurance, 'IN');
            $and->condition(0, $has_insurance_query, 'NOT IN');

            $or->condition($and);
          }
        }
      }
    }
    elseif ($review_restrictions == MFCS_REVIEW_RESTRICTION_VIEW) {
      if (is_null($or)) {
        $or = db_or();
      }

      // always show accepted requests.
      $or->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);

      // accepted but cancelled requests need to be visible for telling clients that the request was cancelled.
      $or->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED);

      // always allow venue coordinator access. to view.
      $or->condition('mer.venue_coordinator', $venue_coordinator_ids, 'IN');

      // allow reviewer access to view if they are allowed to review the request at some point.
      if (!empty($reviewer_settings['request_classifications'])) {
        $and = db_and();
        $and->condition('mer.classification', $reviewer_settings['request_classifications'], 'IN');
        $and->condition('mer.status', $show_status_reviewer, 'IN');

        $or->condition($and);
      }
    }
    elseif ($review_restrictions == MFCS_REVIEW_RESTRICTION_COMMENT) {
      if (is_null($or)) {
        $or = db_or();
      }

      // allow venue coordinator for the request access to comment.
      $or->condition('mer.venue_coordinator', $venue_coordinator_ids, 'IN');

      // allow requester for the request access to comment.
      $or->condition('mer.user_id', $user->uid);


      // allow reviewer access to comment if they are allowed to review the request at some point.
      if (!empty($reviewer_settings['request_classifications'])) {
        $or->condition('mer.classification', $reviewer_settings['request_classifications'], 'IN');
      }
    }
    elseif ($review_restrictions == MFCS_REVIEW_RESTRICTION_NONE) {
      if (is_null($or)) {
        $or = db_or();
      }

      // always show completed and accepted requests when there are no restrictions.
      $or->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);

      // accepted but cancelled requests need to be visible for telling clients that the request was cancelled.
      $or->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED);

      // always allow venue coordinator access.
      $or->condition('mer.venue_coordinator', $venue_coordinator_ids, 'IN');

      // allow reviewer access if they are allowed to review the request at some point.
      if (!empty($reviewer_settings['request_classifications'])) {
        $and = db_and();
        $and->condition('mer.classification', $reviewer_settings['request_classifications'], 'IN');
        $and->condition('mer.status', $show_status_comments_allowed, 'IN');

        $or->condition($and);
      }
    }
    else {
      // no access should be allowed for unknown review_restrictions.
      return $access;
    }

    if (!is_null($or)) {
      $query->condition($or);
    }

    $results = $query->execute()->fetchAllAssoc('id');
    if (!is_array($results)) {
      return $access;
    }

    foreach ($access as $id => $value) {
      $access[$id] = array_key_exists($id, $results);
    }

    return $access;
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return $access;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return $access;
  }

  return $access;
}

/**
 * Access callback for facilities use management page.
 *
 * @param bool
 *   TRUE on access granted, FALSE otherwise.
 */
function mfcs_dashboard_page_access() {
  if (user_access('mfcs administer') || user_access('mfcs request') || user_access('mfcs review') || user_access('mfcs manage')) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Access callback for facilities use management page.
 *
 * @param bool
 *   TRUE on access granted, FALSE otherwise.
 */
function mfcs_management_page_access() {
  if (user_access('mfcs request') || user_access('mfcs review') || user_access('mfcs manage') || user_access('mfcs administer')) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_cronapi().
 */
function mfcs_cronapi() {
  mfcs_include(MFCS_INCLUDE_HOOKS);

  return mfcs_hook_cronapi();
}

/**
 * Implements hook_mail().
 */
function mfcs_mail($key, &$message, $params) {
  global $base_url;

  $subject = '';
  $body = '';
  $markup = '';

  if ($key == 'request_alert') {
    $instance = mfcs_instance();

    if (!empty($params['title_prefix'])) {
      $subject .= $params['title_prefix'];
    }

    $subject .= 'Facilities Use Request: ' . $params['request_id'] . ' - ' . $params['request_title'];

    if (!empty($params['title_suffix'])) {
      $subject .= ' - ' . $params['title_suffix'];
    }

    $request_url = $base_url . '/requests/view-0/' . $params['request_id'];

    if (!empty($params['content'])) {
      $body .= $params['content'] . "\n";
    }

    $body .= "\n";
    $body .= "Request URL:\n - " . $request_url . "\n\n";

    $body .= "\n";
    $body .= "This e-mail was generated on:\n - " . date("Y/m/d h:i:s a T", $instance) . "\n";


    if (isset($params['markup'])) {
      $markup .= $params['markup'];

      $markup .= '<br>';
      $markup .= "<strong>Request URL</strong>:<ul><li><a href=" . '"' . $request_url . '"' . ">" . $request_url . "</a></li></ul><br>";

      $markup .= '<br>';
      $markup .= "<em>This e-mail was generated on</em>:<ul><li><em>" . date("Y/m/d h:i:s a T", $instance) . "</em></li></ul>";
    }
  }
  else {
    return;
  }

  $message['subject'] = substr($subject, 0, MFCS_EMAIL_MAX_SUBJECT_LENGTH);
  $message['body'] = array($body);
  $message['markup'] = isset($params['markup']) ? array($markup) : array();
  $message['from_address'] = isset($params['from']) ? $params['from'] : $message['from'];

  if (!empty($params['files'])) {
    $message['files'] = $params['files'];
  }

  // assign message priority.
  if (isset($params['message_priority'])) {
    if ($params['message_priority'] == MFCS_MAIL_PRIORITY_HIGHEST) {
      $message['headers']['X-Priority'] = '1 (Highest)';
      $message['headers']['Importance'] = 'high';
    }
    elseif ($params['message_priority'] == MFCS_MAIL_PRIORITY_HIGH) {
      $message['headers']['X-Priority'] = '2 (High)';
      $message['headers']['Importance'] = 'high';
    }
    elseif ($params['message_priority'] == MFCS_MAIL_PRIORITY_NORMAL) {
      // @todo: should low be manually specified, such as: 3 (normal) ?
    }
    elseif ($params['message_priority'] == MFCS_MAIL_PRIORITY_LOW) {
      $message['headers']['X-Priority'] = '4 (Low)';
      $message['headers']['Importance'] = 'low';
    }
    elseif ($params['message_priority'] == MFCS_MAIL_PRIORITY_LOWEST) {
      $message['headers']['X-Priority'] = '5 (Lowest)';
      $message['headers']['Importance'] = 'low';
    }
  }
}

/**
 * Helper function to load files related to this project.
 *
 * @param int $id
 *   The number associated with the file to include.
 */
function mfcs_include($id) {
  if (!is_numeric($id)) {
    cf_error::invalid_number('id');
    return;
  }

  $module_path = drupal_get_path('module', 'mfcs');

  if ($id == MFCS_INCLUDE_TABLE) {
    require_once($module_path . '/includes/table.inc');
  }
  elseif ($id == MFCS_INCLUDE_STRUCTURE) {
    require_once($module_path . '/includes/structure.inc');
  }
  elseif ($id == MFCS_INCLUDE_VALIDATION) {
    require_once($module_path . '/includes/validation.inc');
  }
  elseif ($id == MFCS_INCLUDE_AUTOCOMPLETE) {
    require_once($module_path . '/includes/autocomplete.inc');
  }
  elseif ($id == MFCS_INCLUDE_LIST_OPTIONS) {
    require_once($module_path . '/includes/list_options.inc');
  }
  elseif ($id == MFCS_INCLUDE_WORKFLOW) {
    require_once($module_path . '/includes/workflow.inc');
  }
  elseif ($id == MFCS_INCLUDE_HOOKS) {
    require_once($module_path . '/includes/hooks.inc');
  }
  elseif ($id == MFCS_INCLUDE_OUTPUT) {
    require_once($module_path . '/includes/output.inc');
  }
  elseif ($id == MFCS_INCLUDE_MISCELLANEOUS) {
    require_once($module_path . '/includes/miscellaneous.inc');
  }
  elseif ($id == MFCS_INCLUDE_ACCESS) {
    require_once($module_path . '/includes/access.inc');
  }
  elseif ($id == MFCS_INCLUDE_ICAL) {
    require_once($module_path . '/includes/ical.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_CANCEL) {
    require_once($module_path . '/pages/request_cancel.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_CREATE) {
    require_once($module_path . '/pages/request_create.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_ICAL) {
    require_once($module_path . '/pages/request_ical.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_LIST) {
    require_once($module_path . '/pages/request_list.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_OVERRIDE) {
    require_once($module_path . '/pages/request_override.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_REASSIGN) {
    require_once($module_path . '/pages/request_reassign.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_VIEW) {
    require_once($module_path . '/pages/request_view.inc');
  }
  elseif ($id == MFCS_INCLUDE_TESTING) {
    require_once($module_path . '/includes/testing.inc');
  }
  elseif ($id == MFCS_INCLUDE_VIEW) {
    require_once($module_path . '/includes/view.inc');
  }
  elseif ($id == MFCS_INCLUDE_MANAGEMENT) {
    require_once($module_path . '/includes/management.inc');
  }
  elseif ($id == MFCS_INCLUDE_REQUEST_USERS) {
    require_once($module_path . '/pages/request_users.inc');
  }
}

/**
 * Performs a select query.
 *
 * @param string $query
 *   A query string to process.
 * @param array $arguments
 *   (optional) An array of arguments
 *
 * @return array|bool
 *   An array containing the query results.
 *   FALSE is returned on error.
 */
function mfcs_oracle_select($query, $arguments = array()) {
  if (!is_string($query)) {
    cf_error::invalid_string('query');

    return FALSE;
  }

  if (!is_array($arguments)) {
    cf_error::invalid_array('arguments');

    return FALSE;
  }

  $results = array();
  $options = array();
  if (isset($arguments['options']) && is_array($arguments['options'])) {
    $options = $arguments['options'];
  }

  try {
    $conn = Database::getConnection('default', 'oracle');

    $results = (array) $conn->oracleQuery($query, $arguments, $options)->fetchAll();
  }
  catch (Error $e) {
    $silent = FALSE;
    if ($e->getCode() == 12170) {
      // Make an oracle connection error silent because the error presented is likely jibberish to the caller.
      $silent = TRUE;
    }

    cf_error::on_exception($e, WATCHDOG_ERROR, $silent);
    return FALSE;
  }
  catch (Exception $e) {
    $silent = FALSE;
    if ($e->getCode() == 12170) {
      // Make an oracle connection error silent because the error presented is likely jibberish to the caller.
      $silent = TRUE;
    }

    cf_error::on_exception($e, WATCHDOG_ERROR, $silent);
    return FALSE;
  }

  return $results;
}

/**
 * Returns a list of locations available.
 *
 * Note: ucs.msu_venue_list calls the building location 'category'.
 *
 * @param int|null $location
 *   (optional) When specified, load the location associated with the location id.
 * @param bool $disabled
 *   (optional) When TRUE, will also load the disabled rooms.
 *
 * @return array|object|bool
 *   An array of locations objects or a single location object.
 *   FALSE is returned on error.
 */
function mfcs_load_locations($location = NULL, $disabled = FALSE) {
  if (!is_null($location) && !cf_is_integer($location)) {
    cf_error::invalid_integer('location');
    return FALSE;
  }

  if (!is_bool($disabled)) {
    cf_error::invalid_bool('disabled');
    return FALSE;
  }

  $cache_id = __function__;

  if ($disabled) {
    $cache_id .= '_disabled';
  }

  $items = &drupal_static($cache_id, NULL);
  if (is_array($items)) {
    if (is_null($location)) {
      return $items;
    }

    if (array_key_exists($location, $items)) {
      return $items[$location];
    }
  }

  // don't override cached items.
  if (is_null($items)) {
    $items = array();
  }

  try {
    $query = db_select('mfcs_banner_locations', 'mbl');

    if (!$disabled) {
      $query->condition('mbl.disabled', 0);
    }

    $query->addField('mbl', 'id', 'location_id');
    $query->addField('mbl', 'human_name', 'location_name');

    if ($disabled) {
      $query->addField('mbl', 'disabled', 'disabled');
      $query->addField('mbl', 'date', 'date');
    }

    $query->orderBy('mbl.human_name');

    $results = $query->execute()->fetchAllAssoc('location_id');

    if (!empty($results)) {
      foreach ($results as $lid => $l) {
        $items[$lid] = $l;
      }
    }

    if (is_null($location)) {
      return $items;
    }

    if (array_key_exists($location, $items)) {
      return $items[$location];
    }
    else {
      $items[$location] = FALSE;
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }

  return FALSE;
}

/**
 * Returns a list of buildings available.
 *
 * Note: ucs.msu_venue_list calls the building location 'category'.
 *
 * @param int|null $location
 *   (optional) When specified, load buildings associated with the location id.
 * @param int|null $building
 *   (optional) When specified, load the building associated with the building id.
 * @param bool $disabled
 *   (optional) When TRUE, will also load the disabled rooms.
 *
* @return array|object|bool
 *   An array of building objects or a single building object.
 *   FALSE is returned on error.
 */
function mfcs_load_buildings($location = NULL, $building = NULL, $disabled = FALSE) {
  if (!is_null($location) && !cf_is_integer($location)) {
    cf_error::invalid_integer('location');
    return FALSE;
  }

  if (!is_null($building) && !cf_is_integer($building)) {
    cf_error::invalid_integer('building');
    return FALSE;
  }

  if (!is_bool($disabled)) {
    cf_error::invalid_bool('disabled');
    return FALSE;
  }

  $cache_id = __function__;

  if (!is_null($location)) {
    $cache_id .= '_' . $location;
  }

  if ($disabled) {
    $cache_id .= '_disabled';
  }

  $items = &drupal_static($cache_id, NULL);
  if (is_array($items)) {
    if (is_null($building)) {
      return $items;
    }

    if (array_key_exists($building, $items)) {
      return $items[$building];
    }
  }

  // don't override cached items.
  if (is_null($items)) {
    $items = array();
  }

  try {
    $query = db_select('mfcs_banner_buildings', 'mbb');

    if (!is_null($location)) {
      $query->innerJoin('mfcs_banner_building_to_location', 'mbbl', 'mbb.id = mbbl.building');
      $query->innerJoin('mfcs_banner_locations', 'mbl', 'mbbl.location = mbl.id');

      $query->condition('mbl.id', $location);

      $query->addField('mbl', 'id', 'location_id');
      $query->addField('mbl', 'machine_name', 'location_code');
      $query->addField('mbl', 'human_name', 'location_name');

      $query->orderBy('mbl.human_name');

      if (!$disabled) {
        $query->condition('mbl.disabled', 0);
      }
    }

    if (!$disabled) {
      $query->condition('mbb.disabled', 0);
    }

    $query->addField('mbb', 'id', 'building_id');
    $query->addField('mbb', 'machine_name', 'building_code');
    $query->addField('mbb', 'human_name', 'building_name');

    if ($disabled) {
      $query->addField('mbb', 'disabled', 'disabled');
      $query->addField('mbb', 'date', 'date');
    }

    $query->orderBy('mbb.human_name');

    $results = $query->execute()->fetchAllAssoc('building_id');

    if (!empty($results)) {
      foreach ($results as $bid => $b) {
        $items[$bid] = $b;
      }
    }

    if (is_null($building)) {
      return $items;
    }

    if (array_key_exists($building, $items)) {
      return $items[$building];
    }
    else {
      $items[$building] = FALSE;
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }

  return FALSE;
}

/**
 * Returns a list of rooms available.
 *
 * @param int|null $location
 *   (optional) When specified, load rooms associated with the location id.
 * @param int|null $building
 *   (optional) When specified, load rooms associated with the building id.
 * @param int|null $room
 *   (optional) When specified, load the room associated with the room id.
 * @param bool $disabled
 *   (optional) When TRUE, will also load the disabled rooms.
 *
 * @return array|object|bool
 *   An array of rooms or a single room array.
 *   FALSE is returned on error.
 */
function mfcs_load_rooms($location = NULL, $building = NULL, $room = NULL, $disabled = FALSE) {
  if (!is_null($location) && !cf_is_integer($location)) {
    cf_error::invalid_integer('location');
    return FALSE;
  }

  if (!is_null($building) && !cf_is_integer($building)) {
    cf_error::invalid_integer('building');
    return FALSE;
  }

  if (!is_null($room) && !cf_is_integer($room)) {
    cf_error::invalid_integer('room');
    return FALSE;
  }

  if (!is_bool($disabled)) {
    cf_error::invalid_bool('disabled');
    return FALSE;
  }

  $cache_id = __function__;

  if (!is_null($location) || !is_null($building)) {
    $cache_id .= '_' . $location;
    $cache_id .= '_' . $building;
  }

  if ($disabled) {
    $cache_id .= '_disabled';
  }

  $items = &drupal_static($cache_id, NULL);
  if (is_array($items)) {
    if (is_null($room)) {
      return $items;
    }

    if (array_key_exists($room, $items)) {
      return $items[$room];
    }
  }

  // don't override cached items.
  if (is_null($items)) {
    $items = array();
  }

  try {
    $query = db_select('mfcs_banner_rooms', 'mbr');
    $query->innerJoin('mfcs_banner_buildings', 'mbb', 'mbr.building = mbb.id');

    if (!is_null($room)) {
      $query->condition('mbr.id', $room);
    }

    if (!is_null($location)) {
      $query->innerJoin('mfcs_banner_building_to_location', 'mbbl', 'mbb.id = mbbl.building AND mbr.building = mbbl.building');
      $query->innerJoin('mfcs_banner_locations', 'mbl', 'mbbl.location = mbl.id');

      $query->condition('mbl.id', $location);

      $query->addField('mbl', 'id', 'location_id');
      $query->addField('mbl', 'machine_name', 'location_code');
      $query->addField('mbl', 'human_name', 'location_name');

      $query->orderBy('mbl.human_name');

      if (!$disabled) {
        $query->condition('mbl.disabled', 0);
      }
    }

    if (!$disabled) {
      $query->condition('mbr.disabled', 0);
      $query->condition('mbb.disabled', 0);
    }

    if (!is_null($building)) {
      $query->condition('mbb.id', $building);
    }

    $query->addField('mbr', 'id', 'room_id');
    $query->addField('mbr', 'machine_name', 'room_number');
    $query->addField('mbr', 'human_name', 'room_name');
    $query->addField('mbr', 'coordinator_id', 'coordinator_id');
    $query->addField('mbr', 'capacity_normal', 'capacity_normal');
    $query->addField('mbr', 'capacity_max', 'capacity_max');

    if ($disabled) {
      $query->addField('mbr', 'disabled', 'disabled');
      $query->addField('mbr', 'date', 'date');
    }

    $query->addField('mbb', 'id', 'building_id');
    $query->addField('mbb', 'machine_name', 'building_code');
    $query->addField('mbb', 'human_name', 'building_name');

    $query->orderBy('mbb.human_name');
    $query->orderBy('mbr.human_name');
    $query->orderBy('mbr.machine_name');

    $results = $query->execute()->fetchAllAssoc('room_id');

    if (!empty($results)) {
      foreach ($results as $rid => $r) {
        $items[$rid] = $r;
      }
    }

    if (is_null($room)) {
      return $items;
    }

    if (array_key_exists($room, $items)) {
      return $items[$room];
    }
    else {
      $items[$room] = FALSE;
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }

  return FALSE;
}

/**
 * Returns a list of user roles available.
 *
 * @return array|bool
 *   An array containing the roles.
 *   FALSE is returned on error.
 */
function mfcs_load_request_user_roles() {
  try {
    $query = db_select('mfcs_banner_event_roles', 'mber');
    $query->addField('mber', 'machine_name', 'role');

    $roles = $query->execute()->fetchAll();
  }
  catch (Error $e) {
    $transaction->rollback();

    return FALSE;
  }
  catch (Exception $e) {
    $transaction->rollback();

    return FALSE;
  }

  if (empty($roles)) return FALSE;

  return $roles;
}

/**
 * Returns mfcs-specific user data.
 *
 * mfcs-specific columns:
 *   'problems' is a unsigned 64-bit integer containging bitwise flags.
 *
 * @param int|array $user_ids
 *   The user id or an array of user ids.
 * @param bool $join
 *   (optional) When TRUE, will join additional relevant tables.
 * @param bool $deleted
 *   (optional) When FALSE, will join the users table and only load users with
 *   a status > 0. When TRUE, no restrictions are applied and users table is
 *   not loaded (unless $join = TRUE).
 *
 * @return array|false
 *   An array of objects containing the mfcs-specific user fields.
 *
 *   FALSE is returned on error.
 */
function mfcs_load_users($user_ids, $join = FALSE, $deleted = FALSE) {
  if (is_array($user_ids)) {
    if (empty($user_ids)) {
      cf_error::invalid_variable('user_ids', "No user ids have been specified.");
      return FALSE;
    }
  }
  elseif (cf_is_integer($user_ids)) {
    if ($user_ids < 0) {
      cf_error::invalid_variable('user_ids', "The user id must not be negative.");
      return FALSE;
    }
  }
  else {
    cf_error::invalid_variable('user_ids', "Must be an array of integers or a single integer.");
    return FALSE;
  }

  if (!is_bool($join)) {
    cf_error::invalid_bool('join');
    return FALSE;
  }

  if (!is_bool($deleted)) {
    cf_error::invalid_bool('deleted');
    return FALSE;
  }

  $users = array();
  try {
    $query = db_select('mfcs_users', 'mu');

    $query->addField('mu', 'user_id', 'user_id');
    $query->addField('mu', 'problems', 'problems');
    $query->addField('mu', 'date', 'date');

    if (is_array($user_ids)) {
      $query->condition('mu.user_id', $user_ids, 'IN');
    }
    else {
      $query->condition('mu.user_id', $user_ids);
    }

    if ($deleted === FALSE) {
      $query->innerJoin('users', 'u', 'mu.user_id = u.uid');
      $query->condition('u.status', 0, '>');
    }

    $query->orderBy('mu.user_id');

    $users = $query->execute()->fetchAllAssoc('user_id');

    if (is_array($users) && !empty($users)) {
      return $users;
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }

  return FALSE;
}

/**
 * Saves mfcs-specific user data for a single user.
 *
 * @param int $user_id
 *   The user id of the user to load.
 * @param array $data
 *   An array of user data to save.
 *   Each field will be the fields to save/update.
 *   The 'date' field will be updated by this function.
 *
 * @return bool
 *   TRUE is returned when the user exists and the data has been updated.
 *   Otherwise, FALSE is returned.
 */
function mfcs_save_user($user_id, $data) {
  if (!cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  if (!is_array($data) || empty($data)) {
    cf_error::invalid_array('data');
    return FALSE;
  }

  // ensure only this function assignes the date and user_id, overriding any existing values.
  $data['date'] = mfcs_instance();
  $data['user_id'] = $user_id;

  $transaction = db_transaction();

  try {
    $query = db_select('users', 'u');
    $query->condition('u.uid', $user_id);
    $query->addExpression('count(u.uid)');

    $user_exists = $query->execute()->fetchField();

    if ($user_exists == 0) {
      unset($transaction);
      return FALSE;
    }

    // at this time only the 'problems' field exists, so if the problems is set to none, just delete the entry.
    if (array_key_exists('problems', $data) && $data['problems'] == MFCS_USER_PROBLEM_NONE) {
      $query = db_delete('mfcs_users');
      $query->condition('user_id', $user_id);
      $query->execute();

      // enforce transaction execution
      unset($transaction);
      return TRUE;
    }

    $do_insert = FALSE;
    $query = db_select('mfcs_users', 'mu');
    $query->condition('mu.user_id', $user_id);
    $query->addExpression('count(mu.user_id)');

    $user_exists = $query->execute()->fetchField();
    if ($user_exists == 0) {
      $do_insert = TRUE;
    }

    if ($do_insert) {
      $query = db_insert('mfcs_users');
    }
    else {
      $query = db_update('mfcs_users');
      $query->condition('user_id', $user_id);
    }

    $query->fields($data);
    $query->execute();

    // enforce transaction execution
    unset($transaction);
  }
  catch (Error $e) {
    $transaction->rollback();
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    $transaction->rollback();
    cf_error::on_query_execution($e);

    return FALSE;
  }

  return TRUE;
}

/**
 * Returns a list of users based on search criteria.
 *
 * @param string $search
 *   The string to search for in the user name, e-mail, first name, or last name.
 * @param bool $wildcard
 *   (optional) When TRUE, wildcard markers will be prepended and appended..
 * @param bool $sensitive
 *   (optional) When TRUE, case-sensitiveness on the names will be applied.
 * @param bool $deleted
 *   (optional) When TRUE, search will included deleted/disabled accounts.
 *
 * @return array|false
 *   An array of objects containing the mfcs-specific user fields.
 *
 *   FALSE is returned on error.
 */
function mfcs_search_users($search, $wildcard = TRUE, $sensitive = FALSE, $deleted = FALSE) {
  if (!is_string($search)) {
    cf_error::invalid_string('search');
    return FALSE;
  }

  if (!is_bool($wildcard)) {
    cf_error::invalid_bool('wildcard');
    return FALSE;
  }

  if (!is_bool($sensitive)) {
    cf_error::invalid_bool('sensitive');
    return FALSE;
  }

  if (!is_bool($deleted)) {
    cf_error::invalid_bool('deleted');
    return FALSE;
  }

  $users = array();
  try {
    $query = db_select('users', 'u');
    $query->leftJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id');
    $query->leftJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id');

    $query->addField('u', 'uid', 'user_id');
    $query->addField('u', 'name', 'name');
    $query->addField('u', 'mail', 'email');
    $query->addField('fdfufn', 'field_user_first_name_value', 'name_first');
    $query->addField('fdfuln', 'field_user_last_name_value', 'name_last');

    if ($deleted === FALSE) {
      $query->condition('u.status', 0, '>');
    }

    $or = db_or();

    $search_string = $search;
    if ($wildcard) {
      if ($sensitive) {
        $or->condition('u.name', '%' . db_like($search) . '%', 'LIKE');
        $or->condition('u.mail', '%' . db_like($search) . '%', 'LIKE');
        $or->condition('fdfufn.field_user_first_name_value', '%' . db_like($search) . '%', 'LIKE');
        $or->condition('fdfuln.field_user_last_name_value', '%' . db_like($search) . '%', 'LIKE');
      }
      else {
        $or->condition('u.name', '%' . db_like($search) . '%', 'ILIKE');
        $or->condition('u.mail', '%' . db_like($search) . '%', 'ILIKE');
        $or->condition('fdfufn.field_user_first_name_value', '%' . db_like($search) . '%', 'ILIKE');
        $or->condition('fdfuln.field_user_last_name_value', '%' . db_like($search) . '%', 'ILIKE');
      }
    }
    elseif ($sensitive) {
      $or->condition('u.name', db_like($search), 'LIKE');
      $or->condition('u.mail', db_like($search), 'LIKE');
      $or->condition('fdfufn.field_user_first_name_value', db_like($search), 'LIKE');
      $or->condition('fdfuln.field_user_last_name_value', db_like($search), 'LIKE');
    }
    else {
      $or->condition('u.name', $search);
      $or->condition('u.mail', $search);
      $or->condition('fdfufn.field_user_first_name_value', $search);
      $or->condition('fdfuln.field_user_last_name_value', $search);
    }

    $query->condition($or);

    $query->orderBy('u.uid');

    $users = $query->execute()->fetchAllAssoc('user_id');

    if (is_array($users) && !empty($users)) {
      return $users;
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }

  return FALSE;
}

/**
 * Returns an array containg mapping information for oracle.
 *
 * Use this to map drupal request role taxonomy terms with the oracle roles.
 *
 * @return array|bool
 *   An array containing the mapping information.
 *   FALSE is returned on error.
 */
function mfcs_load_request_user_role_mapping() {
  $cache_id = __function__;
  $terms = &drupal_static($cache_id, array());
  if (!empty($terms)) {
    return $terms;
  }

  try {
    $query = db_select('taxonomy_term_data', 'ttd');
    $query->innerJoin('taxonomy_vocabulary', 'tv', 'tv.vid = ttd.vid');
    $query->fields('ttd', array('tid'));
    $query->condition('tv.machine_name', 'user_roles');

    $executed = $query->execute();
    foreach ($executed as $row) {
      $term = taxonomy_term_load($row->tid);
      $name = $term->field_role_oracle_name['und'][0]['value'];

      $terms[$name] = array('tid' => FALSE, 'role' => FALSE, 'rid' => FALSE, 'name' => FALSE);


      if (!empty($term->field_role_oracle_name['und'][0]['value'])) {
        $terms[$name]['tid'] = $row->tid;
      }

      if (!empty($term->field_role_system_name['und'][0]['value'])) {
        $role = user_role_load_by_name($term->field_role_system_name['und'][0]['value']);

        if (is_object($role)) {
          $terms[$name]['role'] = $role->name;
          $terms[$name]['rid'] = $role->rid;
        }

        unset($role);
      }

      if (!empty($term->name)) {
        $terms[$name]['name'] = $term->name;
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $terms;
}

/**
 * Returns user's basic information.
 *
 * This is different from user_load in that it loads a small set of fields.
 * This includes some hardcoded fields that are expected to be created via
 * the drupal field api frontend.
 *
 * Information loaded is:
 * - 'user_id': the users id.
 * - 'name': user's system/login name.
 * - 'email': user's e-mail address.
 * - 'status': user's enabled/disabled status.
 * - 'first_name': user's first name (custom field).
 * - 'last_name': user's last name (custom field).
 * - 'banner_id': user's banner id (custom field).
 * - 'phone_number': user's phone number (custom field).
 *
 * @param integer $user_id
 *   The user id number uniquely representing some user.
 *
 * @return array|bool
 *   An array containing the user information.
 *   FALSE is returned on error.
 */
function mfcs_load_basic_user_settings_by_user_id($user_id) {
  if (!cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');

    return FALSE;
  }

  $cache_id = __function__;
  $user = &drupal_static($cache_id, NULL);
  if (isset($user[$user_id]) && is_array($user[$user_id])) {
    return $user[$user_id];
  }

  $user[$user_id] = NULL;

  try {
    $query = db_select('users', 'u');
    $query->leftJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
    $query->leftJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND fdfuln.delta = 0');
    $query->leftJoin('field_data_field_user_banner_id', 'fdfubi', 'u.uid = fdfubi.entity_id AND fdfubi.delta = 0');
    $query->leftJoin('field_data_field_user_phone_number', 'fdfupn', 'u.uid = fdfupn.entity_id AND fdfupn.delta = 0');

    $query->addField('u', 'name', 'name');
    $query->addField('u', 'mail', 'email');
    $query->addField('u', 'status', 'status');

    $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
    $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');
    $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');
    $query->addField('fdfupn', 'field_user_phone_number_value', 'phone_number');

    $query->condition('u.uid', $user_id);

    $query->range(0, 1);

    $rows = $query->execute()->fetchAll();

    if (!empty($rows) && is_array($rows)) {
      $user[$user_id] = array(
        'user_id' => $user_id,
        'name' => '',
        'email' => '',
        'status' => '',
        'first_name' => '',
        'last_name' => '',
        'banner_id' => '',
        'phone_number' => '',
      );

      foreach ($rows as $row) {
        if (property_exists($row, 'name') && !is_null($row->name)) {
          $user[$user_id]['name'] = $row->name;
        }

        if (property_exists($row, 'email') && !is_null($row->email)) {
          $user[$user_id]['email'] = $row->email;
        }

        if (property_exists($row, 'status') && !is_null($row->status)) {
          $user[$user_id]['status'] = $row->status;
        }

        if (property_exists($row, 'first_name') && !is_null($row->first_name)) {
          $user[$user_id]['first_name'] = $row->first_name;
        }

        if (property_exists($row, 'last_name') && !is_null($row->last_name)) {
          $user[$user_id]['last_name'] = $row->last_name;
        }

        if (property_exists($row, 'banner_id') && !is_null($row->banner_id)) {
          $user[$user_id]['banner_id'] = $row->banner_id;
        }

        if (property_exists($row, 'phone_number') && !is_null($row->phone_number)) {
          $user[$user_id]['phone_number'] = $row->phone_number;
        }

        break;
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  if (is_null($user[$user_id])) return FALSE;

  return $user[$user_id];
}

/**
 * Returns user's information.
 *
 * This is different from user_load in that this loads user banner information.
 *
 * @param integer $user_id
 *   The user id number uniquely representing some user.
 *
 * @return array|bool
 *   An array containing the user information.
 *   FALSE is returned on error.
 */
function mfcs_load_request_user_by_user_id($user_id) {
  if (!cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');

    return FALSE;
  }

  $cache_id = __function__;
  $user = &drupal_static($cache_id, NULL);
  if (isset($user[$user_id]) && is_array($user[$user_id])) {
    return $user[$user_id];
  }

  $user[$user_id] = NULL;

  try {
    $query = db_select('mfcs_banner_event_roles_to_users', 'mberu');
    $query->innerJoin('mfcs_banner_event_roles', 'mber', 'mber.id = mberu.event_role_id');
    $query->innerJoin('field_data_field_user_banner_id', 'fdfubi', 'mberu.user_id = fdfubi.entity_id');

    $query->addField('mber', 'machine_name', 'role');
    $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

    $query->condition('mberu.user_id', $user_id);
    $query->condition('mberu.disabled', 0);
    $query->condition('fdfubi.entity_type', 'user');

    $rows = $query->execute()->fetchAll();

    if (!empty($rows)) {
      $user[$user_id] = array(
        'id' => NULL,
        'user_id' => $user_id,
        'role' => array(),
      );

      foreach ($rows as $row) {
        $user[$user_id]['role'][] = $row->role;

        if (is_null($user[$user_id]['id'])) {
          $user[$user_id]['id'] = $row->banner_id;
        }
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  if (is_null($user[$user_id])) return FALSE;

  return $user[$user_id];
}

/**
 * Returns user's information.
 *
 * This is different from user_load in that this loads user banner information.
 *
 * @param int $banner_id
 *   The numeric banner id string uniquely representing some user.
 *
 * @return array|bool
 *   An array containing the user information.
 *   FALSE is returned on error.
 */
function mfcs_load_request_user_by_banner_id($banner_id) {
  if (!cf_is_integer($banner_id)) {
    cf_error::invalid_int('banner_id');

    return FALSE;
  }

  $banner_id_string = mfcs_banner_id_int_to_string($banner_id);

  $cache_id = __function__;
  $user = &drupal_static($cache_id, NULL);
  if (isset($user[$banner_id]) && is_array($user[$banner_id])) {
    return $user[$banner_id];
  }

  $user[$banner_id] = NULL;

  try {
    $query = db_select('mfcs_banner_event_roles_to_users', 'mberu');
    $query->innerJoin('mfcs_banner_event_roles', 'mber', 'mber.id = mberu.event_role_id');
    $query->innerJoin('field_data_field_user_banner_id', 'fdfubi', 'mberu.user_id = fdfubi.entity_id');

    $query->addField('mber', 'machine_name', 'role');
    $query->addField('fdfubi', 'entity_id', 'user_id');

    $query->condition('fdfubi.field_user_banner_id_value', $banner_id_string);

    $rows = $query->execute()->fetchAll();

    if (!empty($rows)) {
      $user[$banner_id] = array(
        'id' => $banner_id,
        'user_id' => NUll,
        'role' => array(),
      );

      foreach ($rows as $row) {
        $user[$banner_id]['role'][] = $row->role;

        if (is_null($user[$banner_id]['user_id'])) {
          $user[$banner_id]['user_id'] = $row->user_id;
        }
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  if (is_null($user[$banner_id])) return FALSE;

  return $user[$banner_id];
}

/**
 * Synchronizes the user settings with the oracle settings.
 *
 * @param object|null $user
 *   (optional) The user object to synchronize.
 *   If not specified, then the current user is synchronized.
 * @param array $roles
 *   (optional) New roles to assign the user to.
 *   The argument $append_rules determines how these roles are assigned.
 *   The array keys are the role ids and the array values should be the role id (or 0 to remove).
 * @param bool $refresh_banner
 *   (optional) If TRUE, then when the function determines in needs to reload/re-synchronize the banner database, then it will do so.
 *   If FALSE, then it will never reload/re-synchronize the banner database even if synchronization may need to be performed.
 * @param bool $append_roles
 *   (optional) If TRUE, then the $roles are appended to the existing account.
 *   If FALSE, then the $roles replace the existing roles.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_synchronize_user_settings($user = NULL, $roles = array(), $append_roles = TRUE, $refresh_banner = TRUE) {
  if (is_null($user)) {
    $user = cf_current_user();
  }

  if (!is_object($user)) {
    cf_error::invalid_object('user');
    return FALSE;
  }

  if (!is_array($roles)) {
    cf_error::invalid_array('roles');
    return FALSE;
  }

  if (!is_bool($append_roles)) {
    cf_error::invalid_bool('append_roles');
    return FALSE;
  }

  if (!is_bool($refresh_banner)) {
    cf_error::invalid_bool('refresh_banner');
    return FALSE;
  }


  // check to see if the user is in the synchronize whitelist and if so, return from this function.
  global $conf;
  if (isset($conf['fcs_synchronize_whitelist']) && is_array($conf['fcs_synchronize_whitelist']) && in_array($user->uid, $conf['fcs_synchronize_whitelist'])) {
    return TRUE;
  }


  // only execute function once per user account per execution.
  if (!is_null($user)) {
    $already_executed = &drupal_static(__FUNCTION__, NULL);
    if (is_array($already_executed) && array_key_exists($user->uid, $already_executed)) {
      return $already_executed[$user->uid];
    }
  }


  $original_roles = (array) $user->roles;
  foreach ($original_roles as $role_id => $role_value) {
    $original_roles[$role_id] = $role_id;
  }
  unset($role_id);
  unset($role_value);

  if ($append_roles) {
    $user_roles = $original_roles;
    foreach ($roles as $role_id => $role_value) {
      if ($role_value == 0) {
        continue;
      }
      $user_roles[$role_id] = $role_id;
    }
    unset($role_id);
    unset($role_value);
  }
  else {
    foreach ($roles as $role_id => $role_value) {
      if ($role_value == 0) {
        continue;
      }
      $user_roles[$role_id] = $role_id;
    }
    unset($role_id);
    unset($role_value);
  }

  $bannerless_exception_role = user_role_load_by_name('bannerless exception');
  if (isset($bannerless_exception_role->rid) && array_key_exists($bannerless_exception_role->rid, $user_roles)) {
    // if the user has the bannerless exception role assigned, then do not synchronize anything.
    if (!is_null($user)) {
      $already_executed[$user->uid] = TRUE;
    }
    return TRUE;
  }
  unset($bannerless_exception_role);

  $reviewer_exception = NULL;
  $reviewer_exception_role = user_role_load_by_name('reviewer exception');
  if (isset($reviewer_exception_role->rid) && array_key_exists($reviewer_exception_role->rid, $user_roles)) {
    $reviewer_role = user_role_load_by_name('reviewer');
    if (isset($reviewer_role->rid)) {
      $reviewer_exception = array_key_exists($reviewer_role->rid, $user_roles);
    }
    unset($reviewer_role);
  }

  unset($reviewer_exception_role);

  // load the mfcs user-specific problem data as a baseline to make changes to.
  $mfcs_users = mfcs_load_users($user->uid, FALSE, ($user->status == 0));
  $problems_original = MFCS_USER_PROBLEM_NONE;
  if (isset($mfcs_users[$user->uid])) {
    $problems_original = $mfcs_users[$user->uid]->problems;
  }
  unset($mfcs_users);
  $problems_new = $problems_original;


  // load the current users custom account information where available.
  $banner_id = NULL;
  if (!empty($user->field_user_banner_id['und'][0]['value']) && is_numeric($user->field_user_banner_id['und'][0]['value'])) {
    $banner_id = $user->field_user_banner_id['und'][0]['value'];
    if (is_numeric($banner_id)) {
      $banner_id = (int) $banner_id;
    }
  }

  if (is_null($banner_id)) {
    // banner id is necessary for synchronization, if this account has no banner id, then there is nothing to do.
    if (!is_null($user)) {
      $already_executed[$user->uid] = TRUE;
    }
    return TRUE;
  }

  $ldap_duplicate = NULL;
  if (!empty($user->field_user_ldap_duplicate['und'][0]['value']) && is_string($user->field_user_ldap_duplicate['und'][0]['value'])) {
    $ldap_duplicate = strtolower($user->field_user_ldap_duplicate['und'][0]['value']);

    // drupal may store the boolean as either 'true' or '1' for TRUE and either 'false' or '0' for FALSE.
    if ($ldap_duplicate == 'true' || $ldap_duplicate == '1') {
      $ldap_duplicate = TRUE;
    }
    elseif ($ldap_duplicate == 'false' || $ldap_duplicate == '0') {
      $ldap_duplicate = FALSE;
    }
  }

  $ldap_primary = NULL;
  $primary_account_id = NULL;
  if (!empty($user->field_user_primary_account['und'][0]['value']) && is_string($user->field_user_primary_account['und'][0]['value'])) {
    $ldap_primary = strtolower($user->field_user_primary_account['und'][0]['value']);

    // drupal may store the boolean as either 'true' or '1' for TRUE and either 'false' or '0' for FALSE.
    if ($ldap_primary == 'true' || $ldap_primary == '1') {
      $ldap_primary = TRUE;
      $primary_account_id = $user->uid;
    }
    elseif ($ldap_primary == 'false' || $ldap_primary == '0') {
      $ldap_primary = FALSE;
    }
  }


  // Determine how many accounts (with same banner id) are assigned as primary.
  if ($ldap_primary !== TRUE && !is_null($banner_id)) {
    $associated_users = mfcs_users_load_banner_id_to_user_id($banner_id);
    $total_primary = 0;
    $total_accounts = 0;
    $accounts = array();

    if (!empty($associated_users['user'])) {
      foreach ($associated_users['user'] as $associated_user_id => $associated_user) {
        $total_accounts++;

        $accounts[$associated_user_id] = $associated_user_id;
        if ($associated_user['primary'] == 1) {
          $total_primary++;

          if (is_null($primary_account_id)) {
            $primary_account_id = $associated_user_id;
          }
        }
      }
    }
    unset($associated_user_id);
    unset($associated_user);
    unset($associated_users);

    // $accounts is used to perform synchronization loads, so do not save the user account currently being processed.
    unset($accounts[$user->uid]);
  }
  else {
    $total_primary = 0;
    $total_accounts = 1;
    $accounts = array();
  }


  // ticket: fcs-60, if there is only 1 user when isDuplicate is set, then assign that as primary.
  $assign_primary = FALSE;
  if ($total_primary < 1) {
    $assign_primary = TRUE;

    if ($total_accounts > 1 && !$ldap_duplicate) {
      $problems_new = $problems_new | MFCS_USER_PROBLEM_ACCOUNT_DUPLICATES;
    }
  }
  elseif ($total_primary > 1) {
    if (!$ldap_duplicate) {
      $problems_new = $problems_new | MFCS_USER_PROBLEM_ACCOUNT_DUPLICATES;
    }
  }

  if ($ldap_duplicate) {
    // if the current user is not the primary account, then load the roles from the primary account and return.
    if (!is_null($primary_account_id) && $user->uid != $primary_account_id) {
      $primary_account = user_load($primary_account_id);
      $results = mfcs_synchronize_user_settings($primary_account, $roles, $append_roles, $refresh_banner);
      if ($results === TRUE) {
        $primary_account = user_load($primary_account_id);
        return is_object(user_save($primary_account, array('roles' => $primary_account->roles)));
      }

      // account synchronization failed, so assign the problem flag.
      if (($problems_new & MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE) == 0) {
        $problems_new = $problems_new | MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE;
      }

      if ($problems_original != $problems_new) {
        mfcs_save_user($user->uid, array('problems' => $problems_new));
      }

      if (!is_null($user)) {
        $already_executed[$user->uid] = FALSE;
      }
      return FALSE;
    }
  }


  // handle all appropriate banner refreshes.
  if ($refresh_banner) {
    $result = mfcs_sync_banner_to_local_users($user->uid, $banner_id);
    if (($problems_original & MFCS_USER_PROBLEM_ACCOUNT_CREATE_BANNER_UNAVAILABLE) != 0 || ($problems_original & MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE) != 0 || ($problems_original & MFCS_USER_PROBLEM_ACCOUNT_NO_ACCESS) != 0) {
      if ($result === TRUE) {
        if (($problems_original & MFCS_USER_PROBLEM_ACCOUNT_CREATE_BANNER_UNAVAILABLE) != 0) {
          $problems_new -= MFCS_USER_PROBLEM_ACCOUNT_CREATE_BANNER_UNAVAILABLE;
        }

        if (($problems_original & MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE) != 0) {
          $problems_new -= MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE;
        }

        if (($problems_original & MFCS_USER_PROBLEM_ACCOUNT_NO_ACCESS) != 0) {
          $problems_new -= MFCS_USER_PROBLEM_ACCOUNT_NO_ACCESS;
        }
      }
    }

    if (!empty($accounts)) {
      $account_mfcs_information = mfcs_load_users($accounts, FALSE, TRUE);
      foreach ($accounts as $account_id) {
        $account_problems = MFCS_USER_PROBLEM_NONE;
        if (isset($account_mfcs_information[$account_id])) {
          $account_problems = $account_mfcs_information[$account_id]->problems;
        }

        if (($account_problems & MFCS_USER_PROBLEM_ACCOUNT_CREATE_BANNER_UNAVAILABLE) != 0 || ($account_problems & MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE) != 0 || ($problems_original & MFCS_USER_PROBLEM_ACCOUNT_NO_ACCESS) != 0) {
          $account = user_load($account_id);
          mfcs_synchronize_user_settings($account, $user_roles, FALSE, FALSE);
          unset($account);
        }
      }
    }
  }

  $changes_detected = TRUE;
  if (count($original_roles) == count($user_roles)) {
    $difference = array_diff(array_keys($original_roles), array_keys($user_roles));
    if (empty($difference)) {
      $changes_detected = FALSE;
    }
  }

  $edit = array();
  if ($assign_primary) {
    $changes_detected = TRUE;

    // make sure that all reviewer roles associated with the current user are assigned to the primary user and not the others.
    if (!empty($accounts)) {
      $transaction = db_transaction();
      try {
        if (count($accounts) == 1) {
          $query = db_query('update mfcs_reviewers set user_id = :primary_id where user_id = :account_id', array(':primary_id' => $user->uid, ':account_id' => reset($accounts)));
          $query = db_query('update mfcs_proxy_venue_coordinator set user_id = :primary_id where user_id = :account_id', array(':primary_id' => $user->uid, ':account_id' => reset($accounts)));
          $query = db_query('update mfcs_proxy_venue_coordinator set proxy_id = :primary_id where proxy_id = :account_id', array(':primary_id' => $user->uid, ':account_id' => reset($accounts)));
        }
        else {
          $query = db_query('update mfcs_reviewers set user_id = :primary_id where user_id IN :account_ids', array(':primary_id' => $user->uid, ':account_ids' => $accounts));
          $query = db_query('update mfcs_proxy_venue_coordinator set user_id = :primary_id where user_id IN :account_ids', array(':primary_id' => $user->uid, ':account_ids' => $accounts));
          $query = db_query('update mfcs_proxy_venue_coordinator set proxy_id = :primary_id where proxy_id IN :account_ids', array(':primary_id' => $user->uid, ':account_ids' => $accounts));
        }

        unset($transaction);
      }
      catch (Error $e) {
        $transaction->rollback();
        cf_error::on_query_execution($e);

        // account synchronization failed, so assign the problem flag.
        if (($problems_new & MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE) == 0) {
          $problems_new = $problems_new | MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE;
        }

        if ($problems_original != $problems_new) {
          mfcs_save_user($user->uid, array('problems' => $problems_new));
        }

        if (!is_null($user)) {
          $already_executed[$user->uid] = FALSE;
        }
        return FALSE;
      }
      catch (Exception $e) {
        $transaction->rollback();
        cf_error::on_query_execution($e);

        // account synchronization failed, so assign the problem flag.
        if (($problems_new & MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE) == 0) {
          $problems_new = $problems_new | MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE;
        }

        if ($problems_original != $problems_new) {
          mfcs_save_user($user->uid, array('problems' => $problems_new));
        }

        if (!is_null($user)) {
          $already_executed[$user->uid] = FALSE;
        }
        return FALSE;
      }
    }

    $edit['field_user_primary_account']['und'][0]['value'] = 1;
  }


  // Whenever user_save() is called, the hook_user_presave() will auto-refresh banner information.
  if ($changes_detected || $refresh_banner) {
    $edit['roles'] = $user_roles;

    if (!user_save($user, $edit)) {
      // the user-presave process may have altered the user problems settings.
      $mfcs_users = mfcs_load_users($user->uid, FALSE, ($user->status == 0));
      if (isset($mfcs_users[$user->uid])) {
        $problems_original = $mfcs_users[$user->uid]->problems;
      }
      unset($mfcs_users);

      // account synchronization failed, so assign the problem flag.
      if (($problems_new & MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE) == 0) {
        $problems_new = $problems_new | MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE;
      }

      if ($problems_original != $problems_new) {
        mfcs_save_user($user->uid, array('problems' => $problems_new));
      }

      if (!is_null($user)) {
        $already_executed[$user->uid] = FALSE;
      }
      return FALSE;
    }

    // the user-presave process may have altered the user problems settings.
    $mfcs_users = mfcs_load_users($user->uid, FALSE, ($user->status == 0));
    if (isset($mfcs_users[$user->uid])) {
      $problems_original = $mfcs_users[$user->uid]->problems;
    }
    unset($mfcs_users);
  }

  if ($problems_original != $problems_new) {
    mfcs_save_user($user->uid, array('problems' => $problems_new));
  }

  if (!is_null($user)) {
    $already_executed[$user->uid] = FALSE;
  }
  return TRUE;
}

/**
 * Given a user object, the user settings will be updated.
 *
 * Process bannerless exception before calling this and if bannerless exception is enabled, then do not call this.
 *
 * @param object $user
 *   The user object to process.
 * @param int $problems
 *   An integer representing existing problems.
 *   This will be altered so that the caller can discover and handle problems encountered during the execution of this function.
 * @param array $settings
 *   (optional) An array containing the following keys:
 *   'banner_id': If set, then is an integer representing the banner id.
 *                May be set to NULL to designate that the account has no banner id.
 *   'primary': If set, then is a boolean representing the is primary account status.
 *              May be set to NULL to designate that the primary account needs to be determined/detected.
 *   'roles': If set, then is a complete list of role integers associated with the user.
 *            The array key is the role id and the array value is the role name.
 *   'status: If set, then this is an integer to use in place of the user accounts status.
 *
 * @return bool|array
 *   An array containing the changed fields, to be merged with a function such as mfcs_hook_user_presave().
 *   TRUE is returned when banner roles are not to be changed.
 *   FALSE is returned on error.
 *
 * @see: mfcs_hook_user_presave()
 */
function mfcs_process_user_banner_roles($user, &$problems, $settings = array()) {
  if (!is_object($user)) {
    cf_error::invalid_object('user');
    return FALSE;
  }

  if (!cf_is_integer($problems)) {
    cf_error::invalid_integer('problems');
    return FALSE;
  }

  if (!is_array($settings)) {
    cf_error::invalid_array('settings');
    return FALSE;
  }

  if (array_key_exists('banner_id', $settings)) {
    if (is_null($settings['banner_id'])) {
      // accounts without banner ids cannot be synced and are therefore ignored.
      return TRUE;
    }

    $banner_id = $settings['banner_id'];
  }
  else {
    if (empty($user->field_user_banner_id['und'][0]['value']) || !is_numeric($user->field_user_banner_id['und'][0]['value'])) {
      // accounts without banner ids cannot be synced and are therefore ignored.
      return TRUE;
    }

    $banner_id = (int) $user->field_user_banner_id['und'][0]['value'];
  }

  if (isset($user->uid)) {
    $already_executed = &drupal_static(__FUNCTION__, NULL);
    if (is_array($already_executed) && array_key_exists($user->uid, $already_executed)) {
      return $already_executed[$user->uid];
    }
  }

  $primary_account_id = NULL;
  if (array_key_exists('primary', $settings)) {
    if (cf_is_integer($settings['primary'])) {
      $primary_account_id = (int) $settings['primary'];
    }
  }

  $is_primary = TRUE;
  if (is_null($primary_account_id)) {
    $ldap_primary = NULL;
    if (!empty($user->field_user_primary_account['und'][0]['value']) && is_string($user->field_user_primary_account['und'][0]['value'])) {
      $ldap_primary = strtolower($user->field_user_primary_account['und'][0]['value']);

      // drupal may store the boolean as either 'true' or '1' for TRUE and either 'false' or '0' for FALSE.
      if ($ldap_primary == 'true' || $ldap_primary == '1') {
        $is_primary = TRUE;
      }
      elseif ($ldap_primary == 'false' || $ldap_primary == '0') {
        $is_primary = FALSE;
      }
    }
    unset($ldap_primary);

    if (isset($user->uid)) {
      if ($is_primary) {
        $primary_account_id = (int) $user->uid;
      }
      else {
        // load the user id for the primary account.
        $associated_users = mfcs_users_load_banner_id_to_user_id($banner_id);
        if (!empty($associated_users['user'])) {
          foreach ($associated_users['user'] as $associated_user_id => $associated_user) {
            if ($associated_user['primary'] == TRUE) {
              $primary_account_id = (int) $associated_user_id;
              break;
            }
          }
        }
        unset($associated_user_id);
        unset($associated_user);
        unset($associated_users);
      }
    }
  }

  // warning: these are assumed to be defined (on a new install, they must be manually created with these exact names).
  $requester_role = user_role_load_by_name('requester');
  $reviewer_role = user_role_load_by_name('reviewer');
  $manager_role = user_role_load_by_name('manager');
  $administrator_role = user_role_load_by_name('administrator');
  $bannerless_exception_role = user_role_load_by_name('bannerless exception');
  $reviewer_exception_role = user_role_load_by_name('reviewer exception');


  $user_roles = array();
  if (isset($user->roles) && is_array($user->roles)) {
    $user_roles = $user->roles;
  }

  if (array_key_exists('roles', $settings)) {
    if (is_array($settings['roles'])) {
      $user_roles = $settings['roles'];
    }
  }

  $user_status = NULL;
  if (isset($user->status)) {
    $user_status = (int) $user->status;
    if (array_key_exists('status', $settings) && is_int($settings['status'])) {
      $user_status = (int) $settings['status'];
    }
  }


  // force array to be populated with role ids and not role names.
  $processed_roles = array();
  foreach ($user_roles as $role_id => $role_name) {
    $processed_roles[$role_id] = (int) $role_id;
  }
  unset($role_id);
  unset($role_name);

  if (isset($bannerless_exception_role->rid) && array_key_exists($bannerless_exception_role->rid, $processed_roles)) {
    // if the user is defined as being an exception to operate as if it is bannerless, then do so.
    if (isset($user->uid)) {
      $already_executed[$user->uid] = TRUE;
    }
    return TRUE;
  }

  if (isset($administrator_role->rid) && array_key_exists($administrator_role->rid, $processed_roles)) {
    // administrators are not auto-managed.
    if (isset($user->uid)) {
      $already_executed[$user->uid] = TRUE;
    }
    return TRUE;
  }

  unset($administrator_role);
  unset($bannerless_exception_role);

  $is_manager = array_key_exists($manager_role->rid, $processed_roles);


  // remove roles associated with banner from the user roles for non-managers.
  $mappings = mfcs_load_request_user_role_mapping();
  $manager_banner_roles = array();
  foreach ($mappings as $mapping) {
    if (array_key_exists($mapping['rid'], $processed_roles)) {
      if ($is_manager) {
        $manager_banner_roles[$mapping['rid']] = $mapping['tid'];
      }
      else {
        unset($processed_roles[$mapping['rid']]);
      }
    }
  }
  unset($mapping);


  // validate banner id, if invalid, then strip all user roles (admins are cleared before this point).
  if (mfcs_load_request_user_by_banner_id($banner_id) === FALSE) {
    if ($user_status === 0) {
      // disabled accounts should not report invalid banner ids.
      if (($problems & MFCS_USER_PROBLEM_ACCOUNT_BANNER_INVALID) != 0) {
        $problems = $problems - MFCS_USER_PROBLEM_ACCOUNT_BANNER_INVALID;
      }
    }
    elseif (($problems & MFCS_USER_PROBLEM_ACCOUNT_BANNER_INVALID) == 0) {
      $problems = $problems | MFCS_USER_PROBLEM_ACCOUNT_BANNER_INVALID;
    }

    if (!$is_manager) {
      if (isset($user->uid)) {
        $already_executed[$user->uid] = FALSE;
      }
      return FALSE;
    }
  }
  elseif (($problems & MFCS_USER_PROBLEM_ACCOUNT_BANNER_INVALID) != 0) {
    $problems = $problems - MFCS_USER_PROBLEM_ACCOUNT_BANNER_INVALID;
  }

  // load banner role information associated with the primary user.
  $user_banner = array();
  if ($is_primary) {
    if (isset($user->uid)) {
      $user_banner = mfcs_load_request_user_by_user_id($user->uid);
      if ($user_banner == FALSE) {
        $user_banner = array();
      }
    }
  }
  elseif (!is_null($primary_account_id)) {
    $user_banner = mfcs_load_request_user_by_user_id($primary_account_id);
    if ($user_banner == FALSE) {
      $user_banner = array();
    }
  }

  // Assign requester role for all users who have valid banner accounts (administrators and bannerless exception should never reach this point).
  if (!array_key_exists($requester_role->rid, $processed_roles) && !empty($user_banner)) {
    $processed_roles[$requester_role->rid] = $requester_role->rid;
  }

  // if the (non-admin) user is a venue or room coordinator, then add/remove reviewer role as necessary.
  $banner_roles = array();
  if (empty($user_banner['role'])) {
    // if the user has no banner roles, is not a manager, and is not a reviewer exception, then do not allow the user to have reviewer role (bannerless exception and administrators cannot reach this point).
    if (!$is_manager && !array_key_exists($reviewer_exception_role->rid, $processed_roles)) {
      unset($processed_roles[$reviewer_role->rid]);
    }
  }
  else {
    foreach ($user_banner['role'] as $role) {
      if (isset($mappings[$role]['tid'])) {
        $banner_roles[] = array('tid' => $mappings[$role]['tid']);
        $processed_roles[$mappings[$role]['rid']] = $mappings[$role]['rid'];
      }
    }
    unset($role);
  }

  // managers are auto-granted specified roles even if the roles are not supplied by banner.
  if ($is_manager) {
    foreach ($manager_banner_roles as $role_tid) {
      $banner_roles[] = array('tid' => $role_tid);
    }
    unset($role_tid);
  }


  // if the user can proxy as another account, then they need the reviewer role (but make no changes if the user is a manager).
  if (!$is_manager) {
    $can_proxy = FALSE;
    $proxy_accounts = mfcs_get_proxy_venue_coordinators(array('mpvc.user_id' => $primary_account_id));
    if (!empty($proxy_accounts['results'])) {
      $processed_roles[$reviewer_role->rid] = $reviewer_role->rid;
      $can_proxy = TRUE;
    }
  }


  // Alter reviewer role settings for users without 'manager' and 'reviewer exception' roles.
  if (!$is_manager && !array_key_exists($reviewer_exception_role->rid, $processed_roles)) {
    $assigned_as_reviewer = FALSE;
    $reviewers = mfcs_get_reviewers(array('mr.user_id' => $primary_account_id, 'mr.disabled' => 0));
    if (!empty($reviewers['results'])) {
      $assigned_as_reviewer = TRUE;
    }

    $all_coordinators = mfcs_load_room_coordinators(NULL, TRUE);
    if (array_key_exists($primary_account_id, $all_coordinators) || $assigned_as_reviewer) {
      if (!array_key_exists($reviewer_role->rid, $processed_roles)) {
        $processed_roles[$reviewer_role->rid] = $reviewer_role->rid;
      }
    }
    elseif (!$can_proxy) {
      if (array_key_exists($reviewer_role->rid, $processed_roles)) {
        unset($processed_roles[$reviewer_role->rid]);

        // the function arguments are trying to assign 'proxy' role to a user who has no venue or room to review.
        // do not allow this and provide a watchdog warning for reference.
        watchdog(MFCS_WATCHDOG_ID, "The user '%user_name' (%user_id, %primary_id) is not being granted reviewer access as requested because the user is not assigned as either a venue or room coordinator in the banner database and is not a venue coordinator proxy.", array('%user_name' => $user->name, '%user_id' => isset($user->uid) ? $user->uid : 'undefined', '%primary_id' => $primary_account_id), WATCHDOG_WARNING);

        $problems = $problems | MFCS_USER_PROBLEM_ACCOUNT_REVIEWER_NOT_ALLOWED;
      }
    }
  }

  $results = array();

  // auto-lock or auto-unlock accounts without any banner roles, but only when banner can be refreshed.
  if (($problems & MFCS_USER_PROBLEM_ACCOUNT_CREATE_BANNER_UNAVAILABLE) == 0 && ($problems & MFCS_USER_PROBLEM_ACCOUNT_SYNC_BANNER_UNAVAILABLE) == 0 && ($problems & MFCS_USER_PROBLEM_ACCOUNT_BANNER_INVALID) == 0) {
    // If the user has banner roles, then make sure MFCS_USER_PROBLEM_ACCOUNT_NO_ACCESS is no longer set.
    if (!empty($banner_roles) && ($problems & MFCS_USER_PROBLEM_ACCOUNT_NO_ACCESS) != 0) {
      $problems -= MFCS_USER_PROBLEM_ACCOUNT_NO_ACCESS;
    }

    if ($user->status == 0) {
      if (!empty($banner_roles)) {
        // auto-unlock account.
        $results['status'] = 1;

        watchdog(MFCS_WATCHDOG_ID, "The user '%user_name' (%user_id, %primary_id) has had the account enabled/unlocked due to regaining sufficient banner roles.", array('%user_name' => $user->name, '%user_id' => isset($user->uid) ? $user->uid : 'undefined', '%primary_id' => $primary_account_id), WATCHDOG_NOTICE);
      }
    }
    else {
      if (empty($banner_roles)) {
        // auto-lock account (currently disabled).
        #$results['status'] = 0;

        #watchdog(MFCS_WATCHDOG_ID, "The user '%user_name' (%user_id, %primary_id) has had the account disabled/locked due to insufficient banner roles.", array('%user_name' => $user->name, '%user_id' => isset($user->uid) ? $user->uid : 'undefined', '%primary_id' => $primary_account_id), WATCHDOG_NOTICE);
      }
    }
  }

  // Note: the system used to refer to requests as events, but because this is a drupal field, 'event' cannot be easily changed to 'request' in this explicit case.
  $results['field_user_event_roles'] = array('und' => $banner_roles);
  $results['roles'] = $processed_roles;

  if (isset($user->uid)) {
    $already_executed[$user->uid] = $results;
  }
  return $results;
}

/**
 * Loads the user by e-mail and if the user does not exist. create it.
 *
 * @param string $email
 *   The users mcneese e-mail address.
 * @param array $roles
 *   An array of roles to assign the user to. If none is specified, then the
 *   default is to assign the reviewer role.
 *
 * @return object|false
 *   User object on success, FALSE otherwise.
 */
function mfcs_ensure_user_by_email($email, $roles = array()) {
  if (!is_string($email) || empty($email)) {
    cf_error::invalid_string('email');
    return FALSE;
  }

  if (!is_array($roles)) {
    cf_error::invalid_array('roles');
    return FALSE;
  }

  $email_parts = explode('@', $email);

  if (count($email_parts) != 2) {
    return FALSE;
  }

  $username = trim($email_parts[0]);
  $hostname = trim($email_parts[1]);

  if ($hostname != 'mcneese.edu' && $hostname != 'student.mcneese.edu') {
    return FALSE;
  }

  $user = user_load_by_name($username);
  if (is_object($user)) {
    return $user;
  }
  unset($user);


  // check to see if the user exists in ldap.
  $auth_conf = ldap_authentication_get_valid_conf();
  $ldap_user = FALSE;
  $ldap_server = NULL;
  $detailed_watchdog_log = variable_get('ldap_help_watchdog_detail', 0);
  $authentication_result = LDAP_AUTHENTICATION_RESULT_FAIL_GENERIC;

  foreach ($auth_conf->enabledAuthenticationServers as $sid => $ldap_server) {
    $watchdog_tokens = array();
    $authentication_result = LDAP_AUTHENTICATION_RESULT_FAIL_GENERIC;
    $result = $ldap_server->connect();

    if ($result != LDAP_SUCCESS) {
      $authentication_result = LDAP_AUTHENTICATION_RESULT_FAIL_CONNECT;
      $watchdog_tokens['%err_msg'] = $ldap_server->errorMsg('ldap');

      if ($detailed_watchdog_log) {
        watchdog('ldap_authentication',  '%username : Failed connecting to %sid.  Error: %err_msg', $watchdog_tokens, WATCHDOG_DEBUG);
      }

      continue;
    }

    $bind_success = FALSE;
    if ($ldap_server->bind_method != LDAP_SERVERS_BIND_METHOD_ANON && $ldap_server->bind_method != LDAP_SERVERS_BIND_METHOD_ANON_USER) {
      // this can only work using anonymous bindings.
      continue;
    }

    $bind_success = ($ldap_server->bind(NULL, NULL, TRUE) == LDAP_SUCCESS);

    if (!$bind_success) {
      if ($detailed_watchdog_log) {
        $watchdog_tokens['%err_text'] = $ldap_server->errorMsg('ldap');
        watchdog('ldap_authentication', '%username : Trying server %sid where bind_method = %bind_method.  Error: %err_text', $watchdog_tokens, WATCHDOG_DEBUG);
      }
      $authentication_result = ($ldap_server->bind_method == LDAP_SERVERS_BIND_METHOD_USER) ? LDAP_AUTHENTICATION_RESULT_FAIL_CREDENTIALS : LDAP_AUTHENTICATION_RESULT_FAIL_BIND;
      continue; // if bind fails, onto next server
    }

    $ldap_user = $ldap_server->userUserNameToExistingLdapEntry($username);
    if ($ldap_user !== FALSE) {
      break;
    }
  }

  if (empty($ldap_user)) {
    return FALSE;
  }


  // create the new user.
  $auth_conf = ldap_authentication_get_valid_conf();
  $watchdog_tokens = array(
    '%authname' => $username,
    '%account_name_attr' => $username,
    '%drupal_accountname' => $username,
  );

  if (!$auth_conf) {
    watchdog('ldap_authentication', 'Failed to get valid ldap authentication configuration.', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!$auth_conf->hasEnabledAuthenticationServers()) {
    watchdog('ldap_authentication',  'No LDAP servers configured.', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!$auth_conf->ldapUser->provisionEnabled(LDAP_USER_PROV_DIRECTION_TO_DRUPAL_USER, LDAP_USER_DRUPAL_USER_PROV_ON_AUTHENTICATE)) {
    watchdog('ldap_user', 'Drupal account for authname=%authname account name=%account_name_attr does not exist and provisioning of Drupal accounts on authentication is not enabled', $watchdog_tokens, WATCHDOG_INFO);
    return;
  }

  $user_register = variable_get('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL);
  if ($auth_conf->ldapUser->acctCreation == LDAP_USER_ACCT_CREATION_USER_SETTINGS_FOR_LDAP && $user_register == USER_REGISTER_ADMINISTRATORS_ONLY) {
    watchdog('ldap_user', 'Failed to create account for %drupal_accountname. Administrative user must create user.', $watchdog_tokens, WATCHDOG_ERROR);
    return FALSE;
  }

  if ($auth_conf->ldapUser->acctCreation == LDAP_AUTHENTICATION_ACCT_CREATION_USER_SETTINGS_FOR_LDAP && $user_register == USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL) {
    $user_edit = array('name' => $username, 'mail' => $email, 'status' => 0); // if admin approval required, set status to 0.
  }
  else {
    $user_edit = array('name' => $username, 'mail' => $email, 'status' => 1);
  }

  // don't pass in ldap user to provisionDrupalAccount, because want to requery with correct attributes needed
  // this may be a case where efficiency dictates querying for all attributes
  $drupal_account = $auth_conf->ldapUser->provisionDrupalAccount(FALSE, $user_edit, NULL, TRUE);

  if ($drupal_account === FALSE) {
    watchdog('ldap_user', 'Failed to find or create %drupal_accountname.', $watchdog_tokens, WATCHDOG_ERROR);
    return FALSE;
  }

  if ($drupal_account === TRUE) {
    $drupal_account = user_load_by_name($username);
  }

  user_set_authmaps($drupal_account, array('authname_ldap_user' => $username));

  // Using Rules allows emails to be fired and many other possible reactions
  // to the creation of a user.
  if (function_exists('rules_invoke_event')) {
    rules_invoke_event('ldap_user_created', $drupal_account, FALSE);
  }

  mfcs_synchronize_user_settings($drupal_account, $roles);

  // reset the user object cache to force loading of new settings.
  $user = user_load($drupal_account->uid, TRUE);

  return $user;
}

/**
 * Synchronizes the local database with the banner venue information.
 *
 * @param object|null $transaction
 *   (optional) If not NULL, then a transaction object created by the
 *   caller.
 * @param object|null $user
 *   (optional) The user object or NULL for the current user.
 * @param bool $message_on_oracle_failure
 *   (optional) If TRUE, then the a message will be presented when unable to connect to the oracle database.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_sync_banner_to_local($transaction = NULL, $user = NULL, $message_on_oracle_failure = FALSE) {
  if (is_null($user)) {
    $user = cf_current_user();
  }

  if (!is_object($user)) {
    cf_error::invalid_object('user');
    return FALSE;
  }

  if (!is_bool($message_on_oracle_failure)) {
    cf_error::invalid_bool('message_on_oracle_failure');
    return FALSE;
  }

  $join = ' inner join ucs.msu_venue_list mvl on (mvl.category = mvd.category and mvl.building_code = mvd.building_code and mvl.room_number = mvd.room_number)';

  $select = 'mvd.*';
  $select .= ', mvl.building_desc as building_desc';
  $select .= ', mvl.room_desc as room_desc';

  $rows = mfcs_oracle_select('select ' . $select . ' from ucs.msu_venue_detail mvd' . $join);

  if (empty($rows) || !is_array($rows)) {
    if ($rows === FALSE) {
      if ($message_on_oracle_failure) {
        drupal_set_message("Failed to connect to banner database.", 'error', FALSE);
      }
    }
    return FALSE;
  }

  mfcs_include(MFCS_INCLUDE_LIST_OPTIONS);
  $request_locations = mfcs_get_request_location_list_options(NULL, TRUE);

  $instance = mfcs_instance();

  if (!is_object($transaction)) {
    $transaction = db_transaction();
  }

  try {
    // disable all locations, buildings, and rooms such that the ones that are not added back will be disabled.
    $query = db_update('mfcs_banner_locations');
    $query->fields(array('disabled' => 1, 'date' => $instance));
    $query->condition('disabled', 0);
    $query->execute();

    $query = db_update('mfcs_banner_buildings');
    $query->fields(array('disabled' => 1, 'date' => $instance));
    $query->condition('disabled', 0);
    $query->execute();

    $query = db_update('mfcs_banner_rooms');
    $query->fields(array('disabled' => 1, 'date' => $instance));
    $query->condition('disabled', 0);
    $query->execute();

    $query = db_update('mfcs_banner_building_to_location');
    $query->fields(array('disabled' => 1, 'date' => $instance));
    $query->condition('disabled', 0);
    $query->execute();

    foreach ($rows as $row) {
      $location_item = array();
      $building_item = array();
      $room_item = array();
      $coordinator_room_item = array();
      $coordinator_venue_item = array();
      $location_to_building_item = array();

      if (is_array($row)) {
        foreach ($row as $key => $value) {
          // oracle returns duplicate/redundant data in numeric rows.
          if (is_numeric($key)) continue;

          // remove possible trailing whitespaces.
          $v = trim($value);

          if ($key == 'building_code') {
            $building_item['machine_name'] = $v;
            $building_item['disabled'] = 0;
          }
          elseif ($key == 'building_desc') {
            $building_item['human_name'] = $v;
          }
          elseif ($key == 'room_number') {
            $room_item['machine_name'] = $v;
            $room_item['disabled'] = 0;

            // Banner stores other things inside of the room number, so if it actually is a number, store it in the human name, which contains the description.
            if (isset($room_item['human_name']) && cf_is_integer($room_item['machine_name'])) {
              if (empty($room_item['human_name'])) {
                $room_item['human_name'] = "Room #"  . $room_item['machine_name'];
              }
              else {
                $room_item['human_name'] .= " " . $room_item['machine_name'];
              }
            }
          }
          elseif ($key == 'room_desc') {
            $room_item['human_name'] = $v;
            $room_item['disabled'] = 0;

            // Banner stores other things inside of the room number, so if it actually is a number, store it in the human name, which contains the description.
            if (isset($room_item['machine_name']) && cf_is_integer($room_item['machine_name'])) {
              if (empty($room_item['human_name'])) {
                $room_item['human_name'] = "Room";
              }
              $room_item['human_name'] .= " #" . $room_item['machine_name'];
            }
          }
          elseif ($key == 'capacity') {
            $room_item['capacity_normal'] = $v;
          }
          elseif ($key == 'max_capacity') {
            $room_item['capacity_max'] = $v;
          }
          elseif ($key == 'category') {
            $location_item['machine_name'] = $v;
            $location_item['human_name'] = $v;
            $location_item['disabled'] = 0;

            if (array_key_exists($v, $request_locations)) {
              $location_item['human_name'] = substr($request_locations[$v], 0, 63);
            }
          }
          elseif ($key == 'room_coordinator_email') {
            $coordinator_room_item['email'] = $v;
          }
          elseif ($key == 'venue_coordinator_email') {
            $coordinator_venue_item['email'] = $v;

            // have the room coordinator fallback to the venue coordinator if no room coordinator is specified.
            if (!isset($coordinator_room_item['email'])) {
              $coordinator_room_item['email'] = $v;
            }
          }
        }

        // add the room and venue coordinators.
        $room_coordinator = NULL;
        if (!empty($coordinator_room_item['email'])) {
          $roles = array();
          $role = user_role_load_by_name('reviewer');
          if (is_object($role)) {
            $roles[$role->rid] = $role->rid;
          }

          $role = user_role_load_by_name('requester');
          if (is_object($role)) {
            $roles[$role->rid] = $role->rid;
          }
          unset($role);

          $room_coordinator = mfcs_ensure_user_by_email($coordinator_room_item['email'], $roles);
          unset($roles);
        }

        if (!is_object($room_coordinator) && !empty($coordinator_venue_item['email'])) {
          $roles = array();
          $role = user_role_load_by_name('reviewer');
          if (is_object($role)) {
            $roles[$role->rid] = $role->rid;
          }

          $role = user_role_load_by_name('requester');
          if (is_object($role)) {
            $roles[$role->rid] = $role->rid;
          }
          unset($role);

          $room_coordinator = mfcs_ensure_user_by_email($coordinator_venue_item['email'], $roles);
          unset($roles);
        }

        if (is_object($room_coordinator)) {
          $room_item['coordinator_id'] = $room_coordinator->uid;
        }
        else {
          global $conf;

          if (empty($conf['fcs_failsafe_coordinator']) || !is_integer($conf['fcs_failsafe_coordinator'])) {
            watchdog(MFCS_WATCHDOG_ID, "Failed to load 'fcs_failsafe_coordinator' settings. Your settings.php does not contain the failsafe coordinator user id.", array(), WATCHDOG_CRITICAL);
            $room_item['coordinator_id'] = 1; // as a last resort fall back to the default drupal admin account.
          }
          else {
            $room_item['coordinator_id'] = $conf['fcs_failsafe_coordinator'];
          }
        }

        // add/update the location.
        $query = db_select('mfcs_banner_locations', 'mbl');
        $query->addField('mbl', 'id', 'id');
        $query->condition('mbl.machine_name', $location_item['machine_name']);

        $location_id = $query->execute()->fetchField();
        $location_item['date'] = $instance;

        if ($location_item['disabled'] == 0) {
          if ($location_id > 0) {
            $query = db_update('mfcs_banner_locations');
            $query->fields($location_item);
            $query->condition('id', $location_id);
            $query->execute();
          }
          else {
            $query = db_insert('mfcs_banner_locations');
            $query->fields($location_item);
            $location_id = $query->execute();
          }
        }

        // add/update the building.
        $query = db_select('mfcs_banner_buildings', 'mbb');
        $query->addField('mbb', 'id', 'id');
        $query->condition('mbb.machine_name', $building_item['machine_name']);

        $building_id = $query->execute()->fetchField();
        $building_item['date'] = $instance;

        if ($building_item['disabled'] == 0) {
          if ($building_id > 0) {
            $query = db_update('mfcs_banner_buildings');
            $query->fields($building_item);
            $query->condition('id', $building_id);
            $query->execute();
          }
          else {
            $query = db_insert('mfcs_banner_buildings');
            $query->fields($building_item);
            $building_id = $query->execute();
          }
        }

        $room_item['building'] = $building_id;
        $room_item['date'] = $instance;

        // add/update the room.
        $query = db_select('mfcs_banner_rooms', 'mbr');
        $query->addField('mbr', 'id', 'id');
        $query->condition('mbr.machine_name', $room_item['machine_name']);
        $query->condition('mbr.building', $building_id);

        $room_id = $query->execute()->fetchField();

        if ($building_id > 0 && $room_item['disabled'] == 0) {
          if ($room_id > 0) {
            $query = db_update('mfcs_banner_rooms');
            $query->fields($room_item);
            $query->condition('id', $room_id);
            $query->execute();
          }
          else {
            $query = db_insert('mfcs_banner_rooms');
            $query->fields($room_item);
            $room_id = $query->execute();
          }
        }

        // add/update the location to building relations
        if ($location_id > 0 && $building_id > 0 && $location_item['disabled'] == 0 && $building_item['disabled'] == 0) {
          $location_to_building_item['location'] = $location_id;
          $location_to_building_item['building'] = $building_id;
          $location_to_building_item['disabled'] = 0;
          $location_to_building_item['date'] = $instance;

          $query = db_select('mfcs_banner_building_to_location', 'mbbl');
          $query->addExpression('count(mbbl.building)');
          $query->condition('mbbl.location', $location_id);
          $query->condition('mbbl.building', $building_id);

          $building_to_location_count = $query->execute()->fetchField();

          if ($building_to_location_count > 0) {
            $query = db_update('mfcs_banner_building_to_location');
            $query->fields($location_to_building_item);
            $query->condition('location', $location_id);
            $query->condition('building', $building_id);
            $query->execute();
          }
          else {
            $query = db_insert('mfcs_banner_building_to_location');
            $query->fields($location_to_building_item);
            $query->execute();
          }
        }
      }
    }

    // enforce transaction execution
    unset($transaction);
  }
  catch (Error $e) {
    $transaction->rollback();
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    $transaction->rollback();
    cf_error::on_exception($e);

    return FALSE;
  }


  $rows = mfcs_oracle_select('select distinct role from ucs.msu_event_role');

  if (!empty($rows) && is_array($rows)) {
    $transaction = db_transaction();
    try {
      $query = db_update('mfcs_banner_event_roles');
      $query->fields(array('disabled' => 1, 'date' => $instance));
      $query->condition('disabled', 0);
      $query->execute();

      foreach ($rows as $row) {
        if (!is_array($row)) {
          continue;
        }

        foreach ($row as $key => $role) {
          // oracle returns duplicate/redundant data in numeric rows.
          if (is_numeric($key)) continue;

          // add/update the role.
          $mfcs_banner_event_roles_item['machine_name'] = $role;
          $mfcs_banner_event_roles_item['disabled'] = 0;
          $mfcs_banner_event_roles_item['date'] = $instance;

          $query = db_select('mfcs_banner_event_roles', 'mber');
          $query->addExpression('count(mber.id)');
          $query->condition('mber.machine_name', $role);

          $mfcs_banner_event_roles_count = $query->execute()->fetchField();

          if ($mfcs_banner_event_roles_count > 0) {
            $query = db_update('mfcs_banner_event_roles');
            $query->fields($mfcs_banner_event_roles_item);
            $query->condition('machine_name', $role);
            $query->execute();
          }
          else {
            $query = db_insert('mfcs_banner_event_roles');
            $query->fields($mfcs_banner_event_roles_item);
            $query->execute();
          }
        }
      }

      // enforce transaction execution
      unset($transaction);
    }
    catch (Error $e) {
      $transaction->rollback();
      cf_error::on_exception($e);

      return FALSE;
    }
    catch (Exception $e) {
      $transaction->rollback();
      cf_error::on_exception($e);

      return FALSE;
    }
  }

  $result = mfcs_sync_banner_to_local_classes();
  if ($result === FALSE) {
    return FALSE;
  }

  return mfcs_sync_banner_to_local_users();
}

/**
 * Synchronizes the local database with the banner venue information for users.
 *
 * @param null|int $user_id
 *   (optional) If not NULL, the user id of the user to sync data from.
 *   When NULL, process all local users.
 * @param null|int $banner_id
 *   (optional) If not NULL, the banner id to load.
 *   When NULL, the banner id is auto-loaded from the user account.
 * @param bool $assign
 *   (optional) The data gets cached, but that does not been the cached data
 *   gets applied to each local user. Set this to TRUE to traverse each user
 *   in the system and update and save all role information.
 * @param bool $message_on_oracle_failure
 *   (optional) If TRUE, then the a message will be presented when unable to connect to the oracle database.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 *
 * @see: mfcs_search_for_and_mark_disabled_venue_coordinators_with_active_content()
 */
function mfcs_sync_banner_to_local_users($user_id = NULL, $banner_id = NULL, $message_on_oracle_failure = FALSE) {
  if (!is_null($user_id) && !cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  if (!is_null($banner_id) && !cf_is_integer($banner_id)) {
    cf_error::invalid_integer('banner_id');
    return FALSE;
  }

  if (!is_null($user_id) && is_null($banner_id)) {
    $user = user_load($user_id);

    if (!is_object($user) || !isset($user->field_user_banner_id['und'][0]) || !array_key_exists('value', $user->field_user_banner_id['und'][0])) {
      return FALSE;
    }

    $banner_id = $user->field_user_banner_id['und'][0]['value'];

    if (empty($banner_id) || !is_numeric($banner_id)) {
      return FALSE;
    }

    unset($user);
  }

  if (!is_bool($message_on_oracle_failure)) {
    cf_error::invalid_bool('message_on_oracle_failure');
    return FALSE;
  }

  $banner_ids_to_user_ids = mfcs_users_load_banner_id_to_user_id($banner_id);

  $instance = mfcs_instance();

  if (is_null($banner_id)) {
    $rows = mfcs_oracle_select('select id, role from ucs.msu_event_role');
  }
  else {
    $banner_id_string = mfcs_banner_id_int_to_string($banner_id);
    $rows = mfcs_oracle_select('select id, role from ucs.msu_event_role where id = \'' . $banner_id_string . '\'');
  }

  // failed to connect to oracle database.
  if ($rows === FALSE) {
    if ($message_on_oracle_failure) {
      drupal_set_message("Failed to connect to banner database.", 'error', FALSE);
    }
    return FALSE;
  }

  $current_user_id = $user_id;

  if (!empty($rows) && is_array($rows)) {
    $transaction = db_transaction();
    try {
      $query = db_select('mfcs_banner_event_roles', 'mber');
      $query->addField('mber', 'machine_name', 'role');
      $query->addField('mber', 'id', 'id');

      $roles_by_name = $query->execute()->fetchAllKeyed();

      $query = db_update('mfcs_banner_event_roles_to_users');
      $query->fields(array('disabled' => 1, 'date' => $instance));
      $query->condition('disabled', 0);

      if (!is_null($user_id)) {
        $query->condition('user_id', $user_id);
      }

      $query->execute();

      foreach ($rows as $row) {
        if (!is_array($row)) {
          continue;
        }

        if (!isset($roles_by_name[$row['role']])) {
          continue;
        }

        if (is_null($user_id)) {
          $current_user_id = NULL;
        }

        // add/update the roles to users.
        if (is_null($banner_id)) {
          if (isset($banner_ids_to_user_ids['banner'][$row['id']]['user_id'])) {
            $current_user_id = $banner_ids_to_user_ids['banner'][$row['id']]['user_id'];
          }
          elseif (isset($banner_ids_to_user_ids['banner'][$row['id']]) && !array_key_exists('user_id', $banner_ids_to_user_ids['banner'][$row['id']])) {
            // if the 'primary account' flag is not set, but exactly 1 account exists, then assume it is the primary account.
            if (!empty($banner_ids_to_user_ids['banner'][$row['id']]['others']) && count($banner_ids_to_user_ids['banner'][$row['id']]['others']) == 1) {
              $first = reset($banner_ids_to_user_ids['banner'][$row['id']]['others']);
              if (isset($first['user_id'])) {
                $current_user_id = $first['user_id'];
              }
            }
          }
        }

        if (!($current_user_id > 0)) {
          continue;
        }

        $mfcs_banner_event_roles_item['user_id'] = $current_user_id;
        $mfcs_banner_event_roles_item['event_role_id'] = $roles_by_name[$row['role']];
        $mfcs_banner_event_roles_item['disabled'] = 0;
        $mfcs_banner_event_roles_item['date'] = $instance;

        $query = db_select('mfcs_banner_event_roles_to_users', 'mberu');
        $query->addExpression('count(mberu.user_id)');
        $query->condition('mberu.user_id', $current_user_id);
        $query->condition('mberu.event_role_id', $roles_by_name[$row['role']]);

        $mfcs_banner_event_roles_count = $query->execute()->fetchField();

        if ($mfcs_banner_event_roles_count > 0) {
          $query = db_update('mfcs_banner_event_roles_to_users');
          $query->fields($mfcs_banner_event_roles_item);
          $query->condition('user_id', $current_user_id);
          $query->condition('event_role_id', $roles_by_name[$row['role']]);
          $query->execute();
        }
        else {
          $query = db_insert('mfcs_banner_event_roles_to_users');
          $query->fields($mfcs_banner_event_roles_item);
          $query->execute();
        }
      }

      // enforce transaction execution
      unset($transaction);
    }
    catch (Error $e) {
      $transaction->rollback();

      cf_error::on_exception($e, WATCHDOG_ERROR);

      return FALSE;
    }
    catch (Exception $e) {
      $transaction->rollback();

      cf_error::on_exception($e, WATCHDOG_ERROR);

      return FALSE;
    }
  }

  // once banner sync is complete, check for disabled accounts.
  mfcs_search_for_and_mark_disabled_venue_coordinators_with_active_content();

  return TRUE;
}

/**
 * Synchronizes the local database with the banner information for classes.
 *
 * For performance reasons, the table 'mfcs_banner_classes' does not store the
 * disabled/enabled status and date. Instead, on sync all entries are deleted
 * and then fully restored.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_sync_banner_to_local_classes() {
  $instance = mfcs_instance();

  $year = date("Y");
  $year_next = $year + 1;
  $year_stamp = strtotime("midnight Jan 1, " . $year);

  $buildings = mfcs_load_rooms();
  $rooms = mfcs_load_rooms();

  if (empty($buildings) || empty($rooms)) {
    // if there are no buildings or no rooms, then there can be no classes.
    return TRUE;
  }


  $classes_query = 'select ssrmeet_start_date, ssrmeet_end_date, ssrmeet_begin_time, ssrmeet_end_time, ';
  $classes_query .= 'ssrmeet_bldg_code, ssrmeet_room_code, ssrmeet_mon_day, ssrmeet_tue_day, ';
  $classes_query .= 'ssrmeet_wed_day, ssrmeet_thu_day, ssrmeet_fri_day, ssrmeet_sat_day, ssrmeet_sun_day, ';
  $classes_query .= 'ssbsect_subj_code, ssbsect_crse_numb ';
  $classes_query .= 'from ssvmeet sm ';

  $classes_query .= 'where (ssrmeet_term_code like \'' . $year . '%\' or ssrmeet_term_code like \'' . $year_next . '%\')';
  $classes_query .= 'and not ssrmeet_begin_time is NULL ';
  $classes_query .= 'and not ssrmeet_end_time is NULL ';

  $classes_query .= 'and ssrmeet_bldg_code in (';
  $count = 0;
  $buildings_total = count($buildings);
  $buildings_list = array();
  foreach ($buildings as $building) {
    $buildings_list[$building->building_id] = $building->building_code;

    $classes_query .= '\'' . $building->building_code . '\'';
    $count++;

    if ($count < $buildings_total) {
      $classes_query .= ', ';
    }
  }
  $classes_query .= ') ';
  $classes_query .= 'order by ssrmeet_start_date asc';

  $classes = mfcs_oracle_select($classes_query);

  $banner_to_local_weekdays = array(
    'sunday' => 'ssrmeet_sun_day',
    'monday' => 'ssrmeet_mon_day',
    'tuesday' => 'ssrmeet_tue_day',
    'wednesday' => 'ssrmeet_wed_day',
    'thursday' => 'ssrmeet_thu_day',
    'friday' => 'ssrmeet_fri_day',
    'saturday' => 'ssrmeet_sat_day',
  );


  $transaction = db_transaction();
  try {
    // permanently remove all classes and restart the sequence.
    $query = db_delete('mfcs_banner_classes');
    $query->execute();

    // do not restart the sequence, instead make sure the sequence has 'cycle' such that this restart can be avoided.
    // the restart is impossible because postgresql only allows the owner to restart the sequence and providing such an owner is to be avoided.
    #db_query('ALTER SEQUENCE {mfcs_banner_classes_id_seq} RESTART');

    // process all of the classes and add new reservations or remove the 'deleted' status to existing reservations.
    if (!empty($classes)) {
      foreach ($classes as $class) {
        $start_stamp = strtotime($class['ssrmeet_start_date']);
        $stop_stamp = strtotime($class['ssrmeet_end_date']);

        $start_time_string = implode(':', str_split($class['ssrmeet_begin_time'], 2));
        $stop_time_string = implode(':', str_split($class['ssrmeet_end_time'], 2));

        // search the system by both building code and room code.
        $class_room = FALSE;
        foreach ($rooms as $room) {
          if ($class['ssrmeet_room_code'] != $room->room_number) continue;

          if ($class['ssrmeet_bldg_code'] == $room->building_code) {
            $class_room = $room->room_id;
             break;
          }
        }
        if ($class_room === FALSE) {
          continue;
        }

        $class_base = array(
          'room' => $class_room,
        );

        foreach ($banner_to_local_weekdays as $weekday => $banner_weekday) {
          if (!empty($class[$banner_weekday])) {
            $stamp_day = strtotime("this " . $weekday, $start_stamp);

            while ($stamp_day <= $stop_stamp) {
              $stamp_day_string = date("Y/m/d ", $stamp_day);
              $stamp_time_start = strtotime($stamp_day_string . $start_time_string);
              $stamp_time_stop = strtotime($stamp_day_string . $stop_time_string);

              $class_fields = $class_base;
              $class_fields['reserved_day'] = $stamp_day;
              $class_fields['reserved_time_start'] = $stamp_time_start;
              $class_fields['reserved_time_stop'] = $stamp_time_stop;

              $query = db_insert('mfcs_banner_classes');
              $query->fields($class_fields);
              $query->execute();

              $stamp_day = strtotime("next " . $weekday, $stamp_day);
            }
          }
        }
      }
    }

    // enforce transaction execution
    unset($transaction);
  }
  catch (Error $e) {
    $transaction->rollback();
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    $transaction->rollback();
    cf_error::on_exception($e);

    return FALSE;
  }

  return TRUE;
}

/**
 * Executes the cron queue to recreate the oracle cache.
 *
 * This requires the ultimate_cron module to function.
 *
 * @see: mfcs_cronapi()
 */
function mfcs_oracle_recache_cron() {
  mfcs_set_using_effective_system_id();

  mfcs_sync_banner_to_local();
}

/**
 * Executes the cron queue to send out insurance not provided reminders.
 *
 * This requires the ultimate_cron module to function.
 *
 * @see: mfcs_cronapi()
 */
function mfcs_insurance_not_provided_alert_cron() {
  mfcs_set_using_effective_system_id();

  mfcs_include(MFCS_INCLUDE_WORKFLOW);

  $system_user = user_load(1);

  $parameters = array();
  $parameters['changed_by'] = $system_user->uid;
  $parameters['changed_type'] = 'system';
  $parameters['reminder'] = TRUE;
  $parameters['reminder_reason'] = 'insurance_provided';

  $processed = array(
    MFCS_REMINDER_INTERVAL_DAY_30 => array(),
  );

  $dates = mfcs_request_reminders_get_dates();

  foreach ($processed as $interval => &$processed_values) {
    if ($interval == MFCS_REMINDER_INTERVAL_DAY_30) {
      $from = strtotime('+30 days', $dates['today']);
      $to = strtotime('tomorrow', $from);

      $parameters['message_priority'] = MFCS_MAIL_PRIORITY_HIGH;
    }
    else {
      continue;
    }

    mfcs_clear_request_reminders(MFCS_REMINDER_TYPE_INSURANCE_NOT_PROVIDED);

    $results = mfcs_get_requests_not_providing_insurance($from, $to);
    if (!empty($results)) {
      $sent = array();

      foreach ($results as $result) {
        if (array_key_exists($result->id, $processed_values)) {
          continue;
        }

        $reminders = mfcs_get_request_reminders($dates, MFCS_REMINDER_TYPE_INSURANCE_NOT_PROVIDED, $interval, $result->id);

        // if the reminder has already been sent, do not resend.
        if (isset($reminders[$interval][$result->id])) {
          continue;
        }

        // create a new instance for every reminder e-mail.
        mfcs_instance(TRUE);

        $parameters['reminder_data'] = $result;
        $parameters['reminder_data']->interval = $interval;
        mfcs_send_workflow_emails($result->id, $parameters);

        $sent[$result->id] = array(
          'request_id' => $result->id,
          'date' => $dates['today'],
          'type' => MFCS_REMINDER_TYPE_INSURANCE_NOT_PROVIDED,
          'interval' => $interval,
        );

        $processed_values[$result->id] = $result->id;
        unset($parameters['reminder_data']);
      }

      foreach ($sent as $reminder) {
        mfcs_save_request_reminders($reminder);
      }
    }
  }
}

/**
 * Executes the cron queue to cancel requests older than the current day.
 *
 * This requires the ultimate_cron module to function.
 *
 * @see: mfcs_cronapi()
 */
function mfcs_autocancel_old_requests_cron() {
  mfcs_set_using_effective_system_id();

  $status = array(
    MFCS_REQUEST_STATUS_UNLOCKED,
    MFCS_REQUEST_STATUS_LOCKED,
  );

  $date = strtotime('midnight today');

  $unresolved_requests = array();

  try {
    $query = db_select('mfcs_requests', 'mer');

    $query->innerJoin('mfcs_current', 'mc', 'mer.id = mc.request_id');
    $query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mc.request_id = mfdd.request_id AND mc.dates_date = mfdd.revision');

    $query->addField('mer', 'id', 'id');

    $query->condition('mer.status', $status, 'IN');
    $query->condition('mfdd.value', $date, '<');
    $query->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.

    $query->distinct();

    $unresolved_requests = $query->execute()->fetchAllAssoc('id');
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return;
  }

  if (empty($unresolved_requests)) {
    return;
  }

  // cron jobs are considered to have been executed by the admin account as far as logs are concerned.
  $system_user = user_load(1);

  mfcs_include(MFCS_INCLUDE_WORKFLOW);

  foreach ($unresolved_requests as $request_id => $request_object) {
    // create a new instance for every unresolved request.
    mfcs_instance(TRUE);

    $cancelled = mfcs_workflow_set_status($request_id, MFCS_REQUEST_STATUS_CANCELLED, $system_user);

    if ($cancelled) {
      $message = "One or more dates associated with the request are now in the past.";
      mfcs_workflow_step_review($request_id, $system_user, MFCS_REVIEW_DECISION_CANCELLED, MFCS_REVIEW_RESTRICTIONS_MANAGERS, $message);

      $parameters = array();
      $parameters['changed_by'] = $system_user->uid;
      $parameters['changed_type'] = 'user';
      $parameters['cancelled'] = TRUE;
      $parameters['auto-cancelled'] = TRUE;
      $parameters['auto-cancelled-reason'] = $message;
      mfcs_send_workflow_emails($request_id, $parameters);
    }
    else {
      watchdog(MFCS_WATCHDOG_ID, "An error occured while trying to auto-cancel the request: @request_id.", array('@request_id' => $request_id), WATCHDOG_ERROR);
    }
  }
}

/**
 * Executes the cron queue to block accounts lacking the proper banner roles.
 *
 * An exception to this are the accounts defined in the settings array
 * 'fcs_no_auto_block_accounts'.
 *
 * @see: mfcs_cronapi()
 */
function mfcs_auto_block_accounts_cron() {
  mfcs_set_using_effective_system_id();

  global $conf;

  $no_auto_block_accounts = array();
  if (isset($conf['fcs_no_auto_block_accounts']) && is_array($conf['fcs_no_auto_block_accounts'])) {
    $no_auto_block_accounts = $conf['fcs_no_auto_block_accounts'];
  }

  $transaction = NULL;
  try {
    // using PostgresSQL's WITH clause because it is much faster.
    $sql = "with admin_or_exception as (select ur.uid from users_roles ur inner join role r ON ur.rid = r.rid where (r.name IN ('administrator', 'bannerless exception'))), ";
    $sql .= "banner_user_roles as (select mberu.user_id AS user_id from mfcs_banner_event_roles_to_users mberu where mberu.disabled = 0) ";

    $sql .= "select u.uid as user_id, fdfubi.field_user_banner_id_value as banner_id, u.name AS name from users u ";
    $sql .= "left outer join field_data_field_user_banner_id fdfubi on u.uid = fdfubi.entity_id ";

    // do not process anonymous
    $sql .= "where (u.uid <> 0) ";

    // do not process system admin account
    $sql .= "and (u.uid <> 1) ";

    // only check enabled accounts
    $sql .= "and (u.status = 1) ";

    // ignore manually disabled accounts by name.
    $sql .= "and (u.name not in (:no_auto_block_accounts)) ";

    // the user must not have any banner roles to be auto-blocked.
    $sql .= "and (u.uid not in (select * from banner_user_roles bur where bur.user_id = u.uid)) ";

    // the user must not have any drupal administer or bannerless exception roles to be auto-blocked.
    $sql .= "and (u.uid not in (select * from admin_or_exception aoe)) ";

    $users = db_query($sql, array(':no_auto_block_accounts' => $no_auto_block_accounts))->fetchAll();

    if (empty($users)) return;

    // using user_load() is not the most efficient way, but it works and functions like mfcs_synchronize_user_settings() expect a user object.
    $transaction = db_transaction();
    foreach ($users as $u) {
      watchdog(MFCS_WATCHDOG_ID, "Auto-blocking the user @user (@user_id) and removing all existing roles, reason: Not in appropriate banner groups or local admin groups.", array('@user' => $u->name, '@user_id' => $u->user_id), WATCHDOG_INFO);

      $block_query = db_update('users');
      $block_query->fields(array('status' => 0));
      $block_query->condition('uid', $u->user_id);
      $block_query->execute();

      $delete_query = db_delete('users_roles');
      $delete_query->condition('uid', $u->user_id);
      $delete_query->execute();
    }
    unset($transaction);
  }
  catch (Error $e) {
    if (is_object($transaction)) $transaction->rollback();
    cf_error::on_query_execution($e);
  }
  catch (Exception $e) {
    if (is_object($transaction)) $transaction->rollback();
    cf_error::on_query_execution($e);
  }
}

/**
 * Executes the cron queue to scan requests looking for known problem situations.
 *
 * @see: mfcs_cronapi()
 * @see: mfcs_mischellaneous_check_requests_for_problems()
 */
function mfcs_check_for_problems_requests_cron() {
  mfcs_set_using_effective_system_id();

  mfcs_include(MFCS_INCLUDE_MISCELLANEOUS);
  mfcs_mischellaneous_check_requests_for_problems();
}

/***
 * Convert a given value to the appropraite database format.
 *
 * @param string $value
 *   The date or time string to convert.
 * @param string $method
 *   The method to use for converting.
 * @param string|array $option
 *   (optional) Additional options to pass to the method for conversion.
 * @param array $form_state
 *   (optional) The form state array, containing all available values.
 * @param array $delta
 *   (optional) The delta location for processing data of the same delta.
 *
 * @return
 *   The appropriate datatype suitable for storing into the database.
 *   FALSE is returned on error.
 */
function mfcs_convert_value_to_database_format($value, $method, $option = array(), $form_state = array(), $delta = array()) {
  if ($method == 'timestamp') {
    if (empty($value)) {
      return FALSE;
    }

    if (array_key_exists('relative_to', $option) && is_string($option['relative_to']) && !empty($option['relative_to'])) {
      if (!is_array($form_state) || !array_key_exists('values', $form_state)) {
        return FALSE;
      }

      $current = &$form_state['values'];

      $parts = explode('][', $option['relative_to']);
      foreach ($parts as $part) {
        if (is_array($current) && array_key_exists($part, $current)) {
          $current = &$current[$part];
        }
        else {
          return FALSE;
        }
      }

      if (is_array($current) && array_key_exists($delta, $current)) {
        $current = &$current[$delta];
      }
      else {
        return FALSE;
      }

      $date_stamp = strtotime($current, 0);
      return strtotime($value, $date_stamp);
    }

    return strtotime($value);
  }
  elseif ($method == 'timestamp_relative') {
    if (empty($value)) {
      return FALSE;
    }

    return strtotime($value, 0);
  }
  elseif ($method == 'date_popup') {
    if (!is_string($value) || empty($value)) {
      return FALSE;
    }

    // force the date to begin at the earlies time in the day.
    $date_stamp = strtotime($value);
    $date = date("Y/m/d", $date_stamp);
    return strtotime($date, 0);
  }
  elseif ($method == 'date_month') {
    if (!is_string($value) || empty($value)) {
      return FALSE;
    }

    $date_stamp = strtotime($value);
    return (int) date("m", $date_stamp);
  }
  elseif ($method == 'date_day') {
    if (!is_string($value) || empty($value)) {
      return FALSE;
    }

    $date_stamp = strtotime($value);
    return (int) date("d", $date_stamp);
  }
  elseif ($method == 'currency') {
    if (is_null($value)) {
      return FALSE;
    }

    // shift decimal over to digits.
    return floor($value * 100);
  }

  return FALSE;
}

/***
 * Convert a given value to the appropraite database format.
 *
 * @param string $value
 *   The date or time string to convert.
 * @param string $method
 *   The method to use for converting.
 * @param string|array $option
 *   (optional) Additional options to pass to the method for conversion.
 *
 * @return
 *   The appropriate datatype suitable for storing into the database.
 *   FALSE is returned on error.
 */
function mfcs_convert_value_from_database_format($value, $method, $option = array()) {
  if ($method == 'timestamp') {
    if (empty($value)) return NULL;

    return date($option['view'], $value);
  }
  elseif ($method == 'timestamp_relative') {
    if (empty($value)) return NULL;

    return date($option['view'], $value);
  }
  elseif ($method == 'date_popup') {
    if (empty($value)) return NULL;

    return date('Y-m-d', $value);
  }
  elseif ($method == 'date_month') {
    if (empty($value)) return NULL;

    return $value;
  }
  elseif ($method == 'date_day') {
    if (empty($value)) return NULL;

    return $value;
  }
  elseif ($method == 'currency') {
    if (is_null($value)) return NULL;

    return $value / 100;
  }

  return FALSE;
}

/**
 * Loads an request by its ID.
 *
 * @param int|null $request_id
 *   The numeric request id. Can be null when $reset_action is FALSE.
 * @param bool $reset_action
 *   (optional) If TRUE, the cache for the specified request is reset.
 *   If FALSE, the cache is reset, but no request is loaded.
 *   If NULL, no reset is performed.
 * @param int|NULL $revision_id
 *   (optional) If not NULL, this essentially loads all values for a given
 *   revision.
 *
 * @return array|bool
 *   An array of values associated with the request id.
 *   FALSE is returned on error.
 *   An empty array is returned when there is no request by that id.
 *   TRUE is returned when $reset_action is FALSE because there will ne no
 *   request to return.
 */
function mfcs_load_request_by_id($request_id, $reset_action = NULL, $revision_id = NULL) {
  if (!cf_is_integer($request_id) || $request_id < 0) {
    if (!($reset_action === FALSE && is_null($request_id))) {
      cf_error::invalid_integer('request_id');
      return FALSE;
    }
  }

  if (!is_null($reset_action) && !is_bool($reset_action)) {
    cf_error::invalid_bool('reset_action');
    return FALSE;
  }

  if (!is_null($revision_id) && (!cf_is_integer($revision_id) || $revision_id < 0)) {
    cf_error::invalid_integer('revision_id');
    return FALSE;
  }

  $cache_id = __function__;
  $cached_requests = &drupal_static($cache_id, array());
  if (is_null($reset_action) && array_key_exists($request_id, $cached_requests)) {
    if (is_null($revision_id)) {
      if (array_key_exists('latest', $cached_requests[$request_id])) {
        return $cached_requests[$request_id]['latest'];
      }
    }
    else {
      if (array_key_exists($revision_id, $cached_requests[$request_id])) {
        return $cached_requests[$request_id][$revision_id];
      }
    }
  }
  elseif ($reset_action === FALSE) {
    if (is_null($request_id)) {
      $cached_requests = array();
    }
    else {
      unset($cached_requests[$request_id]);
    }

    return TRUE;
  }

  // caching these results can use a lot of memory, so put a hard limit on caching at most 3 at a time.
  if (is_array($cached_requests) && count($cached_requests) > 3) {
    $cached_requests = array();
  }
  // the 'latest' array takes up an array key, so this will have a hard limit of "4" that ends up representing "3".
  elseif (array_key_exists($request_id, $cached_requests) && count($cached_requests[$request_id]) > 4) {
    $cached_requests[$request_id] = array();
  }

  mfcs_include(MFCS_INCLUDE_TABLE);

  $request = array();
  $structure = mfcs_table_structure();

  try {
    $query = db_select('mfcs_requests', 'mer');
    $query->fields('mer');
    $query->condition('id', $request_id);

    $query->innerJoin('mfcs_request_revisions', 'mrv', 'mer.id = mrv.request_id');
    $query->addField('mrv', 'revision', 'revision');
    $query->addField('mrv', 'date', 'revision_date');
    $query->addField('mrv', 'message', 'revision_message');

    if (!is_null($revision_id)) {
      $query->condition('mrv.revision', $revision_id);
    }

    $results = $query->execute()->fetchAll();

    if (empty($results)) {
      return array();
    }

    $mer = array_pop($results);
    $revision_date = NULL;

    // manually add the request information and presentation fields.
    if (!isset($request['mer'])) {
      $request['mer'] = array();
      foreach (array('id', 'user_id', 'created', 'updated', 'revision', 'revision_message') as $key) {
        $request['mer'][$key] = array(0 => new stdClass());
        $request['mer'][$key][0]->value = $mer->{$key};
      }

      if (property_exists($mer, 'revision_date')) {
        $revision_date = $mer->revision_date;
        $request['mer']['updated'][0]->value = $revision_date;
      }
    }

    unset($mer);

    $query = db_select('mfcs_current', 'mc');
    $query->condition('mc.request_id', $request_id);
    $query->fields('mc');

    $current = $query->execute()->fetchObject();
    $request['current'] = array();

    if (!is_object($current)) {
      return FALSE;
    }

    foreach ($structure as $table_name => &$fields) {
      if (!array_key_exists($table_name, $request)) {
        $request[$table_name] = array();
      }

      if (!array_key_exists($table_name, $request['current'])) {
        $request['current'][$table_name] = array();
      }

      foreach ($fields as $field_name => &$field_values) {
        $current_name = $table_name . '_' . $field_name;
        if (is_null($revision_id)) {
          if (property_exists($current, $current_name)) {
            $request['current'][$table_name][$field_name] = $current->{$current_name};
          }
        }
        else {
          if (property_exists($current, $current_name)) {
            $request['current'][$table_name][$field_name] = $current->{$current_name};
          }

          $query = db_select('mfcs_field_' . $current_name, 'mftf');
          $query->addField('mftf', 'revision', 'revision');
          $query->condition('mftf.request_id', $request_id);
          $query->condition('mftf.date', $revision_date, '<=');
          $query->orderBy('mftf.date', 'DESC');
          $query->range(0, 1);

          $result = $query->execute()->fetchField();

          if ($result !== FALSE) {
            $request['current'][$table_name][$field_name] = $result;
            $current->{$current_name} = $result;
          }
        }

        if (isset($structure[$table_name][$field_name]['storage']) && $structure[$table_name][$field_name]['storage'] == 'alternate' && array_key_exists('alternate', $structure[$table_name][$field_name])) {
          foreach ($structure[$table_name][$field_name]['alternate'] as $alternate_name => &$alternate_data) {
            $field_table_name = 'mfcs_field_' . $table_name . '_' . $alternate_name;
            $current_name = $table_name . '_' . $alternate_name;

            if (property_exists($current, $current_name)) {
              $request['current'][$table_name][$field_name] = $current->{$current_name};
            }

            $query = db_select($field_table_name, 'mftf');
            $query->condition('mftf.request_id', $request_id);
            $query->condition('mftf.revision', $current->{$current_name});
            $query->fields('mftf');

            $results = $query->execute()->fetchAll();

            if (empty($results)) {
              $request[$table_name][$alternate_name] = array();
            }
            else {
              $request[$table_name][$alternate_name] = $results;
            }
          }
        }
        else {
          $field_table_name = 'mfcs_field_' . $current_name;

          $query = db_select($field_table_name, 'mftf');
          $query->condition('mftf.request_id', $request_id);
          $query->condition('mftf.revision', $current->{$current_name});
          $query->fields('mftf');

          $results = $query->execute()->fetchAll();

          if (empty($results)) {
            $request[$table_name][$field_name] = array();
          }
          else {
            $request[$table_name][$field_name] = $results;
          }
        }

        unset($results);
        unset($query);
      }

      unset($results);
      unset($query);
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  if (empty($request)) {
    watchdog(MFCS_WATCHDOG_ID, "Unable to find request with id of @request_id.", array('@request_id' => $request_id), WATCHDOG_ERROR);
    return FALSE;
  }

  if (!is_null($revision_id)) {
    if (is_null($revision_date)) {
      watchdog(MFCS_WATCHDOG_ID, "Unable to find request with id of @request_id and revision id of @revision_id.", array('@request_id' => $request_id, '@revision_id' => $revision_id), WATCHDOG_ERROR);
      return FALSE;
    }

    $cached_requests[$request_id][$revision_id] = &$request;

    return $cached_requests[$request_id][$revision_id];
  }

  $cached_requests[$request_id]['latest'] = &$request;

  return $cached_requests[$request_id]['latest'];
}

/**
 * Loads request with fields matching a revision timestamp.
 *
 * @param int $request_id
 *   The numeric request id.
 * @param int $timestamp
 *   Unix Timestamp representing the exact date and time to load.
 * @param int|null $revision_user_id
 *   The user id of the user responsible for the revision at a given timestamp.
 *   This is ignored when nearest = TRUE and in such a case may be null.
 *   When nearest is FALSE, this must not be NULL.
 * @param array $desired_fields
 *   (optional) An array of field names to load that match the specified date.
 *   These are nested by their table structure. When an empty array is
 *   provided, all values are used.
 * @param bool $nearest
 *   (optional) When TRUE, will load either the values by the specified
 *   timestamp or the revision immediately closest to the timestamp.
 *
 * @return array|bool
 *   An array of values associated with the request, date, and fields.
 *   FALSE is returned on error.
 *
 * @see: mfcs_table_structure()
 */
function mfcs_load_request_by_timestamp($request_id, $timestamp, $revision_user_id, $desired_fields = array(), $nearest = FALSE) {
  if (!cf_is_integer($request_id) || $request_id < 0) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  if (!cf_is_integer($timestamp)) {
    cf_error::invalid_integer('timestamp');
    return FALSE;
  }

  if (!is_null($revision_user_id) && !cf_is_integer($revision_user_id)) {
    cf_error::invalid_integer('revision_user_id');
    return FALSE;
  }

  if (!is_array($desired_fields)) {
    cf_error::invalid_array('desired_fields');
    return FALSE;
  }

  if (!is_bool($nearest)) {
    cf_error::invalid_bool('nearest');
    return FALSE;
  }

  // revision_user_id cannot be NULL when nearest is FALSE.
  if (is_null($revision_user_id) && !$nearest) {
    cf_error::invalid_integer('revision_user_id');
    return FALSE;
  }

  mfcs_include(MFCS_INCLUDE_TABLE);

  $request = array();
  $structure = mfcs_table_structure();

  // filter out all fields that were not requested.
  if (!empty($desired_fields)) {
    foreach ($structure as $table_name => &$fields) {
      if (!array_key_exists($table_name, $desired_fields)) {
        unset($structure[$table_name]);
        continue;
      }

      // if $fields is empty, then allow all fields.
      // otherwise, only allow fields defined in $fields.
      if (!empty($fields)) {
        foreach ($fields as $field_name => &$field_values) {
          if (!in_array($field_name, $desired_fields[$table_name])) {
            unset($structure[$table_name][$field_name]);
            continue;
          }
        }
      }
    }
  }

  try {
    $request['current'] = array();
    foreach ($structure as $table_name => &$fields) {
      if (!array_key_exists($table_name, $request)) {
        $request[$table_name] = array();
      }

      $request['current'][$table_name] = array();

      foreach ($fields as $field_name => &$field_values) {
        if (isset($structure[$table_name][$field_name]['storage']) && $structure[$table_name][$field_name]['storage'] == 'alternate' && array_key_exists('alternate', $structure[$table_name][$field_name])) {
          foreach ($structure[$table_name][$field_name]['alternate'] as $alternate_name => &$alternate_data) {
            $field_table_name = 'mfcs_field_' . $table_name . '_' . $alternate_name;

            $query = db_select($field_table_name, 'mftf');
            $query->condition('mftf.request_id', $request_id);

            if (!is_null($revision_user_id)) {
              $query->condition('mftf.user_id', $revision_user_id);
            }

            $query->fields('mftf');

            if ($nearest) {
              $query->condition('mftf.date', $timestamp, '<=');
              $query->range(0, 1);
              $query->orderby('mftf.revision', 'DESC');
            }
            else {
              $query->condition('mftf.date', $timestamp);
              $query->condition('mftf.user_id', $revision_user_id);
            }

            $results = $query->execute()->fetchAll();

            if (empty($results)) {
              $request[$table_name][$alternate_name] = array();

              $request['current'][$table_name][$field_name] = NULL;
            }
            else {
              $request[$table_name][$alternate_name] = $results;

              $first_result = reset($results);
              $request['current'][$table_name][$field_name] = $first_result->revision;
            }
          }
        }
        else {
          $field_table_name = 'mfcs_field_' . $table_name . '_' . $field_name;

          $query = db_select($field_table_name, 'mftf');
          $query->condition('mftf.request_id', $request_id);
          $query->fields('mftf');

          if ($nearest) {
            $query->condition('mftf.date', $timestamp, '<=');
            $query->range(0, 1);
            $query->orderby('mftf.revision', 'DESC');
          }
          else {
            $query->condition('mftf.date', $timestamp);
            $query->condition('mftf.user_id', $revision_user_id);
          }

          $results = $query->execute()->fetchAll();

          if (empty($results)) {
            $request[$table_name][$field_name] = array();

            $request['current'][$table_name][$field_name] = NULL;
          }
          else {
            $request[$table_name][$field_name] = $results;

            $first_result = reset($results);
            $request['current'][$table_name][$field_name] = $first_result->revision;
          }
        }

        unset($results);
        unset($query);
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  return $request;
}

/**
 * Loads the request revision number.
 *
 * @param int $request_id
 *   The numeric request id.
 * @param string $table_field_name
 *   (optional) The name of a specific table to load a revision number from.
 *   When not specified, this returns the latest revision number of a given
 *   request.
 *
 * @return int|bool
 *  FALSE is returned on error.
 *  NULL is returned when there is no existing revision number.
 */
function mfcs_load_request_revision_number($request_id, $table_field_name = NULL) {
  if (!cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  if (is_null($table_field_name)) {
    try {
      $query = db_select('mfcs_request_revisions', 'mrv');
      $query->addField('mrv', 'revision', 'revision');
      $query->condition('mrv.request_id', $request_id);
      $query->orderBy('mrv.revision', 'DESC');
      $query->range(0, 1);

      $field = $query->execute()->fetchfield();

      if ($field === FALSE) {
        return NULL;
      }

      return $field;
    }
    catch (Error $e) {
      cf_error::on_query_execution($e);
    }
    catch (Exception $e) {
      cf_error::on_query_execution($e);
    }

    return FALSE;
  }

  if (!is_string($table_field_name)) {
    cf_error::invalid_string('table_field_name');
    return FALSE;
  }

  try {
    $query = db_select($table_field_name, 'tfn');
    $query->fields('tfn', array('revision'));
    $query->condition('tfn.request_id', $request_id);
    $query->orderBy('tfn.revision', 'DESC');
    $query->range(0, 1);

    $result = $query->execute()->fetchField();

    return $result;
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  return FALSE;
}

/**
 * Loads a system user by its Banner ID.
 *
 * @param int $banner_id
 *   The numeric banner id.
 * @param bool $reset
 *   (optional) If TRUE, the cache for the specified user is reset.
 *
 * @return object|null|bool
 *   The
 *   FALSE is returned on error.
 *   An empty array is returned when there is no request by that id.
 */
function mfcs_load_user_by_banner_id($banner_id, $reset = FALSE) {
  if (!cf_is_integer($banner_id)) {
    cf_error::invalid_integer('banner_id');
    return FALSE;
  }

  $cache_id = __function__;
  $cached_user = &drupal_static($cache_id, NULL);
  if (!$reset && is_array($cached_user) && array_key_exists($banner_id, $cached_user)) {
    return $cached_user[$banner_id];
  }

  $banner_id_string = mfcs_banner_id_int_to_string($banner_id);

  try {
    $query = db_select('users', 'u');

    $query->innerJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
    $query->innerJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND fdfuln.delta = 0');
    $query->innerJoin('field_data_field_user_banner_id', 'fdfubi', 'u.uid = fdfubi.entity_id AND fdfubi.delta = 0');

    $query->addField('u', 'uid', 'user_id');
    $query->addField('u', 'name', 'name');
    $query->addField('u', 'created', 'created');
    $query->addField('u', 'status', 'status');
    $query->addField('u', 'mail', 'email');

    $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
    $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');
    $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

    $query->condition('field_user_banner_id_value', $banner_id_string);

    $results = $query->execute()->fetchAll();
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  if (empty($results)) {
    return NULL;
  }

  $cached_user[$banner_id] = array_pop($results);

  return $cached_user[$banner_id];
}

/**
 * Build the table structure for saving new or existing information.
 *
 * @param array $structure
 *   Describes how the secondary tables are populated and processed.
 * @param array $structure_current
 *   The 'current' table with the fields to be updated.
 * @param array $structure_field_tables
 *   A collection of 'field' tables to create or update.
 * @param string $table_name
 *   Name of the current table being processed.
 * @param string $field_name
 *   Name of the current field being processed.
 * @param string $db_table_field
 *   The name of the 'field' table as defined the SQL database.
 * @param array $user_data
 *   An array of user related information:
 *   - 'user_id': The users ID.
 * @param array $form_state
 *   The form state for advanced processing of fields that depend on other
 *   fields when they are converted into the database format.
 * @param array|null $request
 *   (optional) When NULL, this created tables are new tables.
 *   When an array, the created tables are updates to existing values.
 *   The array should be populated by mfcs_load_request_by_id().
 *
 * @see: mfcs_table_structure()
 * @see: mfcs_load_request_by_id()
 */
function mfcs_build_table_structure($structure, &$structure_current, &$structure_field_tables, $table_name, $field_name, $db_table_field, $user_data, $values, $form_state, $request = NULL) {
  $instance = mfcs_instance();

  if (is_null($request)) {
    $request_id = NULL;
    $revision = 0;
  }
  else {
    $request_id = $request['mer']['id'][0]->value;

    $revision = mfcs_load_request_revision_number($request_id, $db_table_field);
    if ($revision === FALSE) {
      watchdog(MFCS_WATCHDOG_ID, "Failed to load revision number for request %request_id while building the table structure, forcing revision number to be 0.", array('%request_id' => $request_id), WATCHDOG_ERROR);
      $revision = 0;
    }
    elseif (is_null($revision)) {
      $revision = 0;
    }
    else {
      $revision++;
    }
  }

  if (!isset($structure_field_tables[$db_table_field])) {
    $structure_field_tables[$db_table_field] = array();
  }

  if (array_key_exists('storage', $structure[$table_name][$field_name])) {
    if (!is_string($structure[$table_name][$field_name]['storage']) || empty($structure[$table_name][$field_name]['storage'])) {
      watchdog(MFCS_WATCHDOG_ID, "Invalid storage structure specification for the field %field_name in the table %table_name. This must be a non-empty string.", array('%field_name' => $field_name, '%table_name' => $table_name), WATCHDOG_ERROR);
      return;
    }

    $storage_key = $structure[$table_name][$field_name]['storage'];
    if (!array_key_exists($storage_key, $structure[$table_name][$field_name]) || empty($structure[$table_name][$field_name][$storage_key])) {
      watchdog(MFCS_WATCHDOG_ID, "The storage key %storage_key was not found in the structure specification for the field %field_name in the table %table_name. This must be a non-empty string.", array('%storage_key' => $storage_key, '%field_name' => $field_name, '%table_name' => $table_name), WATCHDOG_ERROR);
      return;
    }

    // alternate is used for handling fields that are stored in multiple separate tables.
    if ($storage_key == 'alternate') {
      unset($structure_current[$table_name . '_' . $field_name]);
      unset($structure_field_tables[$db_table_field]);

      foreach ($values as $delta => $value) {
        $alternate_values = array();
        if (!empty($structure[$table_name][$field_name]['alternate_method'])) {
          foreach ($structure[$table_name][$field_name]['alternate_method'] as $method_name => $method_values) {
            if ($method_name == 'explode') {
              $alternate_values = explode($method_values[0], $value, $method_values[1]);
            }

            break;
          }
        }

        foreach ($structure[$table_name][$field_name]['alternate'] as $alternate_name => &$alternate_data) {
          if (!array_key_exists('key', $alternate_data)) continue;

          $db_table_field = 'mfcs_field_' . $table_name . '_' . $alternate_name;

          if (!isset($structure_field_tables[$db_table_field])) {
            $structure_field_tables[$db_table_field] = array();
          }

          $structure_field_tables[$db_table_field][$delta] = array();
          $structure_field_tables[$db_table_field][$delta]['user_id'] = $user_data['user_id'];
          $structure_field_tables[$db_table_field][$delta]['date'] = $instance;
          $structure_field_tables[$db_table_field][$delta]['delta'] = $delta;
          $structure_field_tables[$db_table_field][$delta]['revision'] = $revision;

          if (isset($alternate_values[$alternate_data['key']]) && (is_numeric($alternate_values[$alternate_data['key']]) || !empty($alternate_values[$alternate_data['key']]))) {
            $structure_field_tables[$db_table_field][$delta]['value'] = $alternate_values[$alternate_data['key']];

            // fix_lines works by stripping out all carriage returns and replacing them with a single newline.
            if (array_key_exists('fix_lines', $structure[$table_name][$field_name]) && $structure[$table_name][$field_name]['fix_lines']) {
              $structure_field_tables[$db_table_field][$delta]['value'] = preg_replace("/\r\n/", "\n", $structure_field_tables[$db_table_field][$delta]['value']);
              $structure_field_tables[$db_table_field][$delta]['value'] = preg_replace("/\r/", "\n", $structure_field_tables[$db_table_field][$delta]['value']);
            }
          }

          if (!is_null($request_id)) {
            $structure_field_tables[$db_table_field][$delta]['request_id'] = $request_id;
          }

          $structure_current[$table_name . '_' . $alternate_name] = $revision;
        }
      }
    }
    else {
      $structure_current[$table_name . '_' . $field_name] = $revision;

      foreach ($values as $delta => $value) {
        $structure_field_tables[$db_table_field][$delta] = array();
        $structure_field_tables[$db_table_field][$delta]['user_id'] = $user_data['user_id'];
        $structure_field_tables[$db_table_field][$delta]['date'] = $instance;
        $structure_field_tables[$db_table_field][$delta]['delta'] = $delta;
        $structure_field_tables[$db_table_field][$delta]['revision'] = $revision;

        if (!is_null($request)) {
          $structure_field_tables[$db_table_field][$delta]['request_id'] = $request_id;
        }

        $storage_values = FALSE;
        if (isset($structure[$table_name][$field_name][$storage_key]) && is_array($structure[$table_name][$field_name][$storage_key])) {
          $storage_values = mfcs_convert_value_to_database_format($value, $storage_key, $structure[$table_name][$field_name][$storage_key], $form_state, $delta);
        }

        if ($storage_values !== FALSE && !is_null($storage_values)) {
          $structure_field_tables[$db_table_field][$delta]['value'] = $storage_values;

          // fix_lines works by stripping out all carriage returns and replacing them with a single newline.
          if (array_key_exists('fix_lines', $structure[$table_name][$field_name]) && $structure[$table_name][$field_name]['fix_lines']) {
            $structure_field_tables[$db_table_field][$delta]['value'] = preg_replace("/\r\n/", "\n", $structure_field_tables[$db_table_field][$delta]['value']);
            $structure_field_tables[$db_table_field][$delta]['value'] = preg_replace("/\r/", "\n", $structure_field_tables[$db_table_field][$delta]['value']);
          }
        }

        if (isset($structure[$table_name][$field_name]['type'])) {
          // exception case: the time type is also stored in a field with the y/m/d set to 0 for quick and easy relative searches at the cost of extra space usage.
          if ($structure[$table_name][$field_name]['type'] == 'time' && $storage_key == 'timestamp') {
            $storage_values = FALSE;
            if (isset($structure[$table_name][$field_name][$storage_key]) && is_array($structure[$table_name][$field_name][$storage_key])) {
              $storage_options = $structure[$table_name][$field_name][$storage_key];
              unset($storage_options['relative_to']);
              $storage_values = mfcs_convert_value_to_database_format($value, 'timestamp_relative', $storage_options);
              unset($storage_options);
            }

            if ($storage_values !== FALSE && !is_null($storage_values)) {
              $structure_field_tables[$db_table_field][$delta]['value_relative'] = $storage_values;
            }
          }
          // exception case: the date_popup type is also stored in a month and a day field for quick and easy relative searches at the cost of extra space usage.
          elseif ($structure[$table_name][$field_name]['type'] == 'date' && $storage_key == 'date_popup') {
            $storage_values = FALSE;
            if (isset($structure[$table_name][$field_name][$storage_key]) && is_array($structure[$table_name][$field_name][$storage_key])) {
              $storage_options = $structure[$table_name][$field_name][$storage_key];
              unset($storage_options['relative_to']);
              $storage_values = mfcs_convert_value_to_database_format($value, 'date_month', $storage_options);
              unset($storage_options);
            }

            if ($storage_values !== FALSE && !is_null($storage_values)) {
              $structure_field_tables[$db_table_field][$delta]['value_month'] = $storage_values;
            }

            $storage_values = FALSE;
            if (isset($structure[$table_name][$field_name][$storage_key]) && is_array($structure[$table_name][$field_name][$storage_key])) {
              $storage_options = $structure[$table_name][$field_name][$storage_key];
              unset($storage_options['relative_to']);
              $storage_values = mfcs_convert_value_to_database_format($value, 'date_day', $storage_options);
              unset($storage_options);
            }

            if ($storage_values !== FALSE && !is_null($storage_values)) {
              $structure_field_tables[$db_table_field][$delta]['value_day'] = $storage_values;
            }
          }
        }
      }
    }
  }
  else {
    $structure_current[$table_name . '_' . $field_name] = $revision;

    foreach ($values as $delta => $value) {
      $structure_field_tables[$db_table_field][$delta] = array();
      $structure_field_tables[$db_table_field][$delta]['user_id'] = $user_data['user_id'];
      $structure_field_tables[$db_table_field][$delta]['date'] = $instance;
      $structure_field_tables[$db_table_field][$delta]['delta'] = $delta;
      $structure_field_tables[$db_table_field][$delta]['revision'] = $revision;

      if (!is_null($request)) {
        $structure_field_tables[$db_table_field][$delta]['request_id'] = $request_id;
      }

      if (isset($structure[$table_name][$field_name]['columns'])) {
        foreach ($structure[$table_name][$field_name]['columns'] as $special_field_id => &$special_field_name) {
          if (isset($value[$special_field_id]) && $value[$special_field_id] > 0) {
            $structure_field_tables[$db_table_field][$delta][$special_field_name] = $special_field_id;
          }
        }
      }
      elseif (is_numeric($value) || !empty($value)) {
        $structure_field_tables[$db_table_field][$delta]['value'] = $value;

        // fix_lines works by stripping out all carriage returns and replacing them with a single newline.
        if (array_key_exists('fix_lines', $structure[$table_name][$field_name]) && $structure[$table_name][$field_name]['fix_lines']) {
          $structure_field_tables[$db_table_field][$delta]['value'] = preg_replace("/\r\n/", "\n", $structure_field_tables[$db_table_field][$delta]['value']);
          $structure_field_tables[$db_table_field][$delta]['value'] = preg_replace("/\r/", "\n", $structure_field_tables[$db_table_field][$delta]['value']);
        }
      }
    }
  }
}

/**
 * Returns the reviewers.
 *
 * @param array $conditions
 *   An array containing select conditions, such as:
 *   - 'mr.id': reviewer id.
 *   - 'mr.user_id': user id (uid).
 *   - 'mr.request_classification': request classification.
 *   - 'mr.review_step': request review step.
 *   - 'mr.reviewer_classification': reviewer classification.
 *   The each key may be an array such as:
 *     - array('value' => '1%', 'operator' => 'LIKE')
 *     - array('value' => array(0, 1, 3), 'operator' => 'IN')
 *     - array('value' => 1, '=>')
 *   This also supports a single-depth/non-recursive and/or grouping in the
 *   following format: 'and_{unique_id}', 'or_{unique_id}' where {unique_id}
 *   is some arbitrary string or number to ensure that the row is unique.
 * @param array $options
 *   (optional) When specified, representing an array containing:
 *     'join': When TRUE, the drupal user table is joined to the reviewers
 *             table. Only select portions of the user table is joined. This
 *             also joins custom field tables for user first and last name.
 *     'start': The starting location.
 *     'limit': The number of rows to select, aka: length.
 *     'count': If TRUE, an unfiltered count query is processed.
 *     'results': If FALSE, the main query is not performed.
 *     'search': A special-case/reserved variable for simplified searching.
 *     'sort': When specified, representing the database sorting.
 *
 * @return array|false
 *   An array of containing the following:
 *   - 'results': database objects representing the reviewers.
 *   - 'count': total results loaded before a range limit is applied.
 *   FALSE is returned on error.
 */
function mfcs_get_reviewers($conditions = array(), $options = array()) {
  if (!is_array($conditions)) {
    cf_error::invalid_array('conditions');
    return FALSE;
  }

  if (!is_array($options)) {
    cf_error::invalid_array('options');
    return FALSE;
  }

  $join = NULL;
  if (isset($options['join']) && is_bool($options['join'])) {
    $join = $options['join'];
  }

  $start = NULL;
  if (isset($options['start']) && is_numeric($options['start'])) {
    $start = $options['start'];
  }

  $limit = NULL;
  if (isset($options['limit']) && is_numeric($options['limit'])) {
    $limit = $options['limit'];
  }

  $count = FALSE;
  if (isset($options['count']) && is_bool($options['count'])) {
    $count = $options['count'];
  }

  $sort = FALSE;
  if (isset($options['sort']) && is_array($options['sort'])) {
    $sort = $options['sort'];
  }

  $results = TRUE;
  if (isset($options['results']) && is_bool($options['results'])) {
    $results = $options['results'];
  }

  $return = array(
    'results' => NULL,
    'count' => NULL,
  );

  if (!$results) {
    $return['results'] = array();
  }

  $search = NULL;
  if (isset($options['search'])) {
    $search = $options['search'];
  }

  try {
    $query = db_select('mfcs_reviewers', 'mr');

    if ($join) {
      $query->innerJoin('users', 'u', 'u.uid = mr.user_id');
      $query->leftJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
      $query->leftJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND fdfuln.delta = 0');
      $query->leftJoin('field_data_field_user_banner_id', 'fdfubi', 'u.uid = fdfubi.entity_id AND fdfubi.delta = 0');

      $query->innerJoin('taxonomy_term_data', 'ttd1', 'ttd1.vid = 1 AND mr.request_classification = ttd1.tid');
      $query->innerJoin('taxonomy_term_data', 'ttd2', 'ttd2.vid = 19 AND mr.review_step = ttd2.tid');
      $query->innerJoin('taxonomy_term_data', 'ttd3', 'ttd3.vid = 17 AND mr.reviewer_classification = ttd3.tid');
    }

    if (!empty($conditions)) {
      foreach ($conditions as $condition_id => $condition) {
        // check to see if the condition_id is an and or an or operation.
        $ci_parts = explode('_', $condition_id, 2);

        if (isset($ci_parts[0]) && $ci_parts[0] == 'or') {
          if (empty($ci_parts[0])) continue;

          $or = db_or();
          foreach ($condition as $subcondition_id => $subcondition) {
            if (is_array($subcondition)) {
              if (isset($subcondition['value']) && isset($subcondition['operator'])) {
                if (isset($subcondition['expression']) && $subcondition['expression']) {
                  $placeholder = ':mfcs_db_condition_placeholder_' . $query->nextPlaceholder();
                  $or->where($subcondition_id . ' ' . $subcondition['operator'] . ' ' . $placeholder, array($placeholder => $subcondition['value']));
                }
                else {
                  $or->condition($subcondition_id, $subcondition['value'], $subcondition['operator']);
                }
              }
            }
            else {
              $or->condition($subcondition_id, $subcondition);
            }
          }

          $query->condition($or);
        }
        elseif (isset($ci_parts[0]) && $ci_parts[0] == 'and') {
          if (empty($ci_parts[0])) continue;

          $and = db_and();
          foreach ($condition as $subcondition_id => $subcondition) {
            if (is_array($subcondition)) {
              if (isset($subcondition['value']) && isset($subcondition['operator'])) {
                if (isset($subcondition['expression']) && $subcondition['expression']) {
                  $placeholder = ':mfcs_db_condition_placeholder_' . $query->nextPlaceholder();
                  $and->where($subcondition_id . ' ' . $subcondition['operator'] . ' ' . $placeholder, array($placeholder => $subcondition['value']));
                }
                else {
                  $and->condition($subcondition_id, $subcondition['value'], $subcondition['operator']);
                }
              }
            }
            else {
              $and->condition($subcondition_id, $subcondition);
            }
          }

          $query->condition($and);
        }
        elseif (is_array($condition)) {
          if (isset($condition['value']) && isset($condition['operator'])) {
            if (isset($condition['expression']) && $condition['expression']) {
              $placeholder = ':mfcs_db_condition_placeholder_' . $query->nextPlaceholder();
              $query->where($condition_id . ' ' . $condition['operator'] . ' ' . $placeholder, array($placeholder => $condition['value']));
            }
            else {
              $query->condition($condition_id, $condition['value'], $condition['operator']);
            }
          }
        }
        else {
          $query->condition($condition_id, $condition);
        }
      }
    }

    if ($count) {
      $count_query = clone($query);
      $count_query->addExpression('count(mr.id)');
    }

    $query->fields('mr');

    if ($join) {
      $query->addField('u', 'name', 'name');
      $query->addField('u', 'created', 'created');
      $query->addField('u', 'status', 'status');
      $query->addField('u', 'mail', 'email');

      $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
      $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');
      $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

      $query->addField('ttd1', 'name', 'request_classification_name');
      $query->addField('ttd2', 'name', 'review_step_name');
      $query->addField('ttd3', 'name', 'reviewer_classification_name');
    }

    if (!is_null($start) || !is_null($limit)) {
      $query->range($start, $limit);
    }

    if (!empty($sort)) {
      foreach ($sort as $sort_name => $sort_value) {
        $query->orderBy($sort_name, $sort_value);
      }
    }

    if ($count) {
      $return['count'] = $count_query->execute()->fetchField();
    }

    if ($results) {
      $return['results'] = $query->execute()->fetchAll();
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }

  return $return;
}

/**
 * Returns the proxy venue coordinators.
 *
 * @param array $conditions
 *   An array containing select conditions, such as:
 *   - 'mpvc.id': reviewer id.
 *   - 'mpvc.user_id': user id (uid).
 *   - 'mpvc.proxy_id': user id (uid).
 *   - 'mpvc.disabled': disabled boolean.
 *   The each key may be an array such as:
 *     - array('value' => '1%', 'operator' => 'LIKE')
 *     - array('value' => array(0, 1, 3), 'operator' => 'IN')
 *     - array('value' => 1, '=>')
 *   This also supports a single-depth/non-recursive and/or grouping in the
 *   following format: 'and_{unique_id}', 'or_{unique_id}' where {unique_id}
 *   is some arbitrary string or number to ensure that the row is unique.
 * @param array $options
 *   (optional) When specified, representing an array containing:
 *     'join': When TRUE, the drupal user table is joined to the reviewers
 *             table. Only select portions of the user table is joined. This
 *             also joins custom field tables for user first and last name.
 *     'start': The starting location.
 *     'limit': The number of rows to select, aka: length.
 *     'count': If TRUE, an unfiltered count query is processed.
 *     'results': If FALSE, the main query is not performed.
 *     'search': A special-case/reserved variable for simplified searching.
 *     'sort': When specified, representing the database sorting.
 *
 * @return array|false
 *   An array of containing the following:
 *   - 'results': database objects representing the proxy venue coordinators.
 *   - 'count': total results loaded before a range limit is applied.
 *   FALSE is returned on error.
 */
function mfcs_get_proxy_venue_coordinators($conditions = array(), $options = array()) {
  if (!is_array($conditions)) {
    cf_error::invalid_array('conditions');
    return FALSE;
  }

  if (!is_array($options)) {
    cf_error::invalid_array('options');
    return FALSE;
  }

  $join = NULL;
  if (isset($options['join']) && is_bool($options['join'])) {
    $join = $options['join'];
  }

  $start = NULL;
  if (isset($options['start']) && is_numeric($options['start'])) {
    $start = $options['start'];
  }

  $limit = NULL;
  if (isset($options['limit']) && is_numeric($options['limit'])) {
    $limit = $options['limit'];
  }

  $count = FALSE;
  if (isset($options['count']) && is_bool($options['count'])) {
    $count = $options['count'];
  }

  $sort = FALSE;
  if (isset($options['sort']) && is_array($options['sort'])) {
    $sort = $options['sort'];
  }

  $results = TRUE;
  if (isset($options['results']) && is_bool($options['results'])) {
    $results = $options['results'];
  }

  $return = array(
    'results' => NULL,
    'count' => NULL,
  );

  if (!$results) {
    $return['results'] = array();
  }

  $search = NULL;
  if (isset($options['search'])) {
    $search = $options['search'];
  }

  try {
    $query = db_select('mfcs_proxy_venue_coordinator', 'mpvc');

    if ($join) {
      $query->innerJoin('users', 'u', 'mpvc.user_id = u.uid');
      $query->leftJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
      $query->leftJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND fdfuln.delta = 0');
      $query->leftJoin('field_data_field_user_banner_id', 'fdfubi', 'u.uid = fdfubi.entity_id AND fdfubi.delta = 0');

      $query->innerJoin('users', 'pu', 'mpvc.proxy_id = pu.uid');
      $query->leftJoin('field_data_field_user_first_name', 'pfdfufn', 'pu.uid = pfdfufn.entity_id AND pfdfufn.delta = 0');
      $query->leftJoin('field_data_field_user_last_name', 'pfdfuln', 'pu.uid = pfdfuln.entity_id AND pfdfuln.delta = 0');
      $query->leftJoin('field_data_field_user_banner_id', 'pfdfubi', 'pu.uid = pfdfubi.entity_id AND pfdfubi.delta = 0');
    }

    if (!empty($conditions)) {
      foreach ($conditions as $condition_id => $condition) {
        // check to see if the condition_id is an and or an or operation.
        $ci_parts = explode('_', $condition_id, 2);

        if (isset($ci_parts[0]) && $ci_parts[0] == 'or') {
          if (empty($ci_parts[0])) continue;

          $or = db_or();
          foreach ($condition as $subcondition_id => $subcondition) {
            if (is_array($subcondition)) {
              if (isset($subcondition['value']) && isset($subcondition['operator'])) {
                if (isset($subcondition['expression']) && $subcondition['expression']) {
                  $placeholder = ':mfcs_db_condition_placeholder_' . $query->nextPlaceholder();
                  $or->where($subcondition_id . ' ' . $subcondition['operator'] . ' ' . $placeholder, array($placeholder => $subcondition['value']));
                }
                else {
                  $or->condition($subcondition_id, $subcondition['value'], $subcondition['operator']);
                }
              }
            }
            else {
              $or->condition($subcondition_id, $subcondition);
            }
          }

          $query->condition($or);
        }
        elseif (isset($ci_parts[0]) && $ci_parts[0] == 'and') {
          if (empty($ci_parts[0])) continue;

          $and = db_and();
          foreach ($condition as $subcondition_id => $subcondition) {
            if (is_array($subcondition)) {
              if (isset($subcondition['value']) && isset($subcondition['operator'])) {
                if (isset($subcondition['expression']) && $subcondition['expression']) {
                  $placeholder = ':mfcs_db_condition_placeholder_' . $query->nextPlaceholder();
                  $and->where($subcondition_id . ' ' . $subcondition['operator'] . ' ' . $placeholder, array($placeholder => $subcondition['value']));
                }
                else {
                  $and->condition($subcondition_id, $subcondition['value'], $subcondition['operator']);
                }
              }
            }
            else {
              $and->condition($subcondition_id, $subcondition);
            }
          }

          $query->condition($and);
        }
        elseif (is_array($condition)) {
          if (isset($condition['value']) && isset($condition['operator'])) {
            if (isset($condition['expression']) && $condition['expression']) {
              $placeholder = ':mfcs_db_condition_placeholder_' . $query->nextPlaceholder();
              $query->where($condition_id . ' ' . $condition['operator'] . ' ' . $placeholder, array($placeholder => $condition['value']));
            }
            else {
              $query->condition($condition_id, $condition['value'], $condition['operator']);
            }
          }
        }
        else {
          $query->condition($condition_id, $condition);
        }
      }
    }

    if ($count) {
      $count_query = clone($query);
      $count_query->addExpression('count(mpvc.id)');
    }

    $query->fields('mpvc');

    if ($join) {
      $query->addField('u', 'name', 'name');
      $query->addField('u', 'created', 'created');
      $query->addField('u', 'status', 'status');
      $query->addField('u', 'mail', 'email');

      $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
      $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');
      $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

      $query->addField('pu', 'name', 'proxy_name');
      $query->addField('pu', 'created', 'proxy_created');
      $query->addField('pu', 'status', 'proxy_status');
      $query->addField('pu', 'mail', 'proxy_email');

      $query->addField('pfdfufn', 'field_user_first_name_value', 'proxy_first_name');
      $query->addField('pfdfuln', 'field_user_last_name_value', 'proxy_last_name');
      $query->addField('pfdfubi', 'field_user_banner_id_value', 'proxy_banner_id');
    }

    if (!is_null($start) || !is_null($limit)) {
      $query->range($start, $limit);
    }

    if (!empty($sort)) {
      foreach ($sort as $sort_name => $sort_value) {
        $query->orderBy($sort_name, $sort_value);
      }
    }

    if ($count) {
      $return['count'] = $count_query->execute()->fetchField();
    }

    if ($results) {
      $return['results'] = $query->execute()->fetchAll();
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }

  return $return;
}

/**
 * Loads the venue coordiantors the user can proxy as.
 *
 * This is a wrapper to mfcs_get_proxy_venue_coordinators() that will cache
 * the information. Use this for functions that cache would be a benefit to,
 * such as access control functions.
 *
 * Do not confuse this with mfcs_get_venue_coordinator_proxy().
 *
 * @param int $proxy_id
 *   The user id to obtain proxy information from. This is the proxy user id
 *   and not the id for the user being proxied as.
 *
 * @return array|bool
 *   An array of user ids that the proxy_id can proxy as.
 *
 *   FALSE is returned on error.
 *
 * @see: mfcs_get_proxy_venue_coordinators()
 * @see: mfcs_get_venue_coordinator_proxy()
 */
function mfcs_get_proxy_venue_coordinator($proxy_id) {
  if (!cf_is_integer($proxy_id)) {
    cf_error::invalid_integer('proxy_id');
    return FALSE;
  }

  $proxies = &drupal_static(__function__, array());

  if (array_key_exists($proxy_id, $proxies)) {
    return $proxies[$proxy_id];
  }

  $proxies_returned = mfcs_get_proxy_venue_coordinators(array('mpvc.proxy_id' => $proxy_id, 'mpvc.disabled' => 0));
  $proxys = FALSE;
  if (isset($proxies_returned['results']) && is_array($proxies_returned['results'])) {
    $proxys = $proxies_returned['results'];
  }

  if ($proxys === FALSE) {
    return FALSE;
  }

  $proxies[$proxy_id] = array();

  if (!empty($proxys)) {
    foreach ($proxys as $proxy) {
      $proxies[$proxy_id][$proxy->user_id] = $proxy->user_id;
    }
  }

  return $proxies[$proxy_id];
}

/**
 * Loads the users who can proxy as the venue coordinator.
 *
 * This is a wrapper to mfcs_get_proxy_venue_coordinators() that will cache
 * the information. Use this for functions that cache would be a benefit to,
 * such as access control functions.
 *
 * Do not confuse this with mfcs_get_proxy_venue_coordinator().
 *
 * @param int $venue_coordinator_id
 *   The user id to obtain proxy information from. This is who to proxy as and
 *   not the proxy user.
 *
 * @return array|bool
 *   An array of user ids that can proxy as the venue_coordinator_id.
 *
 *   FALSE is returned on error.
 *
 * @see: mfcs_get_proxy_venue_coordinators()
 * @see: mfcs_get_proxy_venue_coordinator()
 */
function mfcs_get_venue_coordinator_proxy($venue_coordinator_id) {
  if (!cf_is_integer($venue_coordinator_id)) {
    cf_error::invalid_integer('venue_coordinator_id');
    return FALSE;
  }

  $proxies = &drupal_static(__function__, array());

  if (array_key_exists($venue_coordinator_id, $proxies)) {
    return $proxies[$venue_coordinator_id];
  }

  $proxies_returned = mfcs_get_proxy_venue_coordinators(array('mpvc.user_id' => $venue_coordinator_id, 'mpvc.disabled' => 0));
  $proxys = FALSE;
  if (isset($proxies_returned['results']) && is_array($proxies_returned['results'])) {
    $proxys = $proxies_returned['results'];
  }

  if ($proxys === FALSE) {
    return FALSE;
  }

  $proxies[$venue_coordinator_id] = array();

  if (!empty($proxys)) {
    foreach ($proxys as $proxy) {
      $proxies[$venue_coordinator_id][$proxy->proxy_id] = $proxy->proxy_id;
    }
  }

  return $proxies[$venue_coordinator_id];
}

/**
 * A simple user loading function that only loads specific database information.
 *
 * @param int $user_id
 *   The user id to load.
 *
 * @return object|bool
 *   A user object or FALSE on error.
 */
function mfcs_get_user_information($user_id) {
  if (!cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  $users = &drupal_static(__function__, array());
  if (array_key_exists($user_id, $users)) {
    return $users[$user_id];
  }

  try {
    $query = db_select('users', 'u');
    $query->leftJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
    $query->leftJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND fdfuln.delta = 0');
    $query->leftJoin('field_data_field_user_banner_id', 'fdfubi', 'u.uid = fdfubi.entity_id AND fdfubi.delta = 0');

    $query->addField('u', 'name', 'name');
    $query->addField('u', 'created', 'created');
    $query->addField('u', 'status', 'status');
    $query->addField('u', 'mail', 'email');

    $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
    $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');
    $query->addField('fdfubi', 'field_user_banner_id_value', 'banner_id');

    $query->condition('u.uid', $user_id);

    $result = $query->execute()->fetchObject();

    if (is_object($result)) {
      $users[$user_id] = $result;

      return $result;
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }

  return FALSE;
}

/**
 * Returns the reviewer settings for the given drupal user.
 *
 * @param int $user_id
 *   The drupal user id.
 * @param bool|null $disabled
 *   (optional) When TRUE, will included disabled reviewer settings.
 *
 * @return array|false
 *   An array containing:
 *   - 'classifications': reviewer classifications array.
 *   - 'steps': request steps array.
 *   - 'for_steps': array keyed by request steps containing each associated
 *                  request classification (not reviewer classification).
 *   - 'request_classifications': classifications of requests the user is
 *     allowed to review.
 *   FALSE is returned on error.
 */
function mfcs_get_reviewer_settings_by_user_id($user_id, $disabled = FALSE) {
  if (!cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  if (!is_bool($disabled)) {
    cf_error::invalid_bool('disabled');
    $disabled = FALSE;
  }

  $static_settings = &drupal_static(__FUNCTION__);

  if (isset($static_settings[$user_id])) {
    return $static_settings[$user_id];
  }

  $options = array(
    'mr.user_id' => $user_id,
  );

  if ($disabled === FALSE) {
    $options['mr.disabled'] = 0;
  }

  $reviewers_returned = mfcs_get_reviewers($options);
  $reviewers = array();
  if (isset($reviewers_returned['results']) && is_array($reviewers_returned['results'])) {
    $reviewers = $reviewers_returned['results'];
  }
  else {
    return FALSE;
  }
  unset($reviewers_returned);

  $settings = array(
    'classifications' => array(),
    'steps' => array(),
    'for_step' => array(),
    'request_classifications' => array(),
  );

  foreach ($reviewers as $reviewer) {
    if (is_string($reviewer->reviewer_classification)) {
      $reviewer_classification = (int) $reviewer->reviewer_classification;
    }
    else {
      $reviewer_classification = $reviewer->reviewer_classification;
    }

    $reviewer_review_step = NULL;
    if (isset($reviewer->review_step) && is_string($reviewer->review_step)) {
      $reviewer_review_step = (int) $reviewer->review_step;
    }
    else {
      $reviewer_review_step = $reviewer->review_step;
    }

    if (is_string($reviewer->request_classification)) {
      $reviewer_request_classification = (int) $reviewer->request_classification;
    }
    else {
      $reviewer_request_classification = $reviewer->request_classification;
    }

    $settings['classifications'][$reviewer_classification] = $reviewer_classification;
    $settings['steps'][$reviewer_review_step] = $reviewer_review_step;
    $settings['request_classifications'][$reviewer_request_classification] = $reviewer_request_classification;

    // provides 'request classifications' (and not 'review classifications') information on a per step basis.
    if (!array_key_exists($reviewer_review_step, $settings['for_step'])) {
      $settings['for_step'][$reviewer_review_step] = array();
    }
    $settings['for_step'][$reviewer_review_step][$reviewer_request_classification] = $reviewer_request_classification;
  }

  $static_settings[$user_id] = $settings;
  return $settings;
}

/**
 * Checks to see if the given room is available at the given times.
 *
 * For the dates and times to work properly, it is expected that:
 * - unix timestamps are used.
 * - date values have their time reset to 0 (aka: 12:00:00am).
 * - time values have their dates set to the same day as the date value.
 *
 * @param int $room
 *   The room id.
 * @param array $dates
 *   An array containing the date values.
 * @param array $time_start
 *   An array containing the time start values.
 * @param array $time_stop
 *   An array containing the time stop values.
 * @param int|null $request_id
 *   (optional) When not NULL, this represents the request_id to ignore.
 *   Use this so that when editing an existing request, it does not report
 *   itself as the request using the room.
 *
 * @return array|false
 *   An array with the following keys;
 *   - conflicts: an array containing any requests currently using the room at the specified date and time.
 *   - unavailable: an array containing any room unavailability.
 *   FALSE on error.
 */
function mfcs_check_room_availability($room, $dates, $time_start, $time_stop, $request_id = NULL) {
  if (!is_int($room)) {
    cf_error::invalid_integer('room');
    return FALSE;
  }

  if (!is_array($dates) || empty($dates)) {
    cf_error::invalid_array('dates');
    return FALSE;
  }

  if (!is_array($time_start) || empty($time_start)) {
    cf_error::invalid_array('time_start');
    return FALSE;
  }

  if (!is_array($time_stop) || empty($time_stop)) {
    cf_error::invalid_array('time_stop');
    return FALSE;
  }

  if (!is_null($request_id) && !cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  $matched_requests = array(
    'conflicts' => array(),
    'unavailable' => array(),
  );

  try {
    $query = db_select('mfcs_requests', 'mer');

    $query->innerJoin('mfcs_current', 'mc', 'mer.id = mc.request_id');
    $query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mc.request_id = mfdd.request_id AND mc.dates_date = mfdd.revision');

    $query->addField('mer', 'id', 'request_id');
    $query->addField('mer', 'status', 'status');
    $query->addField('mer', 'step', 'step');
    $query->addField('mfdd', 'value', 'date');
    $query->addField('mc', 'dates_date', 'date_revision');
    $query->addField('mc', 'dates_time_start', 'time_start_revision');
    $query->addField('mc', 'dates_time_stop', 'time_stop_revision');

    $query->distinct();

    $statuses = array(
      MFCS_REQUEST_STATUS_LOCKED,
      MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    );

    $query->condition('mer.status', $statuses, 'IN');
    $query->condition('mer.room', $room);
    $query->condition('mfdd.value', $dates, 'IN');
    $query->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.

    if (!is_null($request_id)) {
      $query->condition('mer.id', $request_id, '<>');
    }

    $results = $query->execute()->fetchAll();


    // when rooms are in use, check the individual times.
    if (!empty($results)) {
      // the results contain all locked requests that have something in the given room during the given date.
      // however, this does not mention the time, so loop through the times and see if they are all valid.
      foreach ($results as $result) {
        $query = db_select('mfcs_field_dates_date', 'mfdd');

        $query->innerJoin('mfcs_field_dates_time_start', 'mfdts', 'mfdd.request_id = mfdts.request_id AND mfdd.delta = mfdts.delta');
        $query->innerJoin('mfcs_field_dates_time_stop', 'mfdtsp', 'mfdd.request_id = mfdtsp.request_id AND mfdd.delta = mfdtsp.delta');

        $query->addField('mfdd', 'request_id', 'request_id');
        $query->addField('mfdd', 'revision', 'revision');
        $query->addField('mfdd', 'delta', 'delta');
        $query->addField('mfdd', 'value', 'date');
        $query->addField('mfdts', 'value', 'time_start');
        $query->addField('mfdtsp', 'value', 'time_stop');

        $query->condition('mfdd.request_id', $result->request_id);
        $query->condition('mfdts.request_id', $result->request_id);
        $query->condition('mfdtsp.request_id', $result->request_id);

        $query->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.

        $query->condition('mfdd.revision', $result->date_revision);
        $query->condition('mfdts.revision', $result->time_start_revision);
        $query->condition('mfdtsp.revision', $result->time_stop_revision);

        if (!is_null($request_id)) {
          $query->condition('mfdd.request_id', $request_id, '<>');
        }

        $or = db_or();

        // all day requests match, they have NULL for start and stop time values.
        $and = db_and();
        $and->condition('mfdd.value', $dates, 'IN');
        $and->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.
        $and->isNull('mfdts.value');
        $and->isNull('mfdtsp.value');

        $or->condition($and);

        foreach ($dates as $key => $value) {
          // all day requests match, they have NULL for start and stop time values.
          if (is_null($time_start[$key]) && is_null($time_stop[$key])) {
            $matched_requests['conflicts'][] = $result;
          }

          $and = db_and();
          $and->condition('mfdd.value', $value);
          $and->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.
          $and->condition('mfdts.value', $time_start[$key], '<=');
          $and->condition('mfdtsp.value', $time_start[$key], '>');
          $or->condition($and);

          $and = db_and();
          $and->condition('mfdd.value', $value);
          $and->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.
          $and->condition('mfdts.value', $time_stop[$key], '<');
          $and->condition('mfdtsp.value', $time_stop[$key], '>=');
          $or->condition($and);

          $and = db_and();
          $and->condition('mfdd.value', $value);
          $and->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.
          $and->condition('mfdts.value', $time_start[$key], '>');
          $and->condition('mfdtsp.value', $time_start[$key], '>');
          $and->condition('mfdts.value', $time_stop[$key], '<');
          $and->condition('mfdtsp.value', $time_stop[$key], '<');
          $or->condition($and);
        }

        $query->condition($or);

        $matches = $query->execute()->fetchAll();
        foreach ($matches as $match) {
          $result->time_start = $match->time_start;
          $result->time_stop = $match->time_stop;
          $matched_requests['conflicts'][] = $result;
        }
      }
    }


    // check to see if classes (in banner) have reserved the room.
    $query = db_select('mfcs_banner_classes', 'mbc');
    $query->fields('mbc');
    $query->condition('mbc.room', $room);

    $or = db_or();
    foreach ($dates as $key => $value) {
      // all day requests match, they have NULL for start and stop time values.
      if (is_null($time_start[$key]) && is_null($time_stop[$key])) {
        $or->condition('mbc.reserved_day', $value);
        continue;
      }

      $and = db_and();
      $and->condition('mbc.reserved_day', $value);
      $and->condition('mbc.reserved_time_start', $time_start[$key], '<=');
      $and->condition('mbc.reserved_time_stop', $time_start[$key], '>');
      $or->condition($and);

      $and = db_and();
      $and->condition('mbc.reserved_day', $value);
      $and->condition('mbc.reserved_time_start', $time_stop[$key], '<');
      $and->condition('mbc.reserved_time_stop', $time_stop[$key], '>=');
      $or->condition($and);

      $and = db_and();
      $and->condition('mbc.reserved_day', $value);
      $and->condition('mbc.reserved_time_start', $time_start[$key], '>');
      $and->condition('mbc.reserved_time_stop', $time_start[$key], '>');
      $and->condition('mbc.reserved_time_start', $time_stop[$key], '<');
      $and->condition('mbc.reserved_time_stop', $time_stop[$key], '<');
      $or->condition($and);
    }

    $query->condition($or);

    $results = $query->execute()->fetchAll();
    foreach ($results as $result) {
      $matched_requests['conflicts'][] = $result;
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);
    return FALSE;
  }

  // process explicit/non-conflict unavailabilities.
  foreach ($dates as $key => $date) {
    $year = date('Y', $date);

    if (is_null($time_start[$key])) {
      $start_time = strtotime('midnight today', $date);
      $stop_time = strtotime('midnight tomorrow', $date);
    }
    else {
      $start_time = $time_start[$key];
      $stop_time = $time_stop[$key];
    }

    $unavailabilities = mfcs_get_unavailabilities($year, $room, $start_time, $stop_time);
    foreach ($unavailabilities as $unavailability) {
      $matched_requests['unavailable'][$unavailability->id] = $unavailability;
    }
    unset($unavailability);
    unset($unavailabilities);
  }

  return $matched_requests;
}

/**
 * Builds and returns the availability problem message based on the room availability information.
 *
 * This creates an unordered list.
 * The initial warning/title for the list is not generated because the specfic message may vary.
 *
 * @param array $availability_issues
 *   An array containing availability issues as returned by mfcs_check_room_availability()
 * @param string|null $url_arguments
 *   (optional) An string of url arguments to append to each link.
 *
 * @return string|bool|null
 *   The built string in HTML markup format.
 *   FALSE is returned on error.
 *   NULL is returned when there are no availability issues to process.
 *
 * @see: mfcs_check_room_availability()
 */
function mfcs_build_room_unavailable_message($availability_issues, $url_arguments = NULL) {
  if (!is_array($availability_issues)) {
    cf_error::invalid_array('availability_issues');
    return FALSE;
  }

  if (!is_null($url_arguments) && !is_string($url_arguments)) {
    cf_error::invalid_string('url_arguments');
    return FALSE;
  }

  if (empty($availability_issues['conflicts']) && empty($availability_issues['unavailable'])) {
    return NULL;
  }

  global $base_path;

  $unavailable_message = '<ul>';

  $problematic_dates = array();
  if (!empty($availability_issues['conflicts'])) {
    foreach ($availability_issues['conflicts'] as $request_using_room) {
      if (isset($request_using_room->date)) {
        if (isset($request_using_room->time_start)) {
          $problematic_date_key =  '' . $request_using_room->reserved_day . '-' . $request_using_room->reserved_time_start . '-' . $request_using_room->reserved_time_stop;
          $problematic_date = '<strong>' . date('l, F j, Y', $request_using_room->date) . '</strong> from <strong>' . date('h:ia', $request_using_room->time_start) . '</strong> to <strong>' . date('h:ia', $request_using_room->time_stop) . '</strong> because of a ';
          $problematic_date .= '<strong><a href="' . $base_path . 'requests/view-0/' . $request_using_room->request_id . $url_arguments . '" title="View conflicting request.">scheduling conflict</a></strong>.';
          $problematic_dates[$problematic_date_key] = $problematic_date;
        }
        else {
          $problematic_date_key =  '' . $request_using_room->reserved_day;
          $problematic_date = '<strong>' . date('l, F j, Y', $request_using_room->date) . '</strong> (all day) because of a ';
          $problematic_date .= '<strong><a href="' . $base_path . 'requests/view-0/' . $request_using_room->request_id . $url_arguments . '" title="View conflicting request.">scheduling conflict</a></strong>.';
          $problematic_dates[$problematic_date_key] = $problematic_date;
        }
      }
      elseif (isset($request_using_room->reserved_day)) {
        $problematic_date_key =  '' . $request_using_room->reserved_day . '-' . $request_using_room->reserved_time_start . '-' . $request_using_room->reserved_time_stop;
        $problematic_date = '<strong>' . date('l, F j, Y', $request_using_room->reserved_day) . '</strong> from <strong>' . date('h:ia', $request_using_room->reserved_time_start) . '</strong> to <strong>' . date('h:ia', $request_using_room->reserved_time_stop) . '</strong> because of a scheduling conflict.';
        $problematic_dates[$problematic_date_key] = $problematic_date;
      }
    }
    unset($problematic_date_key);
    unset($request_using_room);

    ksort($problematic_dates);
    foreach ($problematic_dates as $date) {
      $unavailable_message .= '<li>' . $date . '</li>';
    }
    unset($date);
  }

  if (!empty($availability_issues['unavailable'])) {
    foreach ($availability_issues['unavailable'] as $unavailable) {
      $year = (int) date('Y', $unavailable->date_start);

      $unavailable_message .= '<li>';

      $start_day = strtotime('midnight today', $unavailable->date_start);
      $stop_day = strtotime('midnight today', $unavailable->date_stop);

      if ($unavailable->date_start == $start_day && $unavailable->date_stop == $stop_day) {
        // all day.
        if ($unavailable->date_stop == strtotime('midnight tomorrow', $start_day)) {
          // all day, one day.
          $unavailable_message .= '<strong>' . check_plain(date('l, F j, Y', $unavailable->date_start)) . '</strong>';
        }
        else {
          // all day, over more than one days.
          $unavailable_message .= '<strong>' . check_plain(date('l, F j, Y', $unavailable->date_start)) . '</strong> to <strong>' . check_plain(date('l, F j, Y', $unavailable->date_stop)) . '</strong>';
        }
      }
      elseif ($start_day == $stop_day || $unavailable->date_stop == strtotime('midnight tomorrow', $start_day)) {
        // specific times in one day.
        $unavailable_message .= '<strong>' . check_plain(date('l, F j, Y', $unavailable->date_start)) . '</strong> from <strong>' . check_plain(date('h:i a', $unavailable->date_start)) . '</strong> to <strong>' . check_plain(date('h:i a', $unavailable->date_stop)) . '</strong>';
      }
      else {
        // specific times over more than one days.
        $unavailable_message .= '<strong>' . check_plain(date('h:i a, l, F j, Y', $unavailable->date_start)) . '</strong> to <strong>' . check_plain(date('h:i a, l, F j, Y', $unavailable->date_stop)) . '</strong>';
      }

      $unavailable_message .= ' because of: ';
      $unavailable_message .= '<strong><a href="' . $base_path . 'requests/unavailable-0/view/' . $year . '/' . $unavailable->room_id. '/' . $unavailable->id . $url_arguments . '" title="View details about room unavailability.">';
      $unavailable_message .= check_plain(preg_replace('/\.\s*$/i', '', $unavailable->title)) . '</a></strong>.';
      $unavailable_message .= '</li>';

      unset($year);
    }
    unset($unavailable);
  }

  $unavailable_message .= '</ul>';

  return $unavailable_message;
}

/**
 * Load a listing of requests.
 *
 * This can be used as a very simple and straightforward search.
 *
 * @param array $conditions
 *   An array containing select conditions, such as:
 *   - 'mr.id': reviewer id.
 *   - 'mr.user_id': user id (uid).
 *   - 'mr.request_classification': request classification.
 *   - 'mr.review_step': request review step.
 *   - 'mr.reviewer_classification': reviewer classification.
 *   The each key may be an array such as:
 *     - array('value' => '1%', 'operator' => 'LIKE')
 *     - array('value' => array(0, 1, 3), 'operator' => 'IN')
 *     - array('value' => 1, '=>')
 *   This also supports a recursive and/or grouping in the following format:
 *   'and_{unique_id}', 'or_{unique_id}' where {unique_id} is some arbitrary
 *   string or number to ensure that the row is unique.
 * @param array $options
 *   (optional) When specified, representing an array containing:
 *     'join': When TRUE, the drupal user table is joined for the table.
 *             Only select portions of the user table is joined. This
 *             also joins custom field tables for user first and last name.
 *             This is only joined to the submitter table column.
 *     'start': The starting location.
 *     'limit': The number of rows to select, aka: length.
 *     'count': If TRUE, an unfiltered count query is processed.
 *     'results': If FALSE, the main query is not performed.
 *     'sort': An array of database sorting columns and their sort orders.
 *     'sensitive': TRUE for case sensitive and FALSE otherwise.
 *     'review_restrictions': The review restrictions to use.
 *     'extra_fields': An array of extra fields that should be loaded.
 *                     The array will have a key of the table name and a value
 *                     of an array. The value array will contain an 'alias'
 *                     string, an 'on' string, a 'join' string, and a 'columns'
 *                     array.
 *     'distinct': Process the entire query as distinct.
 *     'distinct_id': Custom option to load mer.id as distinct. This overrides
 *                    'distinct' when TRUE.
 *     'cancelled': When not set or set to MFCS_LOAD_CANCELLED_NONE, no cancelled requests or individual dates are loaded.
 *                  When MFCS_LOAD_CANCELLED_INDIVIDUAL, individual dates associated with a request are loaded.
 *                  When MFCS_LOAD_CANCELLED_REQUEST, requests that are cancelled are loaded.
 *                  When MFCS_LOAD_CANCELLED_ALL, both individual dates and requests that are cancelled are loaded.
 *     'user_id': When defined and an integer, represents the user id of the user to load the listing as.
 *     'only_requester': When defined as a boolean, represents that only requests whose requester is the current user xor the user specified by 'user_id' are loaded.
 *     'only_reviewer': When defined as a boolean, represents that only requests whose reviewer is the current user are loaded (venue coordinators are also reviewers).
 *                      This only applies when review restrictions are set to MFCS_REVIEW_RESTRICTION_REVIEW.
 *
 * @return array|false
 *   An array of containing the following:
 *   - 'results': database objects representing the items.
 *   - 'count': total results loaded before a range limit is applied.
 *   FALSE is returned on error.
 *
 * @see: mfcs_request_process_query_search_array()
 */
function mfcs_request_load_listing($conditions = array(), $options = array()) {
  if (!is_array($conditions)) {
    cf_error::invalid_array('conditions');
    return FALSE;
  }

  if (!is_array($options)) {
    cf_error::invalid_array('options');
    return FALSE;
  }

  $join = NULL;
  if (isset($options['join']) && is_bool($options['join'])) {
    $join = $options['join'];
  }

  $start = 0;
  if (isset($options['start']) && is_numeric($options['start']) && $start >= 0) {
    $start = $options['start'];
  }

  $limit = 20;
  if (isset($options['limit']) && is_numeric($options['limit']) && $limit >= 0) {
    $limit = $options['limit'];
  }

  $count = FALSE;
  if (isset($options['count']) && is_bool($options['count'])) {
    $count = (bool) $options['count'];
  }

  $sort = NULL;
  if (isset($options['sort']) && is_array($options['sort'])) {
    $sort = $options['sort'];
  }

  $results = TRUE;
  if (isset($options['results']) && is_bool($options['results'])) {
    $results = $options['results'];
  }

  $distinct = FALSE;
  if (isset($options['distinct']) && is_bool($options['distinct'])) {
    $distinct = (bool) $options['distinct'];
  }

  $distinct_id = FALSE;
  if (isset($options['distinct_id']) && is_bool($options['distinct_id'])) {
    $distinct_id = (bool) $options['distinct_id'];
    if ($distinct_id) {
      $distinct = FALSE;
    }
  }

  $cancelled = MFCS_LOAD_CANCELLED_NONE;
  if (isset($options['cancelled']) && cf_is_integer($options['cancelled'])) {
    switch ($options['cancelled']) {
      case MFCS_LOAD_CANCELLED_INDIVIDUAL:
      case MFCS_LOAD_CANCELLED_REQUEST:
      case MFCS_LOAD_CANCELLED_ALL:
        $cancelled = (int) $options['cancelled'];
        break;
    }
  }

  $user_id = NULL;
  if (isset($options['user_id']) && cf_is_integer($options['user_id'])) {
    $user_id = (int) $options['user_id'];
  }

  $only_requester = NULL;
  if (isset($options['only_requester']) && is_bool($options['only_requester'])) {
    $only_requester = $options['only_requester'];
  }

  $return = array(
    'results' => NULL,
    'count' => NULL,
  );

  if (!$results) {
    $return['results'] = array();
  }

  $sensitive = FALSE;
  if (isset($options['sensitive']) && is_bool($options['sensitive'])) {
    $sensitive = $options['sensitive'];
  }

  $review_restrictions = MFCS_REVIEW_RESTRICTION_NONE;
  if (isset($options['review_restrictions'])) {
    $review_restrictions = $options['review_restrictions'];
  }

  $only_reviewer = NULL;
  if ($review_restrictions === MFCS_REVIEW_RESTRICTION_REVIEW) {
    if (isset($options['only_reviewer']) && is_bool($options['only_reviewer'])) {
      $only_reviewer = $options['only_reviewer'];
    }
  }

  $extra_fields = array();
  if (isset($options['extra_fields']) && is_array($options['extra_fields'])) {
    $extra_fields = $options['extra_fields'];
  }

  if (is_null($user_id)) {
    $user = cf_current_user();
  }
  elseif ($user_id >= 0) {
    $user = user_load($user_id);
  }
  else {
    $user = user_load(0);
  }

  $administer = FALSE;
  $manager = FALSE;
  $reviewer = FALSE;
  $requester = FALSE;
  if ($user_id === MFCS_USER_REQUEST) {
    // this is a simulated user account and must be handled as a special case.
    $requester = TRUE;
  }
  else {
    $administer = user_access('mfcs administer', $user);
    $manager = user_access('mfcs manage', $user);
    $reviewer = user_access('mfcs review', $user);
    $requester = user_access('mfcs request', $user);
  }

  $s = 'i';
  $like = 'ILIKE';
  if ($sensitive) {
    $s = '';
    $like = 'LIKE';
  }

  $show_status_venue_coordinator = array(
    MFCS_REQUEST_STATUS_LOCKED,
    MFCS_REQUEST_STATUS_UNLOCKED,
  );

  $show_step_venue_coordinator = array(
    MFCS_REVIEW_STEP_VENUE_AVAILABLE,
  );

  $show_status_reviewer = array(
    MFCS_REQUEST_STATUS_LOCKED,
  );

  $show_status_manager = array(
    MFCS_REQUEST_STATUS_UNLOCKED,
    MFCS_REQUEST_STATUS_LOCKED,
  );

  $show_step_reviewer = array(
    MFCS_REVIEW_STEP_REVIEW,
    MFCS_REVIEW_STEP_REQUIREMENTS,
  );

  $show_step_manager = array(
    MFCS_REVIEW_STEP_VENUE_AVAILABLE,
    MFCS_REVIEW_STEP_REVIEW,
    MFCS_REVIEW_STEP_REQUIREMENTS,
  );

  if ($review_restrictions != MFCS_REVIEW_RESTRICTION_NONE && $user_id !== MFCS_USER_REQUEST) {
    $reviewer_settings = mfcs_get_reviewer_settings_by_user_id($user->uid);
  }
  else {
    $reviewer_settings = array(
      'classifications' => array(),
      'steps' => array(),
    );
  }

  $already_joined_count = 0;
  $already_joined = array();

  $already_added = array();

  $found = array();
  try {
    $outermost_and = NULL;
    $query = db_select('mfcs_requests', 'mer');
    $query->innerJoin('mfcs_current', 'mc', 'mer.id = mc.request_id');

    $already_joined['mfcs_requests'] = 'mer';
    $already_joined['mfcs_current'] = 'mc';
    $already_joined['mfcs_field_top_status'] = 'mer';
    $already_joined['mfcs_field_top_step'] = 'mer';
    $already_joined['mfcs_field_top_location'] = 'mer';
    $already_joined['mfcs_field_top_building'] = 'mer';
    $already_joined['mfcs_field_top_room'] = 'mer';
    $already_joined['mfcs_field_information_type'] = 'mer';
    $already_joined['mfcs_field_request_coordinator_classification'] = 'mer';
    $already_joined['mfcs_field_information_title'] = 'mer';

    if ($join) {
      $query->leftJoin('users', 'sb_u', 'mer.user_id = sb_u.uid');
      $query->leftJoin('field_data_field_user_first_name', 'sb_fdfufn', 'sb_u.uid = sb_fdfufn.entity_id AND sb_fdfufn.delta = 0');
      $query->leftJoin('field_data_field_user_last_name', 'sb_fdfuln', 'sb_u.uid = sb_fdfuln.entity_id AND sb_fdfuln.delta = 0');

      $already_joined['submitted_by-users'] = 'sb_u';
      $already_joined['submitted_by-field_data_field_user_first_name'] = 'sb_fdfufn';
      $already_joined['submitted_by-field_data_field_user_last_name'] = 'sb_fdfuln';
    }

    $count_query = NULL;
    if ($count) {
      $count_query = clone($query);

      if ($distinct_id) {
        $count_query->addExpression('count(distinct mer.id)');
      }
      else {
        $count_query->addExpression('count(mer.id)');
      }
    }

    if ($distinct) {
      $query->distinct();
    }

    if ($distinct_id) {
      $query->distinct(array('field' => 'mer.id', 'alias' => 'id'));
    }
    else {
      $query->addField('mer', 'id', 'id');
    }

    $query->addField('mer', 'user_id', 'user_id');
    $query->addField('mer', 'created', 'created');
    $query->addField('mer', 'updated', 'updated');

    if ($join) {
      $query->addField('sb_u', 'name', 'submitted_by_name');

      $query->addField('sb_fdfufn', 'field_user_first_name_value', 'submitted_by_first_name');
      $query->addField('sb_fdfuln', 'field_user_last_name_value', 'submitted_by_last_name');

      $already_added['submitted_by_name'] = 'sb_u.name';

      $already_added['submitted_by_first_name'] = 'sb_fdfufn.submitted_by_first_name';
      $already_added['submitted_by_last_name'] = 'sb_fdfuln.submitted_by_last_name';
    }

    $query->addField('mer', 'status', 'status');
    $query->addField('mer', 'step', 'step');

    $query->addField('mer', 'title', 'title');
    $query->addField('mer', 'type', 'type');
    $query->addField('mer', 'classification', 'classification');

    $query->addField('mer', 'location', 'location');
    $query->addField('mer', 'building', 'building');
    $query->addField('mer', 'room', 'room');

    $query->addField('mer', 'venue_coordinator', 'venue_coordinator');

    $already_added['id'] = 'mer.id';
    $already_added['user_id'] = 'mer.user_id';
    $already_added['created'] = 'mer.created';
    $already_added['updated'] = 'mer.updated';

    $already_added['status'] = 'mer.status';
    $already_added['step'] = 'mer.step';

    $already_added['title'] = 'mer.title';
    $already_added['type'] = 'mer.type';
    $already_added['classification'] = 'mer.classification';

    // These will be added via a seperate loop that gathers all possible dates.
    $already_added['current_date'] = 'mc.dates_date';
    $already_added['current_time_start'] = 'mc.dates_time_start';
    $already_added['current_time_stop'] = 'mc.dates_time_stop';
    $already_added['current_category'] = 'mc.dates_category';

    // add custom fields to the select results as requested by the caller.
    if (!empty($extra_fields)) {
      foreach ($extra_fields as $extra_table_name => $extra_values) {
        if (!array_key_exists('alias', $extra_values) || !array_key_exists('join', $extra_values) || !array_key_exists('columns', $extra_values)) {
          continue;
        }

        if (array_key_exists($extra_table_name, $already_joined)) {
          continue;
        }

        if ($extra_values['join'] == 'inner') {
          $query->innerJoin($extra_table_name, $extra_values['alias'], $extra_values['on']);

          if ($count) {
            $count_query->innerJoin($extra_table_name, $extra_values['alias'], $extra_values['on']);
          }
        }
        elseif ($extra_values['join'] == 'left') {
          $query->leftJoin($extra_table_name, $extra_values['alias'], $extra_values['on']);

          if ($count) {
            $count_query->leftJoin($extra_table_name, $extra_values['alias'], $extra_values['on']);
          }
        }
        elseif ($extra_values['join'] == 'right') {
          $query->rightJoin($extra_table_name, $extra_values['alias'], $extra_values['on']);

          if ($count) {
            $count_query->rightJoin($extra_table_name, $extra_values['alias'], $extra_values['on']);
          }
        }

        $already_joined[$extra_table_name] = $extra_values['alias'];
        foreach ($extra_values['columns'] as $column_external_name => $column_internal_name) {
          if (array_key_exists($column_external_name, $already_added)) {
            continue;
          }

          $query->addField($extra_values['alias'], $column_internal_name, $column_external_name);
          $already_added[$column_external_name] = $extra_values['alias'] . '.' . $column_internal_name;
        }
      }
    }

    if (!empty($conditions)) {
      $operand = db_and();
      $result = mfcs_request_process_query_search_array($query, $count_query, $operand, $already_joined, $already_joined_count, $already_added, $conditions, 1, $like);

      if ($result) {
        if (is_null($outermost_and)) {
          $outermost_and = db_and();
        }
        $outermost_and->condition($operand);
      }
    }

    if ($limit > 0) {
      $query->range($start, $limit);
    }

    if ($reviewer || $manager || $administer) {
      $or = NULL;

      $proxies = mfcs_get_proxy_venue_coordinator($user->uid);
      $venue_coordinator_ids = array();
      if (!empty($proxies)) {
        $venue_coordinator_ids = $proxies;
      }
      $venue_coordinator_ids[$user->uid] = $user->uid;


      if ($review_restrictions == MFCS_REVIEW_RESTRICTION_REVIEW) {
        if ($manager && !$only_reviewer) {
          if (is_null($outermost_and)) {
            $outermost_and = db_and();
          }

          // Manager is allowed both venue coordinator and reviewer step review access.
          $outermost_and->condition('mer.step', $show_step_manager, 'IN');
          $outermost_and->condition('mer.status', $show_status_manager, 'IN');
        }
        else {
          if (is_null($or)) {
            $or = db_or();
          }

          // process venue coordinator access.
          $already_venue_coordinated_query = db_select('mfcs_reviewed', 'mrd_vc');
          $already_venue_coordinated_query->addField('mrd_vc', 'request_id', 'request_id');
          $already_venue_coordinated_query->where('mrd_vc.request_id = mer.id');
          $already_venue_coordinated_query->condition('mrd_vc.classification', MFCS_REVIEWER_CLASSIFICATION_VENUE_COORDINATOR);

          $and = db_and();
          $and->condition('mer.status', $show_status_venue_coordinator, 'IN');
          $and->condition('mer.step', $show_step_venue_coordinator, 'IN');
          $and->condition('mer.id', $already_venue_coordinated_query, 'NOT IN');
          $and->condition('mer.venue_coordinator', $venue_coordinator_ids, 'IN');

          $or->condition($and);

          // process review access.
          if (!empty($reviewer_settings['classifications'])) {
            $already_reviewed_query = db_select('mfcs_reviewers', 'mr_r');
            $already_reviewed_query->innerJoin('mfcs_reviewed', 'mrd_r', 'mr_r.reviewer_classification = mrd_r.classification');
            $already_reviewed_query->addField('mrd_r', 'request_id', 'request_id');
            $already_reviewed_query->where('mr_r.request_classification = mer.classification AND mr_r.review_step = mer.step');
            $already_reviewed_query->condition('mr_r.user_id', $user->uid);
            $already_reviewed_query->condition('mr_r.disabled', 0);

            $and = db_and();
            $and->condition('mer.status', $show_status_reviewer, 'IN');
            $and->condition('mer.step', $show_step_reviewer, 'IN');
            $and->condition('mer.step', $reviewer_settings['steps'], 'IN');
            $and->condition('mer.id', $already_reviewed_query, 'NOT IN');

            $or->condition($and);
          }
        }
      }
      elseif ($review_restrictions == MFCS_REVIEW_RESTRICTION_VIEW) {
        if (!$manager && !$administer) {
          if (is_null($or)) {
            $or = db_or();
          }

          // always show completed and accepted requests when there are no restrictions.
          $and = db_and();
          if ($cancelled === MFCS_LOAD_CANCELLED_REQUEST || $cancelled === MFCS_LOAD_CANCELLED_ALL) {
            $subor = db_or();
            $subor->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);
            $subor->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED);
            $and->condition($subor);
            unset($subor);
          }
          else {
            $and->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);
          }
          $and->condition('mer.step', MFCS_REVIEW_STEP_COMPLETED);

          $or->condition($and);

          // process venue coordinator access.
          $or->condition('mer.venue_coordinator', $venue_coordinator_ids, 'IN');

          // process reviewer access.
          if (!empty($reviewer_settings['steps'])) {
            $and = db_and();
            $and->condition('mer.status', MFCS_REQUEST_STATUS_LOCKED);
            $and->condition('mer.step', $show_step_reviewer, 'IN');
            $or->condition($and);
          }
        }
      }
      // always show accepted requests when there are no restrictions.
      elseif ($review_restrictions == MFCS_REVIEW_RESTRICTION_NONE) {
        // if there are no conditions, then don't add any!
        if (!is_null($or)) {
          $and = db_and();
          if ($cancelled === MFCS_LOAD_CANCELLED_REQUEST || $cancelled === MFCS_LOAD_CANCELLED_ALL) {
            $subor = db_or();
            $subor->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);
            $subor->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED);
            $and->condition($subor);
            unset($subor);
          }
          else {
            $and->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);
          }
          $and->condition('mer.step', MFCS_REVIEW_STEP_COMPLETED);
          $or->condition($and);
          unset($and);
        }
      }

      if (!is_null($or)) {
        if (is_null($outermost_and)) {
          $outermost_and = db_and();
        }
        $outermost_and->condition($or);
      }

      // only show requests for the current user xor the specified user.
      if (is_bool($only_requester) && $only_requester) {
        if (is_null($outermost_and)) {
          $outermost_and = db_and();
        }

        $outermost_and->condition('mer.user_id', $user->uid);
      }
    }
    elseif ($requester) {
      $or = NULL;

      // always show accepted requests when there are no restrictions.
      if ($review_restrictions == MFCS_REVIEW_RESTRICTION_NONE) {
        if (is_null($or)) {
          $or = db_or();
        }

        // show cancelled requests that were once approved, if requested to do so.
        if ($cancelled === MFCS_LOAD_CANCELLED_REQUEST || $cancelled === MFCS_LOAD_CANCELLED_ALL) {
          if (is_null($or)) {
            $or = db_or();
          }

          $and = db_and();
          $and->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED_CANCELLED);
          $and->condition('mer.step', MFCS_REVIEW_STEP_COMPLETED);
          $or->condition($and);
          unset($and);
        }

        $and = db_and();
        $and->condition('mer.status', MFCS_REQUEST_STATUS_CLOSED_ACCEPTED);
        $and->condition('mer.step', MFCS_REVIEW_STEP_COMPLETED);
        $or->condition($and);
        unset($and);

        if ($user->uid > 0) {
          $or->condition('mer.user_id', $user->uid);
        }

        if (is_null($outermost_and)) {
          $outermost_and = db_and();
        }
        $outermost_and->condition($or);
      }
      else {
        if ($user->uid > 0) {
          if (is_null($outermost_and)) {
            $outermost_and = db_and();
          }
          $outermost_and->condition('mer.user_id', $user->uid);
        }
      }

      // only show requests for the current user xor the specified user.
      if (is_bool($only_requester) && $only_requester) {
        if (is_null($outermost_and)) {
          $outermost_and = db_and();
        }

        $outermost_and->condition('mer.user_id', $user->uid);
      }
    }
    else {
      // failsafe, should never happen.
      return FALSE;
    }

    // do not include deleted requests.
    if (is_null($outermost_and)) {
      $outermost_and = db_and();
    }
    $outermost_and->condition('mer.status', MFCS_REQUEST_STATUS_DELETED, '<>');

    $query->condition($outermost_and);
    if ($count) {
      $count_query->condition($outermost_and);
    }

    if (is_null($sort)) {
      // default to sorting/ordering by request id.
      if ($distinct || $distinct_id) {
        // when a query is distinct, the order by values must be defined in the select columns.
        $query->orderBy('id' , 'DESC');
      }
      else {
        $query->orderBy('mer.id', 'DESC');
      }
    }
    else {
      if (!empty($sort)) {
        // When selecting distinct on a specific column/alias, it must be specified in order by if order by is used.
        // And distinct field must be the first column to be ordered by.
        if ($distinct_id) {
          if (array_key_exists('id', $sort) && !empty($sort['id'])) {
            $query->orderBy('id' , $sort['id']);
          }
          else {
            $query->orderBy('id' , 'DESC');
          }
        }


        foreach ($sort as $sort_name => $sort_value) {
          if ($sort_name == 'id') {
            // when a query is distinct, the order by values must be defined in the select columns.
            if  ($distinct_id) {
              continue;
            }
            elseif ($distinct) {
              $query->orderBy('id' , is_null($sort_value) ? 'ASC' : $sort_value);
            }
            else {
              $query->orderBy('mer.id', is_null($sort_value) ? 'ASC' : $sort_value);
            }
          }
          elseif ($sort_name == 'title') {
            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $query->orderBy('title' , is_null($sort_value) ? 'ASC' : $sort_value);
            }
            else {
              $query->orderBy('mer.title', is_null($sort_value) ? 'ASC' : $sort_value);
            }
          }
          elseif ($sort_name == 'status') {
            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $query->orderBy('status' , is_null($sort_value) ? 'ASC' : $sort_value);
            }
            else {
              $query->orderBy('mer.status', is_null($sort_value) ? 'ASC' : $sort_value);
            }
          }
          elseif ($sort_name == 'step') {
            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $query->orderBy('step' , is_null($sort_value) ? 'ASC' : $sort_value);
            }
            else {
              $query->orderBy('mer.step', is_null($sort_value) ? 'ASC' : $sort_value);
            }
          }
          elseif ($sort_name == 'location') {
            if (!array_key_exists('mfcs_banner_locations', $already_joined)) {
              $query->innerJoin('mfcs_banner_locations', 'mbl', 'mer.location = mbl.id');
              $already_joined['mfcs_banner_locations'] = 'mbl';
            }

            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $existing_alias = array_search($already_joined['mfcs_banner_locations'] . '.human_name', $already_added);
              if ($existing_alias === FALSE) {
                $query->addField($already_joined['mfcs_banner_locations'], 'human_name', 'banner_locations_name');
                $already_added['banner_locations_name'] = $already_joined['mfcs_banner_locations'] . '.human_name';

                $query->orderBy('banner_locations_name', is_null($sort_value) ? 'ASC' : $sort_value);
              }
              else {
                $query->orderBy($existing_alias, is_null($sort_value) ? 'ASC' : $sort_value);
              }
            }
            else {
              $query->orderBy($already_joined['mfcs_banner_locations'] . '.human_name', is_null($sort_value) ? 'ASC' : $sort_value);
            }
          }
          elseif ($sort_name == 'building') {
            if (!array_key_exists('mfcs_banner_buildings', $already_joined)) {
              $query->innerJoin('mfcs_banner_buildings', 'mbb', 'mer.building = mbb.id');
              $already_joined['mfcs_banner_buildings'] = 'mbb';
            }

            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $existing_alias = array_search($already_joined['mfcs_banner_buildings'] . '.human_name', $already_added);
              if ($existing_alias === FALSE) {
                $query->addField($already_joined['mfcs_banner_buildings'], 'human_name', 'banner_buildings_name');
                $already_added['banner_buildings_name'] = $already_joined['mfcs_banner_buildings'] . '.human_name';

                $query->orderBy('banner_buildings_name', is_null($sort_value) ? 'ASC' : $sort_value);
              }
              else {
                $query->orderBy($existing_alias, is_null($sort_value) ? 'ASC' : $sort_value);
              }
            }
            else {
              $query->orderBy($already_joined['mfcs_banner_buildings'] . '.human_name', is_null($sort_value) ? 'ASC' : $sort_value);
            }
          }
          elseif ($sort_name == 'room') {
            if (!array_key_exists('mfcs_banner_rooms', $already_joined)) {
              $query->innerJoin('mfcs_banner_rooms', 'mbr', 'mer.room = mbr.id');
              $already_joined['mfcs_banner_rooms'] = 'mbr';
            }

            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $existing_alias = array_search($already_joined['mfcs_banner_rooms'] . '.human_name', $already_added);
              if ($existing_alias === FALSE) {
                $query->addField($already_joined['mfcs_banner_rooms'], 'human_name', 'banner_rooms_name');
                $already_added['banner_rooms_name'] = $already_joined['mfcs_banner_rooms'] . '.human_name';

                $query->orderBy('banner_rooms_name' , is_null($sort_value) ? 'ASC' : $sort_value);
              }
              else {
                $query->orderBy($existing_alias, is_null($sort_value) ? 'ASC' : $sort_value);
              }
            }
            else {
              $query->orderBy($already_joined['mfcs_banner_rooms'] . '.human_name', is_null($sort_value) ? 'ASC' : $sort_value);
            }
          }
          elseif ($sort_name == 'date') {
            if (!array_key_exists('mfcs_field_dates_date', $already_joined)) {
              if ($cancelled == MFCS_LOAD_CANCELLED_INDIVIDUAL || $cancelled == MFCS_LOAD_CANCELLED_ALL) {
                $query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mc.request_id = mfdd.request_id AND mc.dates_date = mfdd.revision');
              }
              else {
                // using <> for backwards compatibility where mfdd.cancelled may be NULL.
                $query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mc.request_id = mfdd.request_id AND mc.dates_date = mfdd.revision and mfdd.cancelled <> 1');
              }

              $already_joined['mfcs_field_dates_date'] = 'mfdd';
            }

            if (!array_key_exists('mfcs_field_dates_time_start', $already_joined)) {
              $query->leftJoin('mfcs_field_dates_time_start', 'mfdts', 'mc.request_id = mfdts.request_id AND mc.dates_time_start = mfdts.revision');
              $already_joined['mfcs_field_dates_time_start'] = 'mfdts';
            }

            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $existing_alias = array_search($already_joined['mfcs_field_dates_date'] . '.value', $already_added);
              if ($existing_alias === FALSE) {
                $query->addField($already_joined['mfcs_field_dates_date'], 'value', 'dates_date_value');
                $already_added['dates_date_value'] = $already_joined['mfcs_field_dates_date'] . '.value';

                $query->orderBy('dates_date_value', is_null($sort_value) ? 'ASC' : $sort_value);
              }
              else {
                $query->orderBy($existing_alias, is_null($sort_value) ? 'ASC' : $sort_value);
              }

              $existing_alias = array_search($already_joined['mfcs_field_dates_time_start'] . '.value', $already_added);
              if ($existing_alias === FALSE) {
                $query->addField($already_joined['mfcs_field_dates_time_start'], 'value', 'dates_time_start');
                $already_added['dates_time_start'] = $already_joined['mfcs_field_dates_time_start'] . '.value';

                $query->orderBy('dates_time_start', is_null($sort_value) ? 'ASC' : $sort_value);
              }
              else {
                $query->orderBy($existing_alias, is_null($sort_value) ? 'ASC' : $sort_value);
              }
            }
            else {
              $query->orderBy($already_joined['mfcs_field_dates_date'] . '.value', is_null($sort_value) ? 'ASC' : $sort_value);
              $query->orderBy($already_joined['mfcs_field_dates_time_start'] . '.value', is_null($sort_value) ? 'ASC' : $sort_value);
            }
          }
          elseif ($sort_name == 'submitted by') {
            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $query->orderBy('user_id' , is_null($sort_value) ? 'ASC' : $sort_value);
            }
            else {
              $query->orderBy('mer.user_id', is_null($sort_value) ? 'ASC' : $sort_value);
            }
          }
          elseif ($sort_name == 'submitted on') {
            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $query->orderBy('created' , is_null($sort_value) ? 'DESC' : $sort_value);
            }
            else {
              $query->orderBy('mer.created', is_null($sort_value) ? 'DESC' : $sort_value);
            }
          }
          elseif (!empty($sort_name)) {
            // when a query is distinct, the order by values must be defined in the select columns.
            if ($distinct || $distinct_id) {
              $existing_alias = array_search($sort_name . '.human_name', $already_added);
              if ($existing_alias === FALSE) {
                $query->orderBy($sort_name, $sort_value);
              }
              else {
                $query->orderBy($existing_alias, $sort_value);
              }
            }
            else {
              $query->orderBy($sort_name, $sort_value);
            }
          }
        }
      }
    }

    if ($count) {
      $return['count'] = $count_query->execute()->fetchField();
    }

    if ($results) {
      $found = $query->execute()->fetchAllAssoc('id');

      // fetch all available dates.
      $date_order = array();
      if (!empty($found)) {
        $sub_query = db_select('mfcs_current', 'mc');
        $sub_query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mc.request_id = mfdd.request_id AND mc.dates_date = mfdd.revision');
        $sub_query->innerJoin('mfcs_field_dates_time_start', 'mfdts', 'mc.request_id = mfdts.request_id AND mc.dates_time_start = mfdts.revision AND mfdd.delta = mfdts.delta');
        $sub_query->innerJoin('mfcs_field_dates_time_stop', 'mfdtsp', 'mc.request_id = mfdtsp.request_id AND mc.dates_time_stop = mfdtsp.revision AND mfdts.delta = mfdtsp.delta');
        $sub_query->innerJoin('mfcs_field_dates_category', 'mfdc', 'mc.request_id = mfdc.request_id AND mc.dates_category = mfdc.revision AND mfdts.delta = mfdc.delta');

        $sub_query->addField('mfdd', 'request_id', 'id');
        $sub_query->addField('mfdd', 'value', 'date');
        $sub_query->addField('mfdd', 'delta', 'delta');
        $sub_query->addField('mfdts', 'value', 'time_start');
        $sub_query->addField('mfdtsp', 'value', 'time_stop');
        $sub_query->addField('mfdc', 'value', 'category');
        $sub_query->addField('mfdd', 'cancelled', 'cancelled');

        $sub_query->condition('mfdd.request_id', array_keys($found), 'IN');

        if ($cancelled != MFCS_LOAD_CANCELLED_INDIVIDUAL && $cancelled != MFCS_LOAD_CANCELLED_ALL) {
          $sub_query->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.
        }

        $sub_results = $sub_query->execute()->fetchAll();

        $initialized_date = array();
        foreach ($sub_results as $delta => $sub_result) {
          if (!array_key_exists($sub_result->id, $initialized_date)) {
            $found[$sub_result->id]->date = array();
            $found[$sub_result->id]->time_start = array();
            $found[$sub_result->id]->time_stop = array();
            $found[$sub_result->id]->category = array();
            $found[$sub_result->id]->cancelled = array();

            $initialized_date[$sub_result->id] = $sub_result->id;
          }

          $found[$sub_result->id]->date[$sub_result->delta] = $sub_result->date;
          $found[$sub_result->id]->time_start[$sub_result->delta] = $sub_result->time_start;
          $found[$sub_result->id]->time_stop[$sub_result->delta] = $sub_result->time_stop;
          $found[$sub_result->id]->category[$sub_result->delta] = $sub_result->category;
          $found[$sub_result->id]->cancelled[$sub_result->delta] = $sub_result->cancelled;
        }

        unset($sub_results);
      }
    }
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    return FALSE;
  }


  if ($results) {
    $return['results'] = $found;
  }

  return $return;
}

/**
 * Recursively append search conditions for to a given query.
 *
 * @param object|null $query
 *   The query object. Set to null if not using.
 * @param object|null $count_query
 *   The query object for the count query. Set to null if not using.
 * @param object $operand
 *   The query operand, such as and, or or for processing the conditions.
 * @param array $already_joined
 *   An array of table names that have already been joined in the query object.
 * @param int $already_joined_count
 *   A counter for uniquely generating table alias names.
 * @param array $already_added
 *   An array of field names that have already been added as select parameters
 *   for the query object.
 * @param array $conditions
 *   The collection of search conditions.
 * @param int $recurse_count
 *   A number representing the number of executions this function has within
 *   itself, including the very first call (should start at 1).
 * @param string $like
 *   The appropriate SQL like or ilike string for sensitive and insensitive.
 *
 * @param bool
 *   TRUE when a valid field is found and added to the $operand and FALSE
 *   otherwise.
 */
function mfcs_request_process_query_search_array(&$query, &$count_query, &$operand, &$already_joined, &$already_joined_count, &$already_added, $conditions, $recurse_count, $like) {
  if (!is_null($query) && !is_object($query)) {
    cf_error::invalid_object('query');
    return FALSE;
  }

  if (!is_null($count_query) && !is_object($count_query)) {
    cf_error::invalid_object('count_query');
    return FALSE;
  }

  if (!is_object($operand)) {
    cf_error::invalid_object('operand');
    return FALSE;
  }

  if (!is_array($conditions)) {
    cf_error::invalid_array('conditions');
    return FALSE;
  }

  if (!cf_is_integer($recurse_count)) {
    cf_error::invalid_integer('recurse_count');
    return FALSE;
  }

  if (!is_array($already_joined)) {
    cf_error::invalid_array('already_joined');
    return FALSE;
  }

  if (!cf_is_integer($already_joined_count)) {
    cf_error::invalid_integer('already_joined_count');
    return FALSE;
  }

  if (!is_array($already_added)) {
    cf_error::invalid_array('already_added');
    return FALSE;
  }

  if (!cf_is_integer($recurse_count)) {
    cf_error::invalid_integer('recurse_count');
    return FALSE;
  }

  if (!is_string($like)) {
    cf_error::invalid_string('like');
    return FALSE;
  }

  if ($recurse_count > MFCS_MAX_SEARCH_RECURSION) {
    return FALSE;
  }
  $found_values = FALSE;
  $expression_count = 0;

  // process the inner fields, can be either a 'value_+', 'field_+', 'or_+', 'and_+', 'nor_+', or 'nand_+'.
  foreach ($conditions as $search_operand_or_field => $search_values) {
    $search_op = explode('_', $search_operand_or_field, 2);

    if (count($search_op) != 2) {
      // not valid, just skip.
      continue;
    }

    if (!is_array($search_values) || empty($search_values)) {
      // not valid, just skip.
      continue;
    }

    if ($search_op[0] == 'field') {
      if (!array_key_exists('search', $search_values)) {
        // not valid, just skip.
        continue;
      }

      if (empty($search_values['group_name']) || empty($search_values['field_name']) || empty($search_values['column'])) {
        // not valid, just skip.
        continue;
      }

      $join = 'innerJoin';
      if (isset($search_values['join'])) {
        if ($search_values['join'] == MFCS_JOIN_LEFT) {
          $join = 'leftJoin';
        }
        elseif ($search_values['join'] == MFCS_JOIN_RIGHT) {
          $join = 'rightJoin';
        }
        elseif ($search_values['join'] == MFCS_JOIN_OUTER) {
          $join = 'outerJoin';
        }
      }

      if ($search_values['group_name'] == 'mer') {
        // handle special case of the 'mer' fields, which are already joined and available.
        $field_alias = 'mer';
        $search_values['column'] = $search_values['field_name'];
      }
      else {
        $mfcs_field = 'mfcs_field_' . $search_values['group_name'] . '_' . $search_values['field_name'];

        if (array_key_exists($mfcs_field, $already_joined)) {
          $field_alias = $already_joined[$mfcs_field];

          if ($field_alias == 'mer') {
            $search_values['column'] = $search_values['field_name'];
          }
        }
        else {
          if (!array_key_exists($mfcs_field, $already_joined)) {
            $already_joined[$mfcs_field] = 'mfg_c_' . $already_joined_count;
            $already_joined_count++;
          }

          $field_alias = $already_joined[$mfcs_field];

          if (isset($search_values['multiple']) && $search_values['multiple']) {
            if (!is_null($query)) $query->{$join}($mfcs_field, $field_alias, 'mc.request_id = ' . $field_alias . '.request_id AND mc.' . $search_values['group_name'] . '_' . $search_values['field_name'] . ' = ' . $field_alias . '.revision');
            if (!is_null($count_query)) $count_query->{$join}($mfcs_field, $field_alias, 'mc.request_id = ' . $field_alias . '.request_id AND mc.' . $search_values['group_name'] . '_' . $search_values['field_name'] . ' = ' . $field_alias . '.revision');
          }
          else {
            if (!is_null($query)) $query->{$join}($mfcs_field, $field_alias, 'mc.request_id = ' . $field_alias . '.request_id AND mc.' . $search_values['group_name'] . '_' . $search_values['field_name'] . ' = ' . $field_alias . '.revision AND ' . $field_alias . '.delta = 0');
            if (!is_null($count_query)) $count_query->{$join}($mfcs_field, $field_alias, 'mc.request_id = ' . $field_alias . '.request_id AND mc.' . $search_values['group_name'] . '_' . $search_values['field_name'] . ' = ' . $field_alias . '.revision AND ' . $field_alias . '.delta = 0');
          }
        }

        if (!array_key_exists($search_values['field_name'], $already_added)) {
          if (!is_null($query)) $query->addField($field_alias, $search_values['column'], $search_values['group_name'] . '_' . $search_values['field_name']);
          // note: count_query should not add fields.
        }
      }

      $operator = '=';
      $search_string = $search_values['search'];
      if ($search_values['operator'] == MFCS_OPERATOR_LESS_THAN) {
        $operator = '<';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_LESS_THAN_EQUAL) {
        $operator = '<=';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_EQUAL) {
        $operator = '=';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_LIKE) {
        if ($search_string == "") {
          $operator = '=';
        }
        else {
          $operator = $like;
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_SLIKE) {
        if ($search_string == "") {
          $operator = '=';
        }
        else {
          $operator = 'LIKE';
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_ILIKE) {
        if ($search_string == "") {
          $operator = '=';
        }
        else {
          $operator = 'ILIKE';
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_GREATER_THAN_EQUAL) {
        $operator = '>=';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_GREATER_THAN) {
        $operator = '>';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_EQUAL) {
        $operator = '<>';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_LIKE) {
        if ($search_string == "") {
          $operator = '<>';
        }
        else {
          $operator = 'NOT ' . $like;
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_SLIKE) {
        if ($search_string == "") {
          $operator = '<>';
        }
        else {
          $operator = 'NOT LIKE';
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_ILIKE) {
        if ($search_string == "") {
          $operator = '<>';
        }
        else {
          $operator = 'NOT ILIKE';
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_NULL) {
        $operand->isNull($field_alias . '.' . $search_values['column']);

        $found_values = TRUE;
        continue;
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_NOT_NULL) {
        $operand->isNotNull($field_alias . '.' . $search_values['column']);

        $found_values = TRUE;
        continue;
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_IN) {
        $operator = 'IN';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_NOT_IN) {
        $operator = 'NOT IN';
      }

      $operand->condition($field_alias . '.' . $search_values['column'], $search_string, $operator);

      $found_values = TRUE;
      continue;
    }
    elseif ($search_op[0] == 'value') {
      if (!array_key_exists('search', $search_values)) {
        // not valid, just skip.
        continue;
      }

      if (empty($search_values['field'])) {
        // not valid, just skip.
        continue;
      }

      $expression = FALSE;
      if (array_key_exists('expression', $search_values) && is_bool($search_values['expression'])) {
        $expression = $search_values['expression'];
      }

      $field = $search_values['field'];

      $operator = '=';
      $search_string = $search_values['search'];
      if ($search_values['operator'] == MFCS_OPERATOR_LESS_THAN) {
        $operator = '<';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_LESS_THAN_EQUAL) {
        $operator = '<=';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_EQUAL) {
        $operator = '=';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_LIKE) {
        if ($search_string == "") {
          $operator = '=';
        }
        else {
          $operator = $like;
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_SLIKE) {
        if ($search_string == "") {
          $operator = '=';
        }
        else {
          $operator = 'LIKE';
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_ILIKE) {
        if ($search_string == "") {
          $operator = '=';
        }
        else {
          $operator = 'ILIKE';
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_GREATER_THAN_EQUAL) {
        $operator = '>=';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_GREATER_THAN) {
        $operator = '>';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_EQUAL) {
        $operator = '<>';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_LIKE) {
        if ($search_string == "") {
          $operator = '<>';
        }
        else {
          $operator = 'NOT ' . $like;
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_SLIKE) {
        if ($search_string == "") {
          $operator = '<>';
        }
        else {
          $operator = 'NOT LIKE';
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_NOT_ILIKE) {
        if ($search_string == "") {
          $operator = '<>';
        }
        else {
          $operator = 'NOT ILIKE';
          $search_string = '%' . db_like($search_values['search']) . '%';
        }
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_NULL) {
        if ($expression) {
          // not supported.
          continue;
        }
        else {
          $operand->isNull($field);
        }

        $found_values = TRUE;
        continue;
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_NOT_NULL) {
        if ($expression) {
          // not supported.
          continue;
        }
        else {
          $operand->isNotNull($field);
        }

        $found_values = TRUE;
        continue;
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_IN) {
        $operator = 'IN';
      }
      elseif ($search_values['operator'] == MFCS_OPERATOR_IS_NOT_IN) {
        $operator = 'NOT IN';
      }

      if ($expression) {
        // The count_query and query may have different placeholder orderings, so create a custom placeholder counter.
        $placeholder = ':mfcs_expression_' . $recurse_count . '_' . $search_operand_or_field . '_' . $expression_count;
        $operand->where($field . ' ' . $operator . ' ' . $placeholder, array($placeholder => $search_string));
        $expression_count++;
      }
      else {
        $operand->condition($field, $search_string, $operator);
      }

      $found_values = TRUE;
      continue;
    }
    elseif ($search_op[0] == 'or') {
      $inner_operand = db_or();
    }
    elseif ($search_op[0] == 'and') {
      $inner_operand = db_and();
    }
    elseif ($search_op[0] == 'nor') {
      $inner_operand = db_or();
      $inner_operand->not();
    }
    elseif ($search_op[0] == 'nand') {
      $inner_operand = db_and();
      $inner_operand->not();
    }

    $next_count = $recurse_count + 1;
    $result = mfcs_request_process_query_search_array($query, $count_query, $inner_operand, $already_joined, $already_joined_count, $already_added, $search_values, $next_count, $like);

    if ($result) {
      $operand->condition($inner_operand);
      $found_values = TRUE;
    }

    unset($next_count);
  }

  return $found_values;
}

/**
 * Loads the reviews by step, classification, and date.
 *
 * @parem int $request_id
 *   The numeric request id representing the request to process.
 * @parem array $steps
 *   (optional) Limit the results to only the provided steps.
 * @parem array $decisions
 *   (optional) An array of decisions to limit the results to.
 *
 * @return array|bool
 *   An array of reviews by order of step, classification, and then date
 *   (with the date descending). FALSE is returned on error.
 */
function mfcs_get_latest_reviews($request_id, $steps = array(), $decisions = array()) {
  if (!cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  if (!is_array($steps)) {
    cf_error::invalid_array('steps');
    return FALSE;
  }

  if (!is_array($decisions)) {
    cf_error::invalid_array('decisions');
    return FALSE;
  }

  $reviews = array();
  try {
    $query = db_select('mfcs_field_review_review', 'mfrr');

    $query->innerJoin('mfcs_review_classifications', 'mrc', 'mfrr.id = mrc.review_id');
    $query->innerJoin('mfcs_current', 'mc', 'mfrr.request_id = mc.request_id and mfrr.revision = mc.review_review');

    $query->addField('mfrr', 'id', 'id');
    $query->addField('mfrr', 'user_id', 'user_id');
    $query->addField('mfrr', 'date', 'date');
    $query->addField('mfrr', 'step', 'step');
    $query->addField('mfrr', 'decision', 'decision');
    $query->addField('mrc', 'classification', 'classification');

    $query->condition('mfrr.request_id', $request_id);

    if (!empty($steps)) {
      $query->condition('mfrr.step', $steps, 'IN');
    }

    if (!empty($decisions)) {
      $query->condition('mfrr.decision', $decisions, 'IN');
    }

    // some classifications are only allowed in certain steps.
    $and = db_and();
    $and->condition('mfrr.step', array(MFCS_REVIEW_STEP_REVIEW, MFCS_REVIEW_STEP_REQUIREMENTS), 'IN');
    $and->condition('mrc.classification', array(MFCS_REVIEWER_CLASSIFICATION_VENUE_COORDINATOR, MFCS_REVIEWER_CLASSIFICATION_VENUE_COORDINATOR_PROXY), 'IN');
    $and->not();
    $query->condition($and);

    $query->orderBy('mfrr.step');
    $query->orderBy('mrc.classification');
    $query->orderBy('mfrr.date', 'DESC');

    $results = $query->execute()->fetchAll();
    if (is_array($results)) {
      foreach ($results as $result) {

        if (!isset($reviews[$result->step])) {
          $reviews[$result->step] = array();
        }

        if (!isset($reviews[$result->step][$result->classification])) {
          $reviews[$result->step][$result->classification] = array();
        }

        $reviews[$result->step][$result->classification][$result->id] = $result;
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $reviews;
}

/**
 * Builds a table listing of requests.
 *
 * @param array $items
 *   An array of items to add to the table as returned by
 *   mfcs_request_load_listing().
 * @param int $max_rows
 *   The number of items allowed to be listed on the table at one time.
 * @param array|null $columns
 *   (optional) specify the columns to use. NULL means use default.
 * @param object|null $user
 *   (optional) The user to populate access control based data.
 * @param array|null $extra
 *   (optional) Additional information:
 *   - table_sort: Use the specified table sort instead of the default.
 *   - table_caption: Display the provided text as a caption instead of the default.
 *   - table_summary: Display the provided text as a summary instead of the default.
 *   - table_empty: Display the provided text on empty instead of the default.
 *
 * @return array
 *   A generated table array structure for passing to theme_table().
 *   Additional keys are added to the table structure:
 *   - 'error': TRUE on error, FALSE on when there is no error.
 *
 * @see: mfcs_request_load_listing()
 * @see: theme_table()
 */
function mfcs_build_request_table($items, $max_rows, $columns = NULL, $user = NULL, $extra = array()) {
  if (is_null($columns)) {
    $columns = array('id' => "ID", 'title' => "Title", 'building' => "Building", 'room' => "Room", 'date' => "Date", 'submitted_on' => "Submitted On", 'operations' => "Operations");
  }

  if (!is_array($columns)) {
    cf_error::invalid_array('columns');
    $table['error'] = TRUE;
    return $table;
  }


  if (!is_array($items) && $items !== FALSE) {
    cf_error::invalid_array('items');
    $table['error'] = TRUE;
    return $table;
  }

  if (is_null($user) || !is_object($user)) {
    $user = cf_current_user();
  }

  if (!is_array($extra)) {
    cf_error::invalid_array('extra');
    $table['error'] = TRUE;
    return $table;
  }

  $table_sort = TRUE;
  if (array_key_exists('table_sort', $extra) && !$extra['table_sort']) {
    $table_sort = FALSE;
  }

  $table_caption = "Requests";
  if (array_key_exists('table_caption', $extra) && is_string($extra['table_caption'])) {
    $table_caption = $extra['table_caption'];
  }

  $table_summary = "A listing of requests associated by ID.";
  if (array_key_exists('table_summary', $extra) && is_string($extra['table_summary'])) {
    $table_summary = $extra['table_summary'];
  }

  $table_empty = "No requests were found.";
  if (array_key_exists('table_empty', $extra) && is_string($extra['table_empty'])) {
    $table_empty = $extra['table_empty'];
  }

  $table = array();
  foreach ($columns as $column_name => $column_title) {
    $column_class = array();

    if ($column_name == 'operations') {
      $column_class[] = 'no-print';

      $table['header'][$column_name] = array(
        'data' => $column_title,
        'align' => 'center',
        'class' => $column_class,
      );
    }
    else {
      $table['header'][$column_name] = array(
        'data' => $column_title,
        'align' => 'center',
        'class' => $column_class,
      );

      if ($table_sort) {
        $table['header'][$column_name]['field'] = $column_name;
      }
    }
  }

  $table['attributes'] = array();
  $table['attributes']['summary'] = $table_summary;
  $table['rows'] = array();
  $table['empty'] = $table_empty;
  $table['caption'] = $table_caption;

  global $base_path;
  global $mfcs_determined;

  $url_arguments = '';
  if (!empty($mfcs_determined['complete'])) {
    $url_arguments .= '?' . $mfcs_determined['complete'];
  }

  $rows = array();
  $rows_count = 0;

  if (empty($items)) {
    return $table;
  }

  $administer = user_access('mfcs administer', $user);
  $manager = user_access('mfcs manage', $user);

  $item_ids = array_keys($items);
  $can_create_requests = mfcs_page_request_access('create', $item_ids, $user);
  $can_edit_requests = mfcs_page_request_access('edit', $item_ids, $user);
  $can_review_requests = mfcs_page_request_access('review', $item_ids, $user);
  $can_log_requests = mfcs_page_request_access('log', $item_ids, $user);
  $can_manage_requests = mfcs_page_request_access('manage', $item_ids, $user);
  $can_history_requests = mfcs_page_request_access('history', $item_ids, $user);
  #$can_delete_requests = mfcs_page_request_access('delete', $item_ids, $user);
  $can_delete_requests = FALSE;

  if (!is_array($can_create_requests)) {
    $can_create_requests = array();
  }

  if (!is_array($can_edit_requests)) {
    $can_edit_requests = array();
  }

  if (!is_array($can_review_requests)) {
    $can_review_requests = array();
  }

  if (!is_array($can_log_requests)) {
    $can_log_requests = array();
  }

  if (!is_array($can_manage_requests)) {
    $can_manage_requests = array();
  }

  if (!is_array($can_history_requests)) {
    $can_history_requests = array();
  }

  if (!is_array($can_delete_requests)) {
    $can_delete_requests = array();
  }

  $status_options = mfcs_get_request_status_list_options();
  $step_options = mfcs_get_request_steps_list_options();
  $location_options = mfcs_get_request_location_list_options(NULL, FALSE, TRUE);
  $room_options = mfcs_get_request_room_list_options(NULL, NULL, TRUE);
  $building_options = array();

  foreach ($items as $item) {
    $row = array();
    $rows_count++;

    // Rows per page + 1 is loaded so that it can be detected whether or not a 'next' link needs to be provided.
    if ($rows_count > $max_rows) {
      break;
    }

    if (isset($columns['id'])) {
      $row['id'] = array(
        'data' => $item->id,
        'class' => 'column-id',
      );
    }

    if (isset($columns['title'])) {
      $row['title'] = array(
        'data' => check_plain($item->title),
        'class' => 'column-title',
      );
    }

    if (!array_key_exists($item->location, $building_options)) {
      $building_options[$item->location] = mfcs_get_request_building_list_options($item->location, NULL, TRUE);
    }

    if (isset($columns['location'])) {
      $row['location'] = array(
        'data' => '',
        'class' => 'column-location',
      );

      if (!empty($item->location)) {
        if (isset($location_options[$item->location])) {
          $row['location']['data'] = check_plain($location_options[$item->location]);
        }
      }
    }

    if (isset($columns['building'])) {
      $row['building'] = array(
        'data' => '',
        'class' => 'column-building',
      );

      if (!empty($item->building)) {
        if (isset($building_options[$item->location][$item->building])) {
          $row['building']['data'] = check_plain($building_options[$item->location][$item->building]);
        }
      }
    }

    if (isset($columns['room'])) {
      $row['room'] = array(
        'data' => '',
        'class' => 'column-room',
      );

      if (!empty($item->room)) {
        if (isset($room_options[$item->room])) {
          $row['room']['data'] = check_plain($room_options[$item->room]);
        }
      }
    }

    if (isset($columns['date'])) {
      $row['date'] = array(
        'data' => NULL,
        'class' => 'column-date',
      );

      if (isset($item->date) && is_array($item->date)) {
        foreach ($item->date as $delta => $date) {
          if (is_null($row['date']['data'])) {
            $row['date']['data'] = '';
          }
          else {
            $row['date']['data'] .= '<br>';
          }

          $row['date']['data'] .= check_plain(date("Y/m/d", $date));

          if (array_key_exists($delta, $item->time_start) && !is_null($item->time_start[$delta]) && array_key_exists($delta, $item->time_stop) && !is_null($item->time_stop[$delta])) {
            $row['date']['data'] .= ' ' . check_plain(date("h:i a", $item->time_start[$delta]));
            $row['date']['data'] .= ' to ' . check_plain(date("h:i a", $item->time_stop[$delta]));
          }
        }
      }
      else {
        $row['date']['data'] = '';
      }
    }

    if (isset($columns['status'])) {
      $row['status'] = array(
        'data' => $status_options[$item->status],
        'class' => 'column-status',
      );
    }

    if (isset($columns['step'])) {
      $row['step'] = array(
        'data' => $step_options[$item->step],
        'class' => 'column-step',
      );
    }

    if (isset($columns['submitted_by'])) {
      $row['submitted_by'] = array(
        'data' => '',
        'class' => 'column-submitted_by',
      );

      $submitter = user_load($item->user_id);

      if (is_object($submitter)) {
        $name = $submitter->name;

        if (!empty($submitter->field_user_first_name['und'][0]['value'])) {
          $name = $submitter->field_user_first_name['und'][0]['value'];

          if (!empty($submitter->field_user_last_name['und'][0]['value'])) {
            $name .= ' ' . $submitter->field_user_last_name['und'][0]['value'];
          }

          $name .= ' (' . $submitter->name . ')';
        }

        if ($manager || $administer) {
          $row['submitted_by']['data'] = '<a href="' . $base_path . 'requests/users-0/view/' . $submitter->uid . $url_arguments . '">' . $name . '</a>';
        }
        else {
          $row['submitted_by']['data'] = $name;
        }
      }
      else {
        watchdog(MFCS_WATCHDOG_ID, "Failed to load the submitter a user id of %user_id. No submitter name can be provided.", array('%user_id' => $item->user_id), WATCHDOG_WARNING);
        $row['submitter_name'] = '';
      }

      unset($submitter);
    }

    if (isset($columns['submitted_on'])) {
      $date_stamp = $item->created;

      $row['submitted_on'] = array(
        'data' => check_plain(date("Y/m/d h:i a", $date_stamp)),
        'class' => 'column-submitted_on',
      );
    }

    if (isset($columns['operations'])) {
      $row['operations'] = array(
        'data' => '',
        'class' => 'column-operations no-print',
      );

      $row['operations']['data'] = '';

      $row['operations']['data'] .= '<a href="' . $base_path . 'requests/view-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-view">View</a> ';

      if (array_key_exists($item->id, $can_edit_requests) && $can_edit_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/edit-0/' . $item->id . '/request' . $url_arguments . '" class="operation-link operation-link-edit">Edit</a> ';
      }

      if (array_key_exists($item->id, $can_review_requests) && $can_review_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/view-0/' . $item->id . '/' . MFCS_VIEW_MODE_OPERATIONS . $url_arguments . '" class="operation-link operation-link-review">Review</a> ';
      }

      if (array_key_exists($item->id, $can_log_requests) && $can_log_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/view-0/' . $item->id . '/' . MFCS_VIEW_MODE_LOG . $url_arguments . '" class="operation-link operation-link-log">Log</a> ';
      }

      if (array_key_exists($item->id, $can_manage_requests) && $can_manage_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/manage-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-manage">Manage</a> ';
      }

      if (array_key_exists($item->id, $can_history_requests) && $can_history_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/history-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-history">History</a> ';
      }

      if (array_key_exists($item->id, $can_delete_requests) && $can_delete_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/delete-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-delete">Delete</a> ';
      }

      if (array_key_exists($item->id, $can_create_requests) && $can_create_requests[$item->id]) {
        $row['operations']['data'] .= '<a href="' . $base_path . 'requests/create-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-clone">Copy</a> ';
      }
    }

    $rows[$item->id] = $row;
  }

  $table['rows'] = $rows;
  $table['error'] = FALSE;

  return $table;
}

/**
 * Builds an ajax table listing of requests.
 *
 * @param array $items_returned
 *   The return array from mfcs_request_load_listing() containing both the
 *   results and the count.
 * @param array $conditions
 *   The conditions that were passed to mfcs_request_load_listing().
 * @param array $options
 *   The options that were passed to mfcs_request_load_listing(). This expects
 *   to have additional information added specific to this function, such as:
 *   'columns': an array containing the column information.
 *   'columns_default': An array of integers representing the column with the
 *    default order and the values being either 'asc' or 'desc'.
 *   'table_caption': Display the provided text as a caption instead of the default.
 *   'table_summary': Display the provided text as a summary instead of the default.
 *   'table_empty': Display the provided text on empty instead of the default.
 * @param object|null $user
 *   (optional) The user to populate access control based data.
 *
 * @return array
 *   A generated table array structure for passing to theme_table().
 *   Additional keys are added to the table structure:
 *   - 'error': TRUE on error, FALSE on when there is no error.
 *
 * @see: mfcs_request_load_listing()
 * @see: mfcs_build_request_ajax_table()
 * @see: theme_table()
 */
function mfcs_build_request_ajax_table($items_returned, $conditions, $options, $user = NULL) {
  if (!is_array($items_returned) && $items_returned !== FALSE) {
    cf_error::invalid_array('items_returned');
    return array('error' => TRUE);
  }

  if (!is_array($conditions)) {
    cf_error::invalid_array('conditions');
    return array('error' => TRUE);
  }

  if (!is_array($options)) {
    cf_error::invalid_array('options');
    return array('error' => TRUE);
  }

  if (is_null($user)) {
    $user = cf_current_user();
  }

  if (!is_object($user)) {
    cf_error::invalid_object('user');
    return array('error' => TRUE);
  }

  $table_caption = "Requests";
  if (array_key_exists('table_caption', $options) && is_string($options['table_caption'])) {
    $table_caption = $options['table_caption'];
  }

  $table_summary = NULL;
  if (array_key_exists('table_summary', $options) && is_string($options['table_summary'])) {
    $table_summary = $options['table_summary'];
  }

  $table_empty = "No requests were found.";
  if (array_key_exists('table_empty', $options) && is_string($options['table_empty'])) {
    $table_empty = $options['table_empty'];
  }

  $table = array();
  $table['attributes'] = array(
    'class' => array(
      'no_default',
      'display',
      'hover',
      'order-column',
      'stripe',
      'cell-border',
    ),
  );
  $table['headers'] = array();
  $table['rows'] = array();
  $table['empty'] = $table_empty;
  $table['caption'] = $table_caption;

  if (!is_null($table_summary)) {
    $table['attributes']['summary'] = $table_summary;
  }

  $columns = array(
    'id' => array(
      'column' => 'id',
      'name' => "ID",
      'class' => 'column-id ',
      'sanitize' => FALSE,
      'align' => 'center',
    ),
    'title' => array(
      'column' => 'title',
      'name' => "Title",
      'class' => 'column-title ',
      'align' => 'center',
    ),
    'building' => array(
      'column' => 'building',
      'name' => "Building",
      'class' => 'column-building ',
      'align' => 'center',
    ),
    'room' => array(
      'column' => 'room',
      'name' => "Room",
      'class' => 'column-room ',
      'align' => 'center',
    ),
    'date' => array(
      'column' => 'date',
      'name' => "Date",
      'class' => 'column-date ',
      'align' => 'center',
    ),
    'submitted_on' => array(
      'column' => 'submitted_on',
      'name' => "Submitted On",
      'class' => 'column-submitted_on ',
      'align' => 'center',
    ),
    'operations' => array(
      'column' => NULL,
      'name' => "Operations",
      'class' => 'column-operations no-print ',
      'align' => 'center',
    ),
  );

  $rowId = '0';
  if (isset($options['rowId']) && (is_string($options['rowId']) || is_null($options['rowId']))) {
    $rowId = $options['rowId'];
  }

  if (isset($options['columns']) && is_array($options['columns'])) {
    $columns = $options['columns'];
  }

  $columns_default = array(0 => 'desc');
  if (isset($options['columns_default'])) {
    if (is_numeric($options['columns_default'])) {
      $columns_default = (int) $options['columns_default'];
    }
    elseif (is_array($options['columns_default'])) {
      $columns_default = array();
      foreach ($options['columns_default'] as $sort_column => $sort_direction) {
        if (!is_numeric($sort_column)) continue;

        if ($sort_direction == 'asc' || $sort_direction == 'desc') {
          $columns_default[$sort_column] = $sort_direction;
        }
      }
    }
  }

  $items = array();
  if (isset($items_returned['results']) && is_array($items_returned['results'])) {
    $items = $items_returned['results'];
  }


  // populate the table headers.
  $table['header'] = array();
  foreach ($columns as $column_id => $column) {
    $table['header'][$column_id] = array(
      'field' => $column_id,
      'data' => isset($column['name']) ? $column['name'] : '',
      'align' => isset($column['align']) ? $column['align'] : '',
      'class' => isset($column['class']) ? $column['class'] : '',
    );

    if (array_key_exists('field', $column) && is_null($column['field'])) {
      unset($table['header'][$column_id]['field']);
    }
  }


  // populate the table rows.
  $table['rows'] = mfcs_build_request_ajax_table_process_rows($items, $columns, $user);


  // populate the datatable settings.
  $table['datatable_settings'] = array(
    'order' => $columns_default,
    'columns' => array(),
    #'stateSave' => TRUE,
    'lengthMenu' => array(
      10 => '10',
      25 => '25',
      50 => '50',
      75 => '75',
      100 => '100',
      -1 => '"All"',
    ),
    'processing' => FALSE,
    'serverSide' => FALSE,
    'deferRender' => TRUE,
    'displayStart' => isset($options['start']) ? $options['start'] : 0,
    'pageLength' => isset($options['limit']) ? $options['limit'] : 20,
    'dom' => 'lfCrtip',
    'KeyTable' => FALSE,
    'rowId' => '0',
    'oColVis' => array(
      'buttonText' => '"Show / Hide"',
    ),
    'oLanguage' => array(
      'sSearch' => '"Filter"',
      'sEmptyTable' => '"' . $table['empty'] . '"',
    ),
    'language' => array(
      'emptyTable' => '"' . $table['empty'] . '"',
    ),
    'searchDelay' => 1200,
    'pagingType' => 'input',
  );

  // see: //datatables.net/reference/option/rowId
  if (!is_null($rowId)) {
    $table['datatable_settings']['rowId'] = $rowId;
  }

  foreach ($columns as $column_id => $column) {
    $table['datatable_settings']['columns'][$column_id] = $column;

    if (!array_key_exists('class', $table['datatable_settings']['columns'][$column_id])) {
      $table['datatable_settings']['columns'][$column_id]['class'] = array();
    }

    $table['datatable_settings']['columns'][$column_id]['class'][] = 'column-' . $column_id;

    if ($column_id == 'operations') {
      $table['datatable_settings']['columns'][$column_id]['class'][] = 'no-print';
    }

    $table['datatable_settings']['columns'][$column_id]['className'] = implode(' ', $table['datatable_settings']['columns'][$column_id]['class']);

    if (array_key_exists('visible', $column) && $column['visible'] === FALSE) {
      $table['datatable_settings']['columns'][$column_id]['visible'] = FALSE;
    }
  }

  if (array_key_exists('ajax_path', $options) && is_string($options['ajax_path']) && !empty($options['ajax_path'])) {
    $table['datatable_settings']['ajax'] = array(
      'url' => $options['ajax_path'],
      'type' => "'POST'",
    );

    $table['datatable_settings']['processing'] = TRUE;
    $table['datatable_settings']['serverSide'] = TRUE;

    if (isset($options['only_requester']) && is_bool($options['only_requester'])) {
      $url_options = array();
      $ajax_path = preg_replace("/'/", '', $options['ajax_path']);
      preg_match('/\?[^?]*$/', $ajax_path, $url_options);
      $ajax_path = preg_replace('/\?[^?]*$/', '', $ajax_path);

      if (isset($url_options[0])) {
        $url_options = $url_options[0];
      }
      else {
        $url_options = '';
      }

      $showing_my_requests = "function (e, dt, node, config) {" . "\n";
      $showing_my_requests .= "  var data = dt.ajax.params();" . "\n";
      $showing_my_requests .= "  var url = dt.ajax.url();" . "\n";

      $showing_my_requests .= "  if (url == '" . $ajax_path . "/my_requests' || url == '" . $ajax_path . "/my_requests" . $url_options . "') {" . "\n";
      $showing_my_requests .= "    dt.ajax.url('" . $ajax_path . "/all_requests" . $url_options . "');" . "\n";
      $showing_my_requests .= "    dt.buttons('.datatable-showing_requests').text('Show My Requests');" . "\n";
      $showing_my_requests .= "  }" . "\n";
      $showing_my_requests .= "  else if (url == '" . $ajax_path . "/all_requests' || url == '" . $ajax_path . "/all_requests" . $url_options . "') {" . "\n";
      $showing_my_requests .= "    dt.ajax.url('" . $ajax_path . "/my_requests" . $url_options . "');" . "\n";
      $showing_my_requests .= "    dt.buttons('.datatable-showing_requests').text('Show All Requests');" . "\n";
      $showing_my_requests .= "  }" . "\n";
      $showing_my_requests .= "  else {" . "\n";

      if ($options['only_requester']) {
        $showing_my_requests .= "    dt.ajax.url('" . $ajax_path . "/all_requests" . $url_options . "');" . "\n";
        $showing_my_requests .= "    dt.buttons('.datatable-showing_requests').text('Show My Requests');" . "\n";
      }
      else {
        $showing_my_requests .= "    dt.ajax.url('" . $ajax_path . "/my_requests" . $url_options . "');" . "\n";
        $showing_my_requests .= "    dt.buttons('.datatable-showing_requests').text('Show All Requests');" . "\n";
      }

      $showing_my_requests .= "  }" . "\n";
      $showing_my_requests .= "  dt.ajax.reload();" . "\n";
      $showing_my_requests .= "}" . "\n";

      $table['datatable_settings']['dom'] = 'lfCBrtip';
      $table['datatable_settings']['buttons'] = array();
      $table['datatable_settings']['buttons']['Show Requests'] = array(
        'text' => "'Show All Requests'",
        'action' => $showing_my_requests,
        'className' => "'datatable-showing_requests'",
      );
      unset($showing_my_requests);

      if ($options['only_requester'] === FALSE) {
        $table['datatable_settings']['buttons']['Show Requests']['text'] = "'Show My Requests'";
      }
    }
    elseif (isset($options['only_reviewer']) && is_bool($options['only_reviewer'])) {
      $url_options = array();
      $ajax_path = preg_replace("/'/", '', $options['ajax_path']);
      preg_match('/\?[^?]*$/', $ajax_path, $url_options);
      $ajax_path = preg_replace('/\?[^?]*$/', '', $ajax_path);

      if (isset($url_options[0])) {
        $url_options = $url_options[0];
      }
      else {
        $url_options = '';
      }

      $showing_my_requests = "function (e, dt, node, config) {" . "\n";
      $showing_my_requests .= "  var data = dt.ajax.params();" . "\n";
      $showing_my_requests .= "  var url = dt.ajax.url();" . "\n";

      $showing_my_requests .= "  if (url == '" . $ajax_path . "/as_reviewer' || url == '" . $ajax_path . "/as_reviewer" . $url_options . "') {" . "\n";
      $showing_my_requests .= "    dt.ajax.url('" . $ajax_path . "/as_manager" . $url_options . "');" . "\n";
      $showing_my_requests .= "    dt.buttons('.datatable-showing_requests').text('Show As Reviewer');" . "\n";
      $showing_my_requests .= "    $($($(dt).context[0].nTable).children('caption')[0]).text('Requests (As Manager)');" . "\n";
      $showing_my_requests .= "  }" . "\n";
      $showing_my_requests .= "  else if (url == '" . $ajax_path . "/as_manager' || url == '" . $ajax_path . "/as_manager" . $url_options . "') {" . "\n";
      $showing_my_requests .= "    dt.ajax.url('" . $ajax_path . "/as_reviewer" . $url_options . "');" . "\n";
      $showing_my_requests .= "    dt.buttons('.datatable-showing_requests').text('Show As Manager');" . "\n";
      $showing_my_requests .= "    $($($(dt).context[0].nTable).children('caption')[0]).text('Requests (As Reviewer)');" . "\n";
      $showing_my_requests .= "  }" . "\n";
      $showing_my_requests .= "  else {" . "\n";

      if ($options['only_reviewer']) {
        $showing_my_requests .= "    dt.ajax.url('" . $ajax_path . "/as_manager" . $url_options . "');" . "\n";
        $showing_my_requests .= "    dt.buttons('.datatable-showing_requests').text('Show As Reviewer');" . "\n";
        $showing_my_requests .= "    $($($(dt).context[0].nTable).children('caption')[0]).text('Requests (As Manager)');" . "\n";
      }
      else {
        $showing_my_requests .= "    dt.ajax.url('" . $ajax_path . "/as_reviewer" . $url_options . "');" . "\n";
        $showing_my_requests .= "    $($($(dt).context[0].nTable).children('caption')[0]).text('Requests (As Reviewer)');" . "\n";
      }

      $showing_my_requests .= "  }" . "\n";
      $showing_my_requests .= "  dt.ajax.reload();" . "\n";
      $showing_my_requests .= "}" . "\n";

      $table['datatable_settings']['dom'] = 'lfCBrtip';
      $table['datatable_settings']['buttons'] = array();
      $table['datatable_settings']['buttons']['Show Requests'] = array(
        'text' => "'Show As Manager'",
        'action' => $showing_my_requests,
        'className' => "'datatable-showing_requests'",
      );
      unset($showing_my_requests);

      if ($options['only_reviewer'] === FALSE) {
        $table['datatable_settings']['buttons']['Show Requests']['text'] = "'Show As Reviewer'";
      }
    }
  }


  $table['error'] = FALSE;
  return $table;
}

/**
 * Formats an array of table rows for request listings.
 *
 * @param array $items
 *   List of items returned by mfcs_request_load_listing().
 * @param array $columns
 *   List of column properties and settings that tell the function
 *   what item database columns to use.
 * @param object|null $user
 *   (optional) The user object to check access controls against.
 *   If NULL, then the current user is used.
 * @param bool $ajax
 *   (optional) When TRUE, will format the returned rows in an ajax friendly
 *   structure. When FALSE, will format the returned rows in a drupal friendly
 *   structure.
 *
 * @return array|bool
 *   An array of rows formatted for use in functions like theme_table() or
 *   mfcs_build_request_ajax_table().
 *   FALSE is returned on error.
 *
 * @see: mfcs_build_request_ajax_table_process()
 * @see: mfcs_request_load_listing()
 * @see: mfcs_build_request_ajax_table()
 * @see: theme_table()
 */
function mfcs_build_request_ajax_table_process_rows($items, $columns, $user = NULL, $ajax = FALSE) {
  if (!is_array($items)) {
    cf_error::invalid_array('items');
    return FALSE;
  }

  if (is_null($user)) {
    $user = cf_current_user();
  }

  if (!is_object($user)) {
    cf_error::invalid_object($user);
    return FALSE;
  }

  if (!is_bool($ajax)) {
    cf_error::invalid_bool($ajax);
    return FALSE;
  }

  global $base_path;
  global $mfcs_determined;

  $url_arguments = '';
  if (!empty($mfcs_determined['complete'])) {
    $url_arguments .= '?' . $mfcs_determined['complete'];
  }

  $item_ids = array_keys($items);

  $administer = user_access('mfcs administer', $user);
  $manager = user_access('mfcs manage', $user);

  $can_create_requests = mfcs_page_request_access('create', $item_ids, $user);
  $can_edit_requests = mfcs_page_request_access('edit', $item_ids, $user);
  $can_review_requests = mfcs_page_request_access('review', $item_ids, $user);
  $can_log_requests = mfcs_page_request_access('log', $item_ids, $user);
  $can_manage_requests = mfcs_page_request_access('manage', $item_ids, $user);
  $can_history_requests = mfcs_page_request_access('history', $item_ids, $user);
  #$can_delete_requests = mfcs_page_request_access('delete', $item_ids, $user);
  $can_delete_requests = FALSE;

  if (!is_array($can_create_requests)) {
    $can_create_requests = array();
  }

  if (!is_array($can_edit_requests)) {
    $can_edit_requests = array();
  }

  if (!is_array($can_review_requests)) {
    $can_review_requests = array();
  }

  if (!is_array($can_log_requests)) {
    $can_log_requests = array();
  }

  if (!is_array($can_manage_requests)) {
    $can_manage_requests = array();
  }

  if (!is_array($can_history_requests)) {
    $can_history_requests = array();
  }

  if (!is_array($can_delete_requests)) {
    $can_delete_requests = array();
  }

  $type_options = mfcs_get_request_type_list_options();
  $status_options = mfcs_get_request_status_list_options();
  $step_options = mfcs_get_request_steps_list_options();
  $location_options = mfcs_get_request_location_list_options(NULL, FALSE, TRUE);
  $room_options = mfcs_get_request_room_list_options(NULL, NULL, TRUE);
  $building_options = array();


  $rows = array();
  foreach ($items as $item) {
    $row = array();

    if (!array_key_exists($item->location, $building_options)) {
      $building_options[$item->location] = mfcs_get_request_building_list_options($item->location, NULL, TRUE);
    }

    foreach ($columns as $column_id => $column) {
      if (is_null($column['column'])) {
        if ($column_id == 'operations') {
          $data = '<a href="' . $base_path . 'requests/view-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-view">View</a> ';

          if (array_key_exists($item->id, $can_edit_requests) && $can_edit_requests[$item->id]) {
            $data .= '<a href="' . $base_path . 'requests/edit-0/' . $item->id . '/request' . $url_arguments . '" class="operation-link operation-link-edit">Edit</a> ';
          }

          if (array_key_exists($item->id, $can_review_requests) && $can_review_requests[$item->id]) {
            $data .= '<a href="' . $base_path . 'requests/view-0/' . $item->id . '/' . MFCS_VIEW_MODE_OPERATIONS . $url_arguments . '" class="operation-link operation-link-review">Review</a> ';
          }

          if (array_key_exists($item->id, $can_log_requests) && $can_log_requests[$item->id]) {
            $data .= '<a href="' . $base_path . 'requests/view-0/' . $item->id . '/' . MFCS_VIEW_MODE_LOG . $url_arguments . '" class="operation-link operation-link-log">Log</a> ';
          }

          if (array_key_exists($item->id, $can_manage_requests) && $can_manage_requests[$item->id]) {
            $data .= '<a href="' . $base_path . 'requests/manage-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-manage">Manage</a> ';
          }

          if (array_key_exists($item->id, $can_history_requests) && $can_history_requests[$item->id]) {
            $data .= '<a href="' . $base_path . 'requests/history-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-history">History</a> ';
          }

          if (array_key_exists($item->id, $can_delete_requests) && $can_delete_requests[$item->id]) {
            $data .= '<a href="' . $base_path . 'requests/delete-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-delete">Delete</a> ';
          }

          if (array_key_exists($item->id, $can_create_requests) && $can_create_requests[$item->id]) {
            $data .= '<a href="' . $base_path . 'requests/create-0/' . $item->id . $url_arguments . '" class="operation-link operation-link-clone">Copy</a> ';
          }

          if ($ajax) {
            $row[$column['id']] = $data;
          }
          else {
            $row['operations'] = array(
              'data' => $data,
              'class' => is_array($column['class']) ? $column['class'] : array(),
            );
          }
        }
      }
      elseif (is_string($column['column']) && property_exists($item, $column['column'])) {
        $data = property_exists($item, $column['column']) ? $item->{$column['column']} : '';

        // a number of the database columns are expected and required to be available.
        // these columns are handled differently, such as being converted from an integer to a string.
        if ($column['column'] == 'location') {
          if (!empty($item->location)) {
            if (isset($location_options[$item->location])) {
              $data = check_plain($location_options[$item->location]);
            }
          }
        }
        elseif ($column['column'] == 'building') {
          if (!empty($item->building)) {
            if (isset($building_options[$item->location][$item->building])) {
              $data = check_plain($building_options[$item->location][$item->building]);
            }
          }
        }
        elseif ($column['column'] == 'room') {
          if (!empty($item->room)) {
            if (isset($room_options[$item->room])) {
              $data = check_plain($room_options[$item->room]);
            }
          }
        }
        elseif ($column['column'] == 'date') {
          $data = NULL;

          if (isset($item->date) && is_array($item->date)) {
            foreach ($item->date as $delta => $date) {
              if (is_null($data)) {
                $data = '';
              }
              else {
                $data .= '<br>';
              }

              $data .= check_plain(date("Y/m/d", $date));

              if (array_key_exists($delta, $item->time_start) && !is_null($item->time_start[$delta]) && array_key_exists($delta, $item->time_stop) && !is_null($item->time_stop[$delta])) {
                $data .= ' ' . check_plain(date("h:i a", $item->time_start[$delta]));
                $data .= ' to ' . check_plain(date("h:i a", $item->time_stop[$delta]));
              }
            }
          }
          else {
            $data = '';
          }
        }
        elseif ($column['column'] == 'type') {
          if (isset($type_options[$item->type])) {
            $data = check_plain($type_options[$item->type]);
          }
        }
        elseif ($column['column'] == 'status') {
          if (isset($status_options[$item->status])) {
            $data = check_plain($status_options[$item->status]);
          }
        }
        elseif ($column['column'] == 'step') {
          if (isset($step_options[$item->step])) {
            $data = check_plain($step_options[$item->step]);
          }
        }
        elseif ($column_id == 'submitted_by') {
          $data = '';

          if (empty($item->submitted_by_name)) {
            $submitter = user_load($item->user_id);

            if (is_object($submitter)) {
              $name = $submitter->name;

              if (!empty($submitter->field_user_first_name['und'][0]['value'])) {
                $name = $submitter->field_user_first_name['und'][0]['value'];

                if (!empty($submitter->field_user_last_name['und'][0]['value'])) {
                  $name .= ' ' . $submitter->field_user_last_name['und'][0]['value'];
                }

                $name .= ' (' . $submitter->name . ')';
              }
            }
            else {
              watchdog(MFCS_WATCHDOG_ID, "Failed to load the submitter a user id of %user_id. No submitter name can be provided.", array('%user_id' => $item->user_id), WATCHDOG_WARNING);
            }

            unset($submitter);
          }
          else {
            $name = $item->submitted_by_name;

            if (!empty($item->submitted_by_first_name) && !empty($item->submitted_by_last_name)) {
              $name = $item->submitted_by_first_name . ' ' . $item->submitted_by_last_name . ' (' . $item->submitted_by_name . ')';
            }
          }

          if ($manager || $administer) {
            $data = '<a href="' . $base_path . 'requests/users-0/view/' . $item->user_id . $url_arguments . '">' . $name . '</a>';
          }
          else {
            $data = $name;
          }
        }
        elseif ($column['column'] == 'created') {
          $data = check_plain(date("Y/m/d h:i a", $item->created));
        }
        elseif ($column['column'] == 'updated') {
          $data = check_plain(date("Y/m/d h:i a", $item->updated));
        }
        elseif (!array_key_exists('sanitize', $column) || $column['sanitize'] === FALSE) {
          $data = property_exists($item, $column['column']) ? check_plain($item->{$column['column']}) : '';
        }
        else {
          continue;
        }

        if ($ajax) {
          $row[$column['id']] = $data;
        }
        else {
          $row[$column_id] = array(
            'data' => $data,
            'class' => is_array($column['class']) ? $column['class'] : array(),
          );

          if (array_key_exists('visible', $column) && $column['visible'] === FALSE) {
            $row[$column_id]['class'][] = 'script-hidden';
          }
        }
      }
    }

    if ($ajax) {
      $rows[] = $row;
    }
    else {
      $rows[$item->id] = $row;
    }
  }

  return $rows;
}

/**
 * Load venue coordinators that are available.
 *
 * @return array|bool
 *   An array of venue coordinators or FALSE on error.
 */
function mfcs_request_get_available_venue_coordinators() {
  $ilike = 'LIKE';
  if (db_driver() == 'pgsql') {
    $ilike = 'ILIKE';
  }

  try {
    $query = db_select('users', 'u');
    $query->leftJoin('field_data_field_user_first_name', 'fdfufn', 'u.uid = fdfufn.entity_id AND u.uid = fdfufn.entity_id AND fdfufn.delta = 0');
    $query->leftJoin('field_data_field_user_last_name', 'fdfuln', 'u.uid = fdfuln.entity_id AND u.uid = fdfuln.entity_id AND fdfufn.entity_id = fdfuln.entity_id AND fdfuln.delta = 0');

    $query->addField('u', 'uid', 'user_id');
    $query->addField('u', 'name', 'name');
    $query->addField('u', 'mail', 'email');

    $query->addField('fdfufn', 'field_user_first_name_value', 'first_name');
    $query->addField('fdfuln', 'field_user_last_name_value', 'last_name');

    $subquery = db_select('mfcs_banner_rooms', 'mbr');
    $subquery->addField('mbr', 'coordinator_id', 'coordinator_id');
    $subquery->condition('mbr.disabled', 0);
    $subquery->distinct();

    $query->condition('u.uid', $subquery, 'IN');
    $query->condition('u.status', 0, '<>');
    $query->condition('u.uid', 1, '>');

    $query->orderBy('last_name');
    $query->orderBy('first_name');
    $query->orderBy('name');
    $query->orderBy('uid');

    $results = $query->execute()->fetchAll();
  }
  catch (Error $e) {
    cf_error::on_query_execution($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);
    return FALSE;
  }

  $matches = array();
  foreach ($results as $result) {
    $name = "";
    if (!empty($result->last_name)) {
      $name .= $result->last_name;
    }

    if (!empty($result->last_name)) {
      if (!empty($name)) {
        $name .= ", ";
      }
      $name .= $result->first_name;
    }

    $name_value = $name;

    if (!empty($name)) {
      $name = '"' . $name . '" ';
    }

    $value = $name . $result->email;
    $matches[$result->user_id] = $value;
  }

  return $matches;
}

/**
 * Gets the current review decisions and the total for the given requests.
 *
 * @param array $request_ids
 *   An array of request ids to check.
 *   The array should be keyed by request id with a value being defined as the
 *   revision number. The value may also be NULL, in which case the current
 *   revision is used.
 * @param int $classification
 *   The requests current classification.
 * @param int $step
 *   The requests current step.
 *
 * @param array|bool.
 *   The array is be keyed by request id and the value is an array:
 *   'current': an array of reviews
 *   FALSE is returned on error.
 */
function mfcs_get_requests_current_review_decisions($request_ids, $classification, $step) {
  if (!is_array($request_ids) || empty($request_ids)) {
    cf_error::invalid_array('request_ids');
    return FALSE;
  }

  if (!cf_is_integer($classification)) {
    cf_error::invalid_integer('classification');
    return FALSE;
  }

  if (!cf_is_integer($step)) {
    cf_error::invalid_integer('step');
    return FALSE;
  }

  if (is_string($step)) {
    $step = (int) $step;
  }

  // do not operate on steps that cannot be normally reviewed.
  if ($step !== MFCS_REVIEW_STEP_REVIEW && $step !== MFCS_REVIEW_STEP_REQUIREMENTS) {
    return FALSE;
  }

  mfcs_include(MFCS_INCLUDE_LIST_OPTIONS);

  $reviewer_classification_options = mfcs_get_reviewer_classification_list_options();

  $reviewers_returned = mfcs_get_reviewers(array('mr.request_classification' => $classification, 'mr.review_step' => $step, 'mr.disabled' => 0));
  $reviewers = array();
  if (isset($reviewers_returned['results']) && is_array($reviewers_returned['results'])) {
    $reviewers = $reviewers_returned['results'];
  }
  unset($reviewers_returned);

  $required_reviewers_classifications = array();
  $reviewers_by_classification = array();
  foreach ($reviewers as $reviewer) {
    if (is_string($reviewer->reviewer_classification)) {
      $reviewer_classification = (int) $reviewer->reviewer_classification;
    }
    else {
      $reviewer_classification = $reviewer->reviewer_classification;
    }

    // regardless of classification requirements, always provide all reviewers by classification.
    if (!isset($reviewers_by_classification[$reviewer_classification][$reviewer->user_id])) {
      $reviewers_by_classification[$reviewer_classification][$reviewer->user_id] = $reviewer->user_id;
    }

    if (!array_key_exists($reviewer_classification, $required_reviewers_classifications)) {
      // never count venue coordinator or the proxy reviewer classifications.
      if ($reviewer_classification == MFCS_REVIEWER_CLASSIFICATION_VENUE_COORDINATOR || $reviewer_classification == MFCS_REVIEWER_CLASSIFICATION_VENUE_COORDINATOR_PROXY) {
        continue;
      }

      // never count managers, administers, or requesters.
      if ($reviewer_classification == MFCS_REVIEWER_CLASSIFICATION_SYSTEM_ADMINISTRATOR || $reviewer_classification == MFCS_REVIEWER_CLASSIFICATION_MANAGER || $reviewer_classification == MFCS_REVIEWER_CLASSIFICATION_REQUESTER) {
        continue;
      }

      $required_reviewers_classifications[$reviewer_classification] = $reviewer_classification_options[$reviewer_classification];
    }
  }

  $total_required = count($required_reviewers_classifications);
  $required_reviewers_classifications_ids = array_keys($required_reviewers_classifications);

  if ($step === MFCS_REVIEW_STEP_REVIEW) {
    $review_decisions = array(
      MFCS_REVIEW_DECISION_ISSUES,
      MFCS_REVIEW_DECISION_ISSUES_NONE,
    );
  }
  elseif ($step === MFCS_REVIEW_STEP_REQUIREMENTS) {
    $review_decisions = array(
      MFCS_REVIEW_DECISION_APPROVE,
      MFCS_REVIEW_DECISION_DENY,
    );
  }

  $decisions = array();
  foreach ($request_ids as $request_id => $review_revision) {
    if (array_key_exists($request_id, $decisions)) {
      continue;
    }

    // require a valid integer be used for the revision number.
    if (!is_null($review_revision) && (!cf_is_integer($review_revision) || $review_revision < 0)) {
      watchdog(MFCS_WATCHDOG_ID, "Failed to load reviewer classification count for request %request_id (revision: %review_revision) does not have a valid revision number (and is not NULL).", array('%request_id' => $request_id, '%review_revision' => $review_revision), WATCHDOG_ERROR);
      continue;
    }

    $decisions[$request_id] = array(
      'current' => 0,
      'total' => $total_required,
      'completed' => array(),
      'needed' => $required_reviewers_classifications,
      'reviewers' => $reviewers_by_classification,
    );

    try {
      $query = db_select('mfcs_field_review_review', 'mfrr');

      if (is_null($review_revision)) {
        $query->innerJoin('mfcs_current', 'mc', 'mfrr.request_id = mc.request_id and mfrr.revision = mc.review_review');
      }
      $query->innerJoin('mfcs_review_classifications', 'mrc', 'mfrr.id = mrc.review_id');

      $query->addField('mrc', 'classification', 'classification');
      $query->addField('mfrr', 'user_id', 'user_id');

      $query->condition('mfrr.request_id', $request_id);
      $query->condition('mfrr.step', $step);
      if (!is_null($review_revision)) {
        $query->condition('mfrr.revision', $review_revision);
      }
      $query->condition('mfrr.decision', $review_decisions, 'IN');
      $query->condition('mrc.classification', $required_reviewers_classifications_ids, 'IN');
      $query->distinct();

      $reviews = $query->execute()->fetchAll();

      if ($reviews === FALSE) {
        watchdog(MFCS_WATCHDOG_ID, "Failed to load reviewer classification count for request %request_id (review revision: %review_revision) with classification %classification on step %step. Assuming current reviewed is 0.", array('%request_id' => $request_id, '%review_revision' => (is_null($review_revision) ? 'NULL' : $review_revision), '%classification' => $classification, '%step' => $step), WATCHDOG_ERROR);
      }
      else {
        foreach ($reviews as $review) {
          $decisions[$request_id]['completed'][$review->classification] = $reviewer_classification_options[$review->classification];
        }

        $decisions[$request_id]['current'] = count($decisions[$request_id]['completed']);
      }
    }
    catch (Error $e) {
      cf_error::on_query_execution($e);

      return FALSE;
    }
    catch (Exception $e) {
      cf_error::on_query_execution($e);

      return FALSE;
    }
  }

  return $decisions;
}

/**
 * Loads a list of requests that did not provide insurance.
 *
 * This only loads requests that require insurance.
 * This only loads requests that have been accepted.
 *
 * @param int|null $date_from
 *   When specified, a unix timestamp representing a current date to load
 *   requests within a certain amount of time.
 *   When not specified, all results are loaded.
 *   An = is performed on this value when $date_to is null.
 *   A >= is performed on this value when $date_to is an integer.
 * @param int|null $date_to
 *   When specified, a unix timestamp representing a current date to load
 *   requests within a certain amount of time.
 *   When not specified, all results are loaded.
 *   If specified, this requires $date_from to be non-null.
 *   A < is performed on this value.
 *
 * @return array|bool
 *   An array of requests. FALSE is returned on error.
 */
function mfcs_get_requests_not_providing_insurance($date_from = NULL, $date_to = NULL) {
  if (!is_null($date_from)) {
    if (!cf_is_integer($date_from)) {
      cf_error::invalid_integer('date_from');
      return FALSE;
    }

    if (!is_null($date_to) && !cf_is_integer($date_to)) {
      cf_error::invalid_integer('date_to');
      return FALSE;
    }
  }

  $results = array();

  try {
    $query = db_select('mfcs_requests', 'mer');

    $query->innerJoin('mfcs_current', 'mc', 'mer.id = mc.request_id');

    $query->innerJoin('mfcs_field_dates_date', 'mfdd', 'mc.request_id = mfdd.request_id AND mc.dates_date = mfdd.revision');

    $query->innerJoin('mfcs_field_insurance_contractor', 'mfic', 'mc.request_id = mfic.request_id AND mc.insurance_contractor = mfic.revision AND mfic.delta = 0');
    $query->innerJoin('mfcs_field_insurance_unaffiliated', 'mfiu', 'mc.request_id = mfiu.request_id AND mc.insurance_unaffiliated = mfiu.revision AND mfiu.delta = 0');
    $query->innerJoin('mfcs_field_insurance_provided', 'mfip', 'mc.request_id = mfip.request_id AND mc.insurance_provided = mfip.revision AND mfip.delta = 0');

    $query->innerJoin('mfcs_field_request_coordinator_name', 'mfrcn', 'mc.request_id = mfrcn.request_id AND mc.request_coordinator_name = mfrcn.revision AND mfrcn.delta = 0');
    $query->innerJoin('mfcs_field_request_coordinator_email', 'mfrce', 'mc.request_id = mfrce.request_id AND mc.request_coordinator_email = mfrce.revision AND mfrce.delta = 0');


    $query->addField('mer', 'id', 'id');
    $query->addField('mer', 'title', 'title');
    $query->addField('mfdd', 'value', 'date');
    $query->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.
    $query->addField('mfrcn', 'value', 'coordinator_name');
    $query->addField('mfrce', 'value', 'coordinator_email');


    $allowed_status = array(
      MFCS_REQUEST_STATUS_CLOSED_ACCEPTED,
    );

    $query->condition('mer.status', $allowed_status, 'IN');

    $allowed_steps = array(
      MFCS_REVIEW_STEP_COMPLETED,
    );

    $query->condition('mer.step', $allowed_steps, 'IN');

    $or = db_or();
    $or->condition('mfic.value', 1);
    $or->condition('mfiu.value', 1);
    $query->condition($or);

    $nand = db_and();
    $nand->not();
    $nand->condition('mfip.value', 1);
    $query->condition($nand);

    if (!is_null($date_from)) {
      if (is_null($date_to)) {
        $query->condition('mfdd.value', $date_from);
      }
      else {
        $query->condition('mfdd.value', $date_from, '>=');
        $query->condition('mfdd.value', $date_to, '<');
      }
    }


    $query->orderBy('mfdd.value');


    $results = $query->execute()->fetchAll();

    if (empty($results)) {
      return array();
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  return $results;
}

/**
 * Determines the current dates for reminders relative to the current day.
 *
 * There are a number of problems with the PHP date system that forced me
 * to write this function.
 *
 * The usage of the word 'this' is broken in php's strtotime function.
 * In regards to weeks, the word 'this' is treated as if it were the word
 * 'next', except for then the current day is today.
 *
 * To get the current day for 'this' week, one must use 'first sunday this
 * week' and compare the value to 'today'.
 *
 * If the value of 'today' is identical to 'this week', then that value can
 * be used.
 *
 * If the value of 'today' is different from 'this week', then take the
 * _previous_ weeks date!
 *
 * strtotime also does not support 'first day of week', which actually gives
 * the first day of the month!
 *
 * strtotime also does not process the word 'of' in the same manner, thus
 * 'first sunday this week' != 'first sunday of this week'.
 *
 * strotime also treats 'last week' and '-1 week' differently, last week might
 * return monday even when working with sunday.
 * - This is probably true for 'this week', and 'next week' as well.
 *
 * @return array
 *   An array containing dates relative to today.
 *   - 'today': contains the current day at 00:00.
 *   - 'week_day': contains the first day of the current week at 00:00.
 *   - 'first_day_this_week': contains the proper first day 'this' week at
 *     00:00.
 */
function mfcs_request_reminders_get_dates() {
  $dates = array();

  $dates['today'] = strtotime('today');
  $dates['yesterday'] = strtotime('yesterday', $dates['today']);
  $dates['tomorrow'] = strtotime('tomorrow', $dates['today']);

  $dates['week_day'] = strtotime('first sunday this week');
  #$dates['week_day'] = strtotime('first monday this week'); // iso-8601

  if ($dates['week_day'] == $dates['today']) {
    $dates['first_day_this_week'] = $dates['week_day'];
  }
  else {
    $dates['first_day_this_week'] = strtotime('-1 week', $dates['week_day']);
  }

  return $dates;
}

/**
 * Clears the cache for request reminders that are old.
 *
 * @param int $type
 *   The reminder type to clear all old data for.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_clear_request_reminders($type) {
  if (!cf_is_integer($type)) {
    cf_error::invalid_integer('type');
    return FALSE;
  }

  $dates = mfcs_request_reminders_get_dates();

  try {
    $query = db_delete('mfcs_request_reminders');

    $query->condition('type', $type);

    $or = db_or();

    $days_30 = strtotime('-30 days', $dates['today']);
    $and = db_and();
    $and->condition('interval', MFCS_REMINDER_INTERVAL_DAY_30);
    $and->condition('date', $days_30, '<');
    $or->condition($and);

    $query->condition($or);

    $query->execute();
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  return TRUE;
}

/**
 * Loads the request reminders for a certain reminder type and request.
 *
 * @param array $dates
 *   Should be the dates as defined by mfcs_request_reminders_get_dates().
 *   Provided as an argument here rather than calling the function for
 *   performance reasons.
 * @param int $type
 *   The reminder type to clear all old data for.
 * @param int|null $interval
 *   (optional) When specified, loads reminders only for the specified inteval.
 * @param int|null $request_id
 *   (optional) When specified, loads reminders only for the specified request.
 *
 * @return array|bool
 *   An array of reminders or FALSE on failure.
 *
 * @see: mfcs_request_reminders_get_dates()
 */
function mfcs_get_request_reminders($dates, $type, $interval = NULL, $request_id = NULL) {
  if (!is_array($dates)) {
    cf_error::invalid_array('dates');
    return FALSE;
  }

  if (!cf_is_integer($type)) {
    cf_error::invalid_integer('type');
    return FALSE;
  }

  if (!is_null($interval) && !cf_is_integer($interval)) {
    cf_error::invalid_integer('interval');
    return FALSE;
  }

  if (!is_null($request_id) && !cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  $results = array(
    MFCS_REMINDER_INTERVAL_DAY_30 => array(),
  );

  try {
    $query = db_select('mfcs_request_reminders', 'mrr');

    $query->fields('mrr');
    $query->condition('type', $type);

    if (!is_null($request_id)) {
      $query->condition('request_id', $request_id);
    }

    // perform separate queries instead of doing a php loop to rebuild the results in the desired structure.
    // this puts the work onto the database, which is generally more efficient at such tasks at the cost of multiple queries.
    // when $interval is specified, then only one of these queries is performed.

    if (is_null($interval) || $interval == MFCS_REMINDER_INTERVAL_DAY_30) {
      $days_30 = strtotime('-30 days', $dates['today']);
      $query_day_30 = clone $query;
      $query_day_30->condition('interval', MFCS_REMINDER_INTERVAL_DAY_30);
      $query_day_30->condition('date', $days_30, '>=');
      $results[MFCS_REMINDER_INTERVAL_DAY_30] = $query_day_30->execute()->fetchAllAssoc('request_id');
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  return $results;
}

/**
 * Saves the request reminder into the cache.
 *
 * @param array $reminder
 *   An array containing the reminder values.
 *
 * @param bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_save_request_reminders($reminder) {
  if (!is_array($reminder)) {
    cf_error::invalid_array('reminder');
    return FALSE;
  }

  if (!isset($reminder['request_id']) || !cf_is_integer($reminder['request_id'])) {
    cf_error::invalid_integer('reminder[request_id]');
    return FALSE;
  }

  if (!isset($reminder['date']) || !cf_is_integer($reminder['date'])) {
    cf_error::invalid_integer('reminder[date]');
    return FALSE;
  }

  if (!isset($reminder['type']) || !cf_is_integer($reminder['type'])) {
    cf_error::invalid_integer('reminder[type]');
    return FALSE;
  }

  if (!isset($reminder['interval']) || !cf_is_integer($reminder['interval'])) {
    cf_error::invalid_integer('reminder[interval]');
    return FALSE;
  }

  try {
    $query = db_insert('mfcs_request_reminders');

    $query->fields($reminder);
    $query->execute();
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  return TRUE;
}

/**
 * Adds canonical and short url links to the http meta and headers.
 *
 * Will also add the content-location http header via the unique path.
 *
 * @param string $unique_path
 *   The canonical path used to uniquely identify this page.
 * @param string $short_path
 *   (optional) A short version of the unique path. If not specified, then the
 *   unique path is also specified as the short path.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function mfcs_add_canonical_headers($unique_path, $short_path = NULL) {
  if (!is_string($unique_path)) {
    cf_error::invalid_string('unique_path');
    return FALSE;
  }

  if (!is_null($short_path) && !is_string($short_path)) {
    cf_error::invalid_string('short_path');
    return FALSE;
  }

  if (is_null($short_path)) {
    $short_path = $unique_path;
  }

  global $base_url;
  global $base_path;

  // expose settings as a static variable so that the theme can find and process.
  $mfcs_canonical = &drupal_static('mfcs_canonical', array());

  $mfcs_canonical[] = array(
    'rel' => 'canonical',
    'href' => $base_url . '/' . $unique_path,
  );

  $mfcs_canonical[] = array(
    'rel' => 'shortlink',
    'href' => $base_path . $short_path,
  );

  $link = '<' . $base_path . $short_path . '>; rel="shortlink", <' . $base_url . '/' . $unique_path . '>; rel="canonical"';

  // provide content-location http header.
  drupal_add_http_header('content-location', $base_path . $unique_path, FALSE);
  drupal_add_http_header('link', $link, FALSE);

  return TRUE;
}

/**
 * Load a unix timestamp instance.
 *
 * This functions similar to REQUEST_TIME, except it is updatable within a
 * single script execution. This is necessary when performing multiple tasks
 * that are not grouped togethor.
 *
 * @param bool $reset
 *   (optional) When TRUE, will reset the instance to the current timestamp.
 *
 * @return int
 *   The instance timestamp.
 */
function mfcs_instance($reset = FALSE) {
  $instance = &drupal_static(__function__, NULL);

  if (is_null($instance)) {
    $instance = REQUEST_TIME;
  }
  elseif ($reset === TRUE) {
    $instance = strtotime('now');
  }

  return $instance;
}

/**
 * Identify the filters passed to the url and generate database filters.
 *
 * The arguments are processed and stored in the global $mfcs_determined.
 */
function mfcs_determine_url_arguments() {
  global $user;
  global $mfcs_determined;

  $mfcs_determined = array(
    'get' => array(),
    'filters' => array(),
    'redirect' => array(),
    'combined' => '',
    'remaining' => '',
    'complete' => '',
  );

  // deny access to this functionality to the anonymous user.
  if ($user->uid == 0) {
    return;
  }

  if (!empty($_GET)) {
    $first = TRUE;
    foreach ($_GET as $request_name => $request_value) {
      $lower_name = strtolower($request_name);

      if ($lower_name == 'types') {
        $mfcs_determined['redirect'][$lower_name] = $request_value;

        $lower_value = strtolower($request_value);
        $types_array = explode(',', $lower_value);

        if ($first) {
          $first = FALSE;
        }
        else {
          $mfcs_determined['combined'] .= '&';
        }
        $mfcs_determined['combined'] .= $lower_name . '=' . $lower_value;

        $types = array();
        foreach ($types_array as $type) {
          if (cf_is_integer($type)) {
            $types[$type] = $type;
          }
        }
        unset($types_array);
        $mfcs_determined['get']['types'] = $types;

        $target_field_name = 'field_information-type-0';
        $mfcs_determined['filters'][$target_field_name]['group_name'] = 'information';
        $mfcs_determined['filters'][$target_field_name]['field_name'] = 'type';
        $mfcs_determined['filters'][$target_field_name]['column'] = 'value';
        $mfcs_determined['filters'][$target_field_name]['search'] = $types;
        $mfcs_determined['filters'][$target_field_name]['type'] = 'number';
        $mfcs_determined['filters'][$target_field_name]['multiple'] = FALSE;
        $mfcs_determined['filters'][$target_field_name]['operator'] = MFCS_OPERATOR_IS_IN;
      }
      elseif ($lower_name == 'classifications') {
        $mfcs_determined['redirect'][$lower_name] = $request_value;

        $lower_value = strtolower($request_value);
        $classifications_array = explode(',', $lower_value);

        if ($first) {
          $first = FALSE;
        }
        else {
          $mfcs_determined['combined'] .= '&';
        }
        $mfcs_determined['combined'] .= $lower_name . '=' . $lower_value;

        $classifications = array();
        foreach ($classifications_array as $classification) {
          if (cf_is_integer($classification)) {
            $classifications[$classification] = $classification;
          }
        }
        unset($classifications_array);
        $mfcs_determined['get']['classifications'] = $classifications;

        $target_field_name = 'field_request_coordinator-classification-0';
        $mfcs_determined['filters'][$target_field_name]['group_name'] = 'request_coordinator';
        $mfcs_determined['filters'][$target_field_name]['field_name'] = 'classification';
        $mfcs_determined['filters'][$target_field_name]['column'] = 'value';
        $mfcs_determined['filters'][$target_field_name]['search'] = $classifications;
        $mfcs_determined['filters'][$target_field_name]['type'] = 'number';
        $mfcs_determined['filters'][$target_field_name]['multiple'] = FALSE;
        $mfcs_determined['filters'][$target_field_name]['operator'] = MFCS_OPERATOR_IS_IN;
      }
      elseif ($lower_name == 'buildings') {
        $mfcs_determined['redirect'][$lower_name] = $request_value;

        $lower_value = strtolower($request_value);
        $buildings_array = explode(',', $lower_value);

        if ($first) {
          $first = FALSE;
        }
        else {
          $mfcs_determined['combined'] .= '&';
        }
        $mfcs_determined['combined'] .= $lower_name . '=' . $lower_value;

        $buildings = array();
        foreach ($buildings_array as $building) {
          if (cf_is_integer($building)) {
            $buildings[$building] = $building;
          }
        }
        unset($buildings_array);
        $mfcs_determined['get']['buildings'] = $buildings;

        $target_field_name = 'field_top-building-0';
        $mfcs_determined['filters'][$target_field_name]['group_name'] = 'mer';
        $mfcs_determined['filters'][$target_field_name]['field_name'] = 'building';
        $mfcs_determined['filters'][$target_field_name]['column'] = 'value';
        $mfcs_determined['filters'][$target_field_name]['search'] = $buildings;
        $mfcs_determined['filters'][$target_field_name]['type'] = 'number';
        $mfcs_determined['filters'][$target_field_name]['multiple'] = FALSE;
        $mfcs_determined['filters'][$target_field_name]['operator'] = MFCS_OPERATOR_IS_IN;
      }
      elseif ($lower_name == 'q') {
        // drupal uses 'q' for the url path, so ignore it.
        continue;
      }
      elseif ($lower_name == 'sort' || $lower_name == 'order' || $lower_name == 'destination') {
        // these are not intended to be carried along, globally.
        continue;
      }
      elseif (is_string($request_value)) {
        $mfcs_determined['redirect'][$lower_name] = $request_value;

        if (!isset($mfcs_determined['get']['remaining'])) {
          $mfcs_determined['get']['remaining'] = array();
        }

        $mfcs_determined['get']['remaining'][$request_name] = $request_value;
      }
    }

    $mfcs_determined['complete'] .= $mfcs_determined['combined'];
  }

  // handle converting the remaining values
  if (!empty($mfcs_determined['get']['remaining'])) {
    $first = TRUE;
    foreach ($mfcs_determined['get']['remaining'] as $remaining_key => $remaining_value) {
      // ignore arguments added by datatables.
      if ($remaining_key == 'draw' || $remaining_key == 'start' || $remaining_key == 'length' || $remaining_key == '_') {
        continue;
      }

      if ($first) {
        $first = FALSE;

        if (!empty($mfcs_determined['complete'])) {
          $mfcs_determined['complete'] .= '&';
        }
      }
      else {
        $mfcs_determined['remaining'] .= '&';
      }

      $mfcs_determined['remaining'] .= urlencode($remaining_key) . '=' . urlencode($remaining_value);
    }

    $mfcs_determined['complete'] .= $mfcs_determined['remaining'];
  }
}

/**
 * Builds a redirect array that contains the appropriate url arguments.
 *
 * @param string $path
 *   The url path to redirect to.
 * @param string|null $fragment
 *   (optional) The url 'fragment', without the leading '#'.
 *
 * @return array|bool
 *   The generated array for form state redirect or FALSE on error.
 */
function mfcs_build_redirect_array($path, $fragment = NULL) {
  if (!is_string($path)) {
    cf_error::invalid_string('path');
    return FALSE;
  }

  if (!is_null($fragment) && !is_string($fragment)) {
    cf_error::invalid_string('fragments');
    return FALSE;
  }

  global $mfcs_determined;

  return array($path, array('query' => $mfcs_determined['redirect'], 'fragment' => $fragment));
}

/**
 * Returns whether or not the specified user has manage access.
 *
 * Unlike user_access() this does not require the entire drupal object.
 * Only the user id is necessary, which increases performance and uses less
 * memory.
 *
 * @param bool $reset
 *   (optional) When TRUE, will reset the instance to the current timestamp.
 *
 * @return bool
 *   TRUE if the user is a manager, FALSE otherwise.
 */
function mfcs_user_can_manage($user_id) {
  static $can_manage;
  $can_manage = &drupal_static(__function__, array());

  if (!array_key_exists($user_id, $can_manage)) {
    try {
      $query = db_select('users', 'u');
      $query->innerJoin('users_roles', 'ur', 'u.uid = ur.uid');
      $query->innerJoin('role_permission', 'rp', 'ur.rid = rp.rid');

      $query->condition('u.uid', $user_id);
      $query->condition('rp.permission', 'mfcs manage');
      $query->range(0, 1);

      $results = $query->execute()->fetchAll();

      $can_manage[$user_id] = !empty($results);
    }
    catch (Error $e) {
      cf_error::on_exception($e);
      return FALSE;
    }
    catch (Exception $e) {
      cf_error::on_exception($e);
      return FALSE;
    }
  }

  return $can_manage[$user_id];
}

/**
 * Returns whether or not the specified user has administration access.
 *
 * Unlike user_access() this does not require the entire drupal object.
 * Only the user id is necessary, which increases performance and uses less
 * memory.
 *
 * @param bool $reset
 *   (optional) When TRUE, will reset the instance to the current timestamp.
 *
 * @return bool
 *   TRUE if the user is an administrator, FALSE otherwise.
 */
function mfcs_user_can_administer($user_id) {
  static $can_administer;
  $can_administer = &drupal_static(__function__, array());

  if (!array_key_exists($user_id, $can_administer)) {
    try {
      $query = db_select('users', 'u');
      $query->innerJoin('users_roles', 'ur', 'u.uid = ur.uid');

      $query->condition('u.uid', $user_id);
      $query->condition('ur.rid', 3); // @fixme: this is a hardcoded value for the 'administer' role, might need to find a dynamic way to implement this.
      $query->range(0, 1);

      $results = $query->execute()->fetchAll();

      $can_administer[$user_id] = !empty($results);
    }
    catch (Error $e) {
      cf_error::on_exception($e);
      return FALSE;
    }
    catch (Exception $e) {
      cf_error::on_exception($e);
      return FALSE;
    }
  }

  return $can_administer[$user_id];
}

/**
 * Returns TRUE if the given request dates have not come to pass.
 *
 * To keep queries as simple as possible, this operates on a per-day basis.
 * Change this to a per minute basis if this becomes a problem.
 *
 * This does not check to see if a request by the specified id exists.
 *
 * @param int $request_id
 *   The request id integer.
 *
 * @return bool
 *   TRUE when the request has upcoming dates.
 *   FALSE on error or when the request has no upcoming dates.
 */
function mfcs_request_is_still_upcoming($request_id) {
  if (!cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  $today = strtotime('midnight today', mfcs_instance());

  try {
    $query = db_select('mfcs_field_dates_date', 'mfdd');
    $query->addExpression('count(mfdd.request_id)');

    $query->condition('mfdd.request_id', $request_id);
    $query->condition('mfdd.value', $today, '>=');
    $query->condition('mfdd.cancelled', 1, '<>'); // using <> for backwards compatibility where mfdd.cancelled may be NULL.

    $upcoming_dates = $query->execute()->fetchField();
    return $upcoming_dates > 0;
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  return FALSE;
}

/**
 * Sign the message us GNU PG.
 *
 * @param string $message
 *   A string to sign.
 * @param $content_type
 *   (optional) The content type to use, such as: 'multipart/mixed'.
 *
 * @param string|false
 *   Signature string on success, FALSE otherwise.
 */
function mfcs_gpg_sign($message) {
  global $conf;

  if (empty($conf['fcs_email']) || empty($message)) {
    return FALSE;
  }

  if (!class_exists('gnupg') || !isset($conf['gpg-mail'][$conf['fcs_email']]['fingerprint'])) {
    return FALSE;
  }

  if (!is_string($conf['gpg-mail'][$conf['fcs_email']]['fingerprint'])) {
    return FALSE;
  }

  $gpg = new gnupg();
  if (!is_object($gpg)) {
    return FALSE;
  }

  try {
    $fingerprint = $conf['gpg-mail'][$conf['fcs_email']]['fingerprint'];

    $gpg->seterrormode(gnupg::ERROR_EXCEPTION);
    $gpg->addsignkey($fingerprint);
    $gpg->setsignmode(gnupg::SIG_MODE_DETACH);
    $gpg->setarmor(1);

    return $gpg->sign($message);
    #$valid = $gpg->verify($message, $signature);
  }
  catch (Error $e) {
    watchdog(MFCS_WATCHDOG_ID, "Failed to sign PGP key: @key, reason: @reason", array('@key' => $fingerprint, '@reason' => $e->getMessage()), WATCHDOG_ERROR);
  }
  catch (Exception $e) {
    watchdog(MFCS_WATCHDOG_ID, "Failed to sign PGP key: @key, reason: @reason", array('@key' => $fingerprint, '@reason' => $e->getMessage()), WATCHDOG_ERROR);
  }

  return FALSE;
}

/**
 * Returns a list of venue coordinators associated with a given room.
 *
 * @param integer|null $room_id
 *   (optional) A room ID to limit the listing to.
 * @param bool $coordinators_only
 *   (optional) Do not return room ids, only coordinators.
 *
 * @return array|bool
 *   When $coordinators_only is FALSE, an array containing the venue
 *   coordinator ids with the room ids as the array keys.
 *   When $coordinators_only is TRUE, an array containing a distinct set of
 *   venue coordinator ids with the keys being the coordinator id as well.
 *   FALSE is returned on error.
 */
function mfcs_load_room_coordinators($room_id = NULL, $coordinators_only = FALSE) {
  if (!is_null($room_id) && !cf_is_integer($room_id)) {
    cf_error::invalid_integer('room_id');

    return FALSE;
  }

  if (!is_bool($coordinators_only)) {
    cf_error::invalid_bool('coordinators_only');

    return FALSE;
  }

  $rows = array();
  try {
    $query = db_select('mfcs_banner_rooms', 'mbr');

    if (!is_null($room_id)) {
      $query->condition('mbr.id', $room_id);
    }

    if ($coordinators_only) {
      $query->addField('mbr', 'coordinator_id', 'coordinator_id');
      $query->distinct();

      $rows = $query->execute()->fetchAllKeyed(0, 0);
    }
    else {
      $query->addField('mbr', 'id', 'id');
      $query->addField('mbr', 'coordinator_id', 'coordinator_id');

      $rows = $query->execute()->fetchAllKeyed();
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $rows;
}

/**
 * Return an array containing the user id and name of the primary user.
 *
 * jira ticket: fcs-58.
 *
 * @param null|int $banner_id
 *   (optional) The banner id string. If Null, then load all users on system.
 *
 * @return array
 *   An array with the banner ids and user ids.
 */
function mfcs_users_load_banner_id_to_user_id($banner_id = NULL) {
  $list = array(
    'banner' => array(),
    'user' => array(),
  );

  if (!is_null($banner_id) && !cf_is_integer($banner_id)) {
    return $list;
  }

  if (is_null($banner_id)) {
    $query = db_query('select u.uid as user_id, u.name as name, fdfubi.field_user_banner_id_value as banner_id, fdfupa.field_user_primary_account_value as primary_account from field_data_field_user_banner_id fdfubi inner join users u on fdfubi.entity_id = u.uid left join field_data_field_user_primary_account fdfupa on u.uid = fdfupa.entity_id order by u.uid');
  }
  else {
    $banner_id_string = mfcs_banner_id_int_to_string($banner_id);
    $query = db_query('select u.uid as user_id, u.name as name, fdfubi.field_user_banner_id_value as banner_id, fdfupa.field_user_primary_account_value as primary_account from field_data_field_user_banner_id fdfubi inner join users u on fdfubi.entity_id = u.uid left join field_data_field_user_primary_account fdfupa on u.uid = fdfupa.entity_id where field_user_banner_id_value = :banner_id order by u.uid', array(':banner_id' => $banner_id_string));
  }

  $results = $query->fetchAll();
  if (!is_array($results)) {
    return $list;
  }

  foreach ($results as $result) {
    $is_primary = TRUE;
    if (!isset($result->primary_account) || $result->primary_account == 0) {
      $is_primary = FALSE;
    }

    if (!isset($list['banner'][$result->banner_id])) {
      $list['banner'][$result->banner_id] = array(
        'others' => array(
       ),
      );
    }

    if ($is_primary) {
      $list['banner'][$result->banner_id]['user_id'] = $result->user_id;
      $list['banner'][$result->banner_id]['name'] = $result->name;
    }
    else {
      $list['banner'][$result->banner_id]['others'][$result->user_id] = array(
        'user_id' => $result->user_id,
        'name' => $result->name,
      );

      $is_primary = FALSE;
    }

    $list['user'][$result->user_id] = array(
      'banner_id' => $result->banner_id,
      'name' => $result->name,
      'primary' => $is_primary,
    );
  }

  return $list;
}
/**
 * Obtain a list of disabled accounts that are assigned as a requester to active content.
 *
 * @param int|null $user_id
 *   (optional) When an integer, represents the user id for a single user to load.
 *   When NULL, all users will be loaded.
 *
 * @return bool|array
 *   An array of users who have active content.
 *   FALSE is returned on error.
 */
function mfcs_disabled_requesters_with_active_content($user_id = NULL) {
  if (!is_null($user_id) && !cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  $rows = array();
  try {
    $query = db_select('mfcs_requests', 'mer');
    $query->innerJoin('users', 'u', 'mer.user_id = u.uid');

    $query->addField('mer', 'user_id', 'user_id');
    $query->distinct();

    $query->condition('mer.status', array(MFCS_REQUEST_STATUS_LOCKED, MFCS_REQUEST_STATUS_UNLOCKED), 'IN');
    $query->condition('u.status', 0);

    if (!is_null($user_id)) {
      $query->condition('u.uid', $user_id);
    }

    $results = $query->execute()->fetchAll();
    if (is_array($results)) {
      foreach ($results as $result) {
        $rows[$result->user_id] = $result->user_id;
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $rows;
}

/**
 * Obtain a list of disabled accounts that are assigned as a venue coordinator to active content.
 *
 * @param int|null $user_id
 *   (optional) When an integer, represents the user id for a single user to load.
 *   When NULL, all users will be loaded.
 *
 * @return bool|array
 *   An array of users who have active content.
 *   FALSE is returned on error.
 */
function mfcs_disabled_venue_coordinators_with_active_content($user_id = NULL) {
  if (!is_null($user_id) && !cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  //select mer.* from mfcs_requests mer where mer.venue_coordinator = 51 and (mer.status = 1 or status = 2) order by id, venue_coordinator;
  $rows = array();
  try {
    $query = db_select('mfcs_requests', 'mer');
    $query->innerJoin('users', 'u', 'mer.venue_coordinator = u.uid');

    $query->addField('mer', 'venue_coordinator', 'venue_coordinator');
    $query->distinct();

    $query->condition('mer.status', array(MFCS_REQUEST_STATUS_LOCKED, MFCS_REQUEST_STATUS_UNLOCKED), 'IN');
    $query->condition('u.status', 0);

    if (!is_null($user_id)) {
      $query->condition('u.uid', $user_id);
    }

    $results = $query->execute()->fetchAll();
    if (is_array($results)) {
      foreach ($results as $result) {
        $rows[$result->venue_coordinator] = $result->venue_coordinator;
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $rows;
}

/**
 * Search through database for venue coordinators and store the appropriate user problem settings.
 *
 * @see: mfcs_disabled_venue_coordinators_with_active_content()
 */
function mfcs_search_for_and_mark_disabled_venue_coordinators_with_active_content() {
  $disabled_user_ids = mfcs_disabled_venue_coordinators_with_active_content();

  // do not bother with error reporting, just exit if a non-array is returned.
  if (!is_array($disabled_user_ids)) {
    return;
  }

  foreach ($disabled_user_ids as $user_id) {
    $mfcs_users = mfcs_load_users($user_id);

    $problems = MFCS_USER_PROBLEM_NONE;
    if (isset($mfcs_users[$user_id])) {
      $problems = $mfcs_users[$user_id]->problems;
    }

    if (($problems & MFCS_USER_PROBLEM_ACCOUNT_DISABLED_IN_USE) == 0) {
      $problems = ($problems | MFCS_USER_PROBLEM_ACCOUNT_DISABLED_IN_USE);
      mfcs_save_user($user_id, array('problems' => $problems));
    }
  }


  // look for users who have been disabled, but were re-enabled at some point.
  mfcs_include(MFCS_INCLUDE_MANAGEMENT);

  $options = array(
    'include_disabled' => TRUE,
  );

  $conditions = array();
  $conditions['value_only_problems'] = array(
    'field' => 'mu.problems',
    'operator' => MFCS_OPERATOR_NOT_EQUAL,
    'search' => MFCS_USER_PROBLEM_NONE,
  );

  $problems_returned = mfcs_management_search_users($conditions, $options);
  if (isset($problems_returned['results']) && is_array($problems_returned['results'])) {
    foreach ($problems_returned['results'] as $result) {
      // skip accounts that have already been marked as disabled, leaving only accounts that are now enabled.
      if (array_key_exists($result->user_id, $disabled_user_ids)) {
        continue;
      }

      if (($result->problems & MFCS_USER_PROBLEM_ACCOUNT_DISABLED_IN_USE) != 0) {
        $result->problems -= MFCS_USER_PROBLEM_ACCOUNT_DISABLED_IN_USE;
        mfcs_save_user($result->user_id, array('problems' => $result->problems));
      }
    }
  }
}

/**
 * Convert the banner id integer to a string for use in the database.
 *
 * An integer is being used because it is easier to work with, but the banner database uses a string with 9-digits.
 * Zeros are prefixed to the front of the string for proper matching.
 *
 * @param int $banner_id
 *   The banner id to convert to a string.
 *
 * @return string
 *   The converted banner id that should be 9-characters long.
 */
function mfcs_banner_id_int_to_string($banner_id) {
  if (!cf_is_integer($banner_id)) {
    cf_error::invalid_integer('banner_id');
    return FALSE;
  }

  $banner_id_string = '' . $banner_id;

  $length_id = strlen($banner_id_string);
  if ($length_id < MFCS_BANNER_ID_LENGTH) {
    $banner_id_string = str_pad($banner_id_string, MFCS_BANNER_ID_LENGTH, '0', STR_PAD_LEFT);
  }

  return $banner_id_string;
}

/**
 * Enables a static variable to identify that the (effective) system account is currently operating.
 *
 * This is primarily used for/by cron jobs, which use the actual account of anonymous (uid = 0).
 */
function mfcs_set_using_effective_system_id() {
  $static = &drupal_static('mfcs_using_effective_system_id', TRUE);
  $static = TRUE;
}

/**
 * Returns status of whether or not the effective system id status is enabled.
 *
 * @return bool
 *   Returns TRUE if the system id is considered active, FALSE otherwise.
 */
function mfcs_using_effective_system_id() {
  $static = &drupal_static('mfcs_using_effective_system_id', FALSE);

  if (!is_bool($static)) {
    $static = FALSE;
  }

  return $static;
}

/**
 * Returns classifications that have already reviewed the request as for the given step.
 *
 * @param int $request_id
 *   The integer representing the request.
 * @param array $reviewer_classifications
 *   An array of all reviewer classifications to check if they have been reviewed.
 *
 * @return array|bool
 *   An array containing the following:
 *   'reviewed': An array of classifications that have already been reviewed (from provided list).
 *   'available': An array of classifications that have not yet been reviewed (from provided list).
 *   FALSE is returned on error.
 */
function mfcs_get_request_already_reviewed_as_classifications($request_id, $reviewer_classifications) {
  if (!cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  if (!is_array($reviewer_classifications) || empty($reviewer_classifications)) {
    cf_error::invalid_array('reviewer_classifications');
    return FALSE;
  }

  $return = array(
    'reviewed' => array(),
    'available' => array(),
  );

  foreach ($reviewer_classifications as $classification) {
    $return['available'][(int) $classification] = (int) $classification;
  }

  try {
    $query = db_select('mfcs_reviewed', 'mrd_r');
    $query->addField('mrd_r', 'classification', 'classification');
    $query->condition('mrd_r.request_id', $request_id);
    $query->condition('mrd_r.classification', $return['available'], 'IN');

    $results = $query->execute()->fetchAll();
    if (!empty($results)) {
      foreach ($results as $result) {
        $classification = (int) $result->classification;
        $return['reviewed'][$classification] = $classification;
        unset($return['available'][$classification]);
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $return;
}

/**
 * Returns a list of holidays for the given year, month, day.
 *
 * @param int $year
 *   The year the holiday belongs under.
 * @param int|null $timestamp_start
 *   (optional) The timestamp start range.
 *   If the stop range is NULL and this is an integer, then only the specific specified timestamp is loaded.
 * @param int|null $timestamp_stop
 *   (optional) The timestamp stop range.
 *   If NULL, then this value is ignored.
 * @param bool|null $enabled
 *   (optional) When TRUE, only load holidays when the enabled column is 1.
 *   When FALSE, only load holidays when the enabled column is 0.
 *   When NULL, ignore this column.
 * @param bool|null $deleted
 *   (optional) When TRUE, only load holidays when the deleted column is 1.
 *   When FALSE, only load holidays when the deleted column is 0.
 *   When NULL, ignore this column.
 *
 * @return array|bool
 *   An array of holidays.
 *   FALSE is returned on error.
 */
function mfcs_get_holidays($year, $timestamp_start = NULL, $timestamp_stop = NULL, $enabled = TRUE, $deleted = FALSE) {
  if (!cf_is_integer($year)) {
    cf_error::invalid_integer('year');
    return FALSE;
  }

  if (!is_null($timestamp_start) && !cf_is_integer($timestamp_start)) {
    cf_error::invalid_integer('timestamp_start');
    return FALSE;
  }

  if (!is_null($timestamp_stop) && !cf_is_integer($timestamp_stop)) {
    cf_error::invalid_integer('timestamp_stop');
    return FALSE;
  }

  if (!is_null($enabled) && !is_bool($enabled)) {
    cf_error::invalid_bool('enabled');
    return FALSE;
  }

  if (!is_null($deleted) && !is_bool($deleted)) {
    cf_error::invalid_bool('deleted');
    return FALSE;
  }

  try {
    $query = db_select('mfcs_holiday', 'mh');
    $query->addField('mh', 'id', 'id');
    $query->addField('mh', 'date', 'date');
    $query->addField('mh', 'year', 'year');
    $query->addField('mh', 'title', 'title');
    $query->addField('mh', 'description', 'description');
    $query->addField('mh', 'enabled', 'enabled');
    $query->addField('mh', 'deleted', 'deleted');
    $query->addField('mh', 'created', 'created');
    $query->addField('mh', 'updated', 'updated');

    $query->condition('mh.year', $year);

    if ($enabled === TRUE) {
      $query->condition('mh.enabled', 1);
    }
    elseif ($enabled === FALSE) {
      $query->condition('mh.enabled', 0);
    }

    if ($deleted === TRUE) {
      $query->condition('mh.deleted', 1);
    }
    elseif ($deleted === FALSE) {
      $query->condition('mh.deleted', 0);
    }

    if (!is_null($timestamp_start)) {
      // only process values on a per day-to-day basis by setting the timestamps to midnight for each day.
      $timestamp_start_midnight = strtotime('midnight today', $timestamp_start);

      if (is_null($timestamp_stop)) {
        $query->condition('mh.date', $timestamp_start_midnight);
      }
      else {
        // only process values on a per day-to-day basis by setting the timestamps to midnight for each day.
        $timestamp_stop_midnight = strtotime('midnight today', $timestamp_stop);

        $query->condition('mh.date', $timestamp_start_midnight, '>=');
        $query->condition('mh.date', $timestamp_stop_midnight, '<');
      }
    }

    $query->orderBy('mh.date');

    $results = $query->execute()->fetchAllAssoc('id');
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $results;
}

/**
 * Returns information for a specific holiday.
 *
 * @param int $id
 *   The id of the holiday to load.
 * @param bool|null $enabled
 *   (optional) When TRUE, only load holidays when the enabled column is 1.
 *   When FALSE, only load holidays when the enabled column is 0.
 *   When NULL, ignore this column.
 * @param bool|null $deleted
 *   (optional) When TRUE, only load holidays when the deleted column is 1.
 *   When FALSE, only load holidays when the deleted column is 0.
 *   When NULL, ignore this column.
 *
 * @return array|bool
 *   An array of holidays.
 *   FALSE is returned on error.
 */
function mfcs_get_holiday($id, $enabled = TRUE, $deleted = FALSE) {
  if (!cf_is_integer($id)) {
    cf_error::invalid_integer('id');
    return FALSE;
  }

  if (!is_null($enabled) && !is_bool($enabled)) {
    cf_error::invalid_bool('enabled');
    return FALSE;
  }

  if (!is_null($deleted) && !is_bool($deleted)) {
    cf_error::invalid_bool('deleted');
    return FALSE;
  }

  try {
    $query = db_select('mfcs_holiday', 'mh');
    $query->addField('mh', 'id', 'id');
    $query->addField('mh', 'year', 'year');
    $query->addField('mh', 'date', 'date');
    $query->addField('mh', 'title', 'title');
    $query->addField('mh', 'description', 'description');
    $query->addField('mh', 'enabled', 'enabled');
    $query->addField('mh', 'deleted', 'deleted');
    $query->addField('mh', 'created', 'created');
    $query->addField('mh', 'updated', 'updated');

    $query->condition('mh.id', $id);

    if ($enabled === TRUE) {
      $query->condition('mh.enabled', 1);
    }
    elseif ($enabled === FALSE) {
      $query->condition('mh.enabled', 0);
    }

    if ($deleted === TRUE) {
      $query->condition('mh.deleted', 1);
    }
    elseif ($deleted === FALSE) {
      $query->condition('mh.deleted', 0);
    }

    $results = $query->execute()->fetchObject();
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $results;
}

/**
 * Returns a list of unavailabilities for the given year, month, day.
 *
 * @param int $year
 *   The year the unavailability belongs under.
 * @param array|int|null $room_id
 *   (optional) The ID of the room to load.
 *   May be an array of room IDS to load by multiple rooms.
 *   If NULL, then all rooms for the given year are loaded.
 * @param int|null $timestamp_start
 *   (optional) The timestamp start range.
 * @param int|null $timestamp_stop
 *   (optional) The timestamp stop range.
 *   If NULL, then this value is ignored.
 *   If timestamp_start is NULL, then this value is ignored.
 * @param bool|null $enabled
 *   (optional) When TRUE, only load unavailabilities when the enabled column is 1.
 *   When FALSE, only load unavailabilities when the enabled column is 0.
 *   When NULL, ignore this column.
 * @param bool|null $deleted
 *   (optional) When TRUE, only load unavailabilities when the disabled column is 1.
 *   When FALSE, only load unavailabilities when the disabled column is 0.
 *   When NULL, ignore this column.
 * @param bool $inner_joinbs
 *   (optional) When TRUE, additional inner joins will be performed to load the banner room and building information.
 *
 * @return array|bool
 *   An array of unavailabilities.
 *   FALSE is returned on error.
 */
function mfcs_get_unavailabilities($year, $room_id = NULL, $timestamp_start = NULL, $timestamp_stop = NULL, $enabled = TRUE, $deleted = FALSE, $inner_joins = FALSE) {
  if (!cf_is_integer($year)) {
    cf_error::invalid_integer('year');
    return FALSE;
  }

  if (!is_null($room_id) && !cf_is_integer($room_id) && !is_array($room_id)) {
    cf_error::invalid_integer('room_id');
    return FALSE;
  }

  if (!is_null($timestamp_start) && !cf_is_integer($timestamp_start)) {
    cf_error::invalid_integer('timestamp_start');
    return FALSE;
  }

  if (!is_null($timestamp_stop) && !cf_is_integer($timestamp_stop)) {
    cf_error::invalid_integer('timestamp_stop');
    return FALSE;
  }

  if (!is_null($enabled) && !is_bool($enabled)) {
    cf_error::invalid_bool('enabled');
    return FALSE;
  }

  if (!is_null($deleted) && !is_bool($deleted)) {
    cf_error::invalid_bool('deleted');
    return FALSE;
  }

  if (!is_bool($inner_joins)) {
    cf_error::invalid_bool('inner_joins');
    return FALSE;
  }

  // start and stop integers must not be identical.
  if (!is_null($timestamp_start) && !is_null($timestamp_stop)) {
    if ($timestamp_start == $timestamp_stop) {
      cf_error::invalid_integer('timestamp_stop');
      return FALSE;
    }
  }

  try {
    $query = db_select('mfcs_unavailability', 'mu');
    $query->addField('mu', 'id', 'id');
    $query->addField('mu', 'room_id', 'room_id');
    $query->addField('mu', 'building_id', 'building_id');
    $query->addField('mu', 'date_start', 'date_start');
    $query->addField('mu', 'date_stop', 'date_stop');
    $query->addField('mu', 'title', 'title');
    $query->addField('mu', 'description', 'description');
    $query->addField('mu', 'enabled', 'enabled');
    $query->addField('mu', 'deleted', 'deleted');
    $query->addField('mu', 'created', 'created');
    $query->addField('mu', 'updated', 'updated');

    if ($inner_joins) {
      $query->innerJoin('mfcs_banner_rooms', 'mbr', 'mu.room_id = mbr.id');
      $query->innerJoin('mfcs_banner_buildings', 'mbb', 'mu.building_id = mbb.id');

      $query->addField('mbr', 'machine_name', 'room_number');
      $query->addField('mbr', 'human_name', 'room_name');
      $query->addField('mbr', 'coordinator_id', 'room_coordinator_id');
      $query->addField('mbb', 'id', 'building_id');
      $query->addField('mbb', 'machine_name', 'building_code');
      $query->addField('mbb', 'human_name', 'building_name');
    }

    $query->condition('mu.year', $year);

    if (!is_null($room_id)) {
      if (is_array($room_id)) {
        $query->condition('mu.room_id', $room_id, 'IN');
      }
      else {
        $query->condition('mu.room_id', $room_id);
      }
    }

    if ($enabled === TRUE) {
      $query->condition('mu.enabled', 1);
    }
    elseif ($enabled === FALSE) {
      $query->condition('mu.enabled', 0);
    }

    if ($deleted === TRUE) {
      $query->condition('mu.deleted', 1);
    }
    elseif ($deleted === FALSE) {
      $query->condition('mu.deleted', 0);
    }

    if (!is_null($timestamp_start)) {
      if (is_null($timestamp_stop)) {
        $query->condition('mu.date_start', $timestamp_start, '>=');
        $query->condition('mu.date_stop', $timestamp_start, '<');
      }
      else {
        $or = db_or();

        // [B] [DS] [E] [DF] ~ B <= DS && E > DS | DS < E && DF >= E
        // [B] [DS] [DF] [E] ~ B <= DS && E > DF | DS >= B && DF < E
        // [DS] [B] [DF] [E] ~ B >= DS && B < DF | DS <= B && DF > B

        $and = db_and();
        $and->condition('mu.date_start', $timestamp_stop, '<');
        $and->condition('mu.date_stop', $timestamp_stop, '>=');
        $or->condition($and);

        $and = db_and();
        $and->condition('mu.date_start', $timestamp_start, '>=');
        $and->condition('mu.date_stop', $timestamp_stop, '<');
        $or->condition($and);

        $and = db_and();
        $and->condition('mu.date_start', $timestamp_start, '<=');
        $and->condition('mu.date_stop', $timestamp_start, '>');
        $or->condition($and);

        $query->condition($or);

    #( (mu.date_start >= 1469077200) AND (mu.date_start < 1469163600) )
    #OR                  1468389600
    #( (mu.date_stop > 1469077200) AND (mu.date_stop <= 1469163600) )
      }
    }

    $query->orderBy('mu.date_start');
    $query->orderBy('mu.date_stop');

    $results = $query->execute()->fetchAllAssoc('id');
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $results;
}

/**
 * Returns information for a specific unavailability.
 *
 * @param int $id
 *   The id of the unavailability to load.
 * @param bool|null $enabled
 *   (optional) When TRUE, only load unavailabilities when the enabled column is 1.
 *   When FALSE, only load unavailabilities when the enabled column is 0.
 *   When NULL, ignore this column.
 * @param bool|null $deleted
 *   (optional) When TRUE, only load unavailabilities when the disabled column is 1.
 *   When FALSE, only load unavailabilities when the disabled column is 0.
 *   When NULL, ignore this column.
 *
 * @return array|bool
 *   An array of unavailabilities.
 *   FALSE is returned on error.
 */
function mfcs_get_unavailability($id, $enabled = TRUE, $deleted = FALSE) {
  if (!cf_is_integer($id)) {
    cf_error::invalid_integer('id');
    return FALSE;
  }

  if (!is_null($enabled) && !is_bool($enabled)) {
    cf_error::invalid_bool('enabled');
    return FALSE;
  }

  if (!is_null($deleted) && !is_bool($deleted)) {
    cf_error::invalid_bool('deleted');
    return FALSE;
  }

  try {
    $query = db_select('mfcs_unavailability', 'mu');
    $query->addField('mu', 'id', 'id');
    $query->addField('mu', 'year', 'year');
    $query->addField('mu', 'room_id', 'room_id');
    $query->addField('mu', 'building_id', 'building_id');
    $query->addField('mu', 'date_start', 'date_start');
    $query->addField('mu', 'date_stop', 'date_stop');
    $query->addField('mu', 'title', 'title');
    $query->addField('mu', 'description', 'description');
    $query->addField('mu', 'enabled', 'enabled');
    $query->addField('mu', 'deleted', 'deleted');
    $query->addField('mu', 'created', 'created');
    $query->addField('mu', 'updated', 'updated');

    $query->condition('mu.id', $id);

    if ($enabled === TRUE) {
      $query->condition('mu.enabled', 1);
    }
    elseif ($enabled === FALSE) {
      $query->condition('mu.enabled', 0);
    }

    if ($deleted === TRUE) {
      $query->condition('mu.deleted', 1);
    }
    elseif ($deleted === FALSE) {
      $query->condition('mu.deleted', 0);
    }

    $results = $query->execute()->fetchObject();
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $results;
}

/**
 * Load the reviewer classifications for a given user for a given request classification and step.
 *
 * @param int $user_id
 *   ID of the user to process classifications for.
 * @param int $request_classification
 *   Integer of the request classification to fine-tune results based on.
 * @param int $review_step
 *   Integer of the review step to fine-tune results based on.
 *
 * @param array|bool
 *   An array containing reviewer classifications with the following keys:
 *   - 'step': all reviewer classifications associated with the given step.
 *   - 'all': all reviewer classifications associated with the request.
 *   FALSE is returned on error.
 */
function mfcs_get_reviewer_classifications($user_id, $request_classification, $review_step) {
  if (!cf_is_integer($user_id)) {
    cf_error::invalid_integer('user_id');
    return FALSE;
  }

  if (!cf_is_integer($request_classification)) {
    cf_error::invalid_integer('request_classification');
    return FALSE;
  }

  if (!cf_is_integer($review_step)) {
    cf_error::invalid_integer('review_step');
    return FALSE;
  }

  $reviewer_classifications = array(
    'step' => array(),
    'all' => array(),
  );

  $reviewer_conditions = array(
    'mr.user_id' => $user_id,
    'mr.request_classification' => $request_classification,
    'mr.disabled' => 0,
  );

  $reviewers_returned = mfcs_get_reviewers($reviewer_conditions, array('join' => TRUE));
  $reviewers = array();
  if (isset($reviewers_returned['results']) && is_array($reviewers_returned['results'])) {
    $reviewers = $reviewers_returned['results'];
  }
  unset($reviewers_returned);

  foreach ($reviewers as $reviewer) {
    if (is_string($reviewer->reviewer_classification)) {
      $reviewer_classification = (int) $reviewer->reviewer_classification;
    }
    else {
      $reviewer_classification = $reviewer->reviewer_classification;
    }

    $step = NULL;
    if (isset($reviewer->review_step)) {
      if (is_string($reviewer->review_step)) {
        $step = (int) $reviewer->review_step;
      }
      else {
        $step = $reviewer->review_step;
      }
    }

    if ($review_step === $step) {
      $reviewer_classifications['step'][$reviewer_classification] = $reviewer_classification;
    }

    $reviewer_classifications['all'][$reviewer_classification] = $reviewer_classification;
  }

  return $reviewer_classifications;
}

/**
 * Given an array of request classifications, return which have not yet been reviewed.
 *
 * @param int $request_id
 *   The id of the request.
 * @param array $reviewer_classifications
 *   An array of reviewer classifications with the array keys being the numeric id of the classification.
 *
 * @return array|bool
 *   An array containing a copy of $reviewer_classifications with already reviewed classifications removed.
 *   FALSE is returned on error.
 */
function mfcs_remove_processed_reviewed_classifications($request_id, $reviewer_classifications) {
  if (!cf_is_integer($request_id)) {
    cf_error::invalid_integer('request_id');
    return FALSE;
  }

  if (!is_array($reviewer_classifications)) {
    cf_error::invalid_array('reviewer_classifications');
    return FALSE;
  }

  $remaining = $reviewer_classifications;

  if (empty($remaining)) {
    return $remaining;
  }

  try {
    $query = db_select('mfcs_reviewed', 'mr');
    $query->addField('mr', 'classification', 'classification');
    $query->condition('request_id', $request_id);
    $query->condition('classification', array_keys($reviewer_classifications), 'IN');
    $results = $query->execute()->fetchAll();

    $processed = array();

    if (is_array($results)) {
      foreach ($results as $result) {
        unset($remaining[$result->classification]);
      }
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);

    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);

    return FALSE;
  }

  return $remaining;
}

/**
 * Get the ids of all requesters for the specified requests.
 *
 * @param array $request_ids
 *   An array of request ids to process.
 *
 * @param array|bool
 *   An array containing the requesters indexed by the request id.
 *   FALSE is returned on error.
 */
function mfcs_load_requesters_of_requests($request_ids) {
  if (!is_array($request_ids)) {
    cf_error::invalid_array('request_ids');
    return FALSE;
  }

  if (empty($request_ids)) {
    return array();
  }

  try {
    $query = db_select('mfcs_requests', 'mer');
    $query->addField('mer', 'id', 'request_id');
    $query->addField('mer', 'user_id', 'user_id');
    $query->condition('mer.id', $request_ids, 'IN');
    $results = $query->execute()->fetchAllAssoc('request_id');

    if (!is_array($results)) {
      return FALSE;
    }
  }
  catch (Error $e) {
    cf_error::on_exception($e);
    return FALSE;
  }
  catch (Exception $e) {
    cf_error::on_exception($e);
    return FALSE;
  }

  $return = array();
  foreach ($request_ids as $request_id) {
    if (array_key_exists($request_id, $results)) {
      $return[$request_id] = $results[$request_id]->user_id;
    }
    else {
      $return[$request_id] = NULL;
    }
  }

  return $return;
}

/**
 * Load LDAP user name for the given banner id.
 *
 * @param int $banner_id
 *   The numeric banner id to search by.
 *
 * @param bool|string
 *   Username string on success, FALSE otherwise.
 */
function mfcs_get_ldap_user_name_by_banner_id($banner_id) {
  if (!cf_is_integer($banner_id)) {
    cf_error::invalid_integer('banner_id');
    return FALSE;
  }

  $ldap_servers = ldap_servers_get_servers(NULL, 'enabled');
  $ldap_server = NULL;

  if (empty($ldap_servers)) {
    return FALSE;
  }

  // @fixme: currently only searching the first enabled server found.
  foreach ($ldap_servers as $server) {
    if ($server->status) {
      $ldap_server = $server;
      break;
    }
  }

  if (is_null($ldap_server)) {
    return FALSE;
  }

  $banner_id_string = mfcs_banner_id_int_to_string($banner_id);
  $attr_banner_id = ldap_server_massage_text($banner_id_string, 'attr_value', LDAP_SERVER_MASSAGE_QUERY_LDAP);
  $search_results = $ldap_server->search(NULL, 'employeeNumber=' . $attr_banner_id);

  if (isset($search_results[0]['uid'][0])) {
    return $search_results[0]['uid'][0];
  }

  return FALSE;
}

/**
 * @} End of '@defgroup mfcs McNeese Facilities Use'.
 */
