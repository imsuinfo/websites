<?php

/**
 * @file
 * McNeese State University Content Formats module.
 */

/**
 * @defgroup mcneese_content McNeese Content Formats
 * @{
 * Provides content formatting functionality and changes to drupal 7.
 */

/**
 * Implements hook_mcneese_content_permission_alter().
 */
function mcneese_content_formats_mcneese_content_permission_alter(&$permissions) {
  if (!is_array($permissions)) $permissions = array();

  $permissions['bypass deny abused codes'] = array(
    'title' => t("Bypass Deny Abused Codes"),
    'description' => t("Grants permissions to bypass the removal of abused codes for text formats in which the deny abused codes filter is enabled."),
  );

  $permissions['bypass denied tags'] = array(
    'title' => t("Bypass Denied Tags"),
    'description' => t("Grants permissions to bypass the restriction of saving content with unauthorized tags."),
  );
}

/**
 * Implements hook_mcneese_content_node_type_form_alter().
 */
function mcneese_content_formats_mcneese_content_node_type_form_alter(&$form, &$form_state, &$form_id) {
  if (empty($form_id)) return;

  $deny_abused_codes_default = variable_get('mcneese_content_formats_deny_abused_codes_' . $form['#node_type']->type, FALSE);
  $denied_tags_default = variable_get('mcneese_content_formats_denied_tags_' . $form['#node_type']->type, 'script noscript');
  $fix_links_default = variable_get('mcneese_content_formats_fix_links_' . $form['#node_type']->type, FALSE);
  $fix_markup_default = variable_get('mcneese_content_formats_fix_markup_' . $form['#node_type']->type, FALSE);

  $form['mcneese_content']['deny_abused_codes'] = array(
    '#type' => 'checkbox',
    '#title' => t("Deny Abused Codes"),
    '#default_value' => $deny_abused_codes_default,
    '#description' => t("This enables the denial of certain html codes that have been identified as commonly abused or mis-used by end-user."),
  );

  $form['mcneese_content']['denied_tags'] = array(
    '#type' => 'textfield',
    '#title' => t("Denied Tags"),
    '#maxlength' => 4096,
    '#default_value' => $denied_tags_default,
    '#description' => t("This prevents saving content with tags that are in this list. Set this to nothing to allow all tags."),
  );

  $form['mcneese_content']['fix_links'] = array(
    '#type' => 'checkbox',
    '#title' => t("Fix Links"),
    '#default_value' => $fix_links_default,
    '#description' => t("This enables the correction of the mis-use of url links. This also updates older and no longer valid links to use the newer method. This currently only fixes a and img links."),
  );

  $form['mcneese_content']['fix_markup'] = array(
    '#type' => 'checkbox',
    '#title' => t("Fix Markup (declobber)"),
    '#default_value' => $fix_markup_default,
    '#description' => t("This enables the correction of the mis-use or non-proper HTML. In general, this partially cleans up some of the mess that comes from a copy and pasted word document (or similar)."),
  );
}

/**
 * Implements hook_mcneese_content_node_type_form_submit_alter().
 */
function mcneese_content_formats_mcneese_content_node_type_form_submit_alter($form, &$form_state) {
  if (!isset($form['#node_type']) && !is_object($form['#node_type'])) return;

  cf_settings_register('mcneese_content_formats_deny_abused_codes_' . $form['#node_type']->type, 'drupal_variables', 'mcneese_content_formats', TRUE);
  cf_settings_register('mcneese_content_formats_denied_tags_' . $form['#node_type']->type, 'drupal_variables', 'mcneese_content_formats', TRUE);
  cf_settings_register('mcneese_content_formats_fix_links_' . $form['#node_type']->type, 'drupal_variables', 'mcneese_content_formats', TRUE);
  cf_settings_register('mcneese_content_formats_fix_markup_' . $form['#node_type']->type, 'drupal_variables', 'mcneese_content_formats', TRUE);

  if (isset($form_state['values']['mcneese_content']['deny_abused_codes']) && $form_state['values']['mcneese_content']['deny_abused_codes']) {
    variable_set('mcneese_content_formats_deny_abused_codes_' . $form['#node_type']->type, TRUE);
  }
  else {
    variable_set('mcneese_content_formats_deny_abused_codes_' . $form['#node_type']->type, FALSE);
  }

  if (isset($form_state['values']['mcneese_content']['denied_tags'])) {
    variable_set('mcneese_content_formats_denied_tags_' . $form['#node_type']->type, $form_state['values']['mcneese_content']['denied_tags']);
  }
  else {
    variable_set('mcneese_content_formats_denied_tags_' . $form['#node_type']->type, '');
  }

  if (isset($form_state['values']['mcneese_content']['fix_links']) && $form_state['values']['mcneese_content']['fix_links']) {
    variable_set('fix_links_' . $form['#node_type']->type, TRUE);
  }
  else {
    variable_set('mcneese_content_formats_fix_links_' . $form['#node_type']->type, FALSE);
  }

  if (isset($form_state['values']['mcneese_content']['fix_markup']) && $form_state['values']['mcneese_content']['fix_markup']) {
    variable_set('fix_markup_' . $form['#node_type']->type, TRUE);
  }
  else {
    variable_set('mcneese_content_formats_fix_markup_' . $form['#node_type']->type, FALSE);
  }
}

/**
 * Implements hook_node_presave().
 */
function mcneese_content_formats_node_presave($node) {
  $deny_abused_codes_value = variable_get('mcneese_content_formats_deny_abused_codes_' . $node->type, FALSE);

  $denied_tags_string = variable_get('mcneese_content_formats_denied_tags_' . $node->type, 'script noscript');
  $denied_tags = explode(' ', $denied_tags_string);
  if (user_access('bypass denied tags')) {
    $denied_tags = array();
  }

  $operations = array();
  $operations['deny_abused_codes'] = $deny_abused_codes_value && !user_access('bypass deny abused codes');
  $operations['fix_links'] = variable_get('mcneese_content_formats_fix_links_' . $node->type, FALSE);
  $operations['fix_markup'] = variable_get('mcneese_content_formats_fix_markup_' . $node->type, FALSE);
  $operations['denied_tags'] = $denied_tags;

  $abused_codes = array();
  $abused_codes['&#34;'] = '"';
  $abused_codes['&#38;'] = '&amp;';
  $abused_codes['&#39;'] = '\'';
  $abused_codes['&#60;'] = '&lt;';
  $abused_codes['&#62;'] = '&gt;';
  $abused_codes['&quot;'] = '"';
  $abused_codes['&ndash;'] = '-';
  $abused_codes['&mdash;'] = '-';
  $abused_codes['&lsquo;'] = '\'';
  $abused_codes['&rsquo;'] = '\'';
  $abused_codes['&ldquo;'] = '"';
  $abused_codes['&rdquo;'] = '"';


  $node_variables = array_keys(get_object_vars($node));

  // at this time 'deny abused codes' is only applied to the body field (and its summary).
  // this does not pay attention to text formats.
  // if such flexibility is needed, then it will be added on a per-text-field basis.
  if (property_exists($node, 'body') && is_array($node->body)) {
    foreach ($node->body as $language => &$language_value) {
      foreach ($language_value as $index => &$index_value) {
        // do not process this filter for php_code format because this will alter the php_code closing tag.
        // @todo: find a way to still do this without breaking the php code.
        if (isset($index_value['format']) && $index_value['format'] == 'php_code') {
          continue;
        }

        if (!empty($index_value['summary'])) {
          if ($operations['deny_abused_codes']) mcneese_content_formats_deny_abused_codes($abused_codes, $index_value['summary']);
          mcneese_content_formats_alter_dom($index_value['summary'], $operations);
        }

        if (!empty($index_value['value'])) {
          if ($operations['deny_abused_codes']) mcneese_content_formats_deny_abused_codes($abused_codes, $index_value['value']);
          mcneese_content_formats_alter_dom($index_value['value'], $operations);
        }
      }
    }
  }
}

/**
 * Strip out used code from index.
 *
 * @param array $abused_code
 *   An array of codes and their replacements.
 * @param string $value
 *   The text to alter.
 */
function mcneese_content_formats_deny_abused_codes($abused_codes, &$value) {
  foreach ($abused_codes as $code => $replacement) {
    $replaced = preg_replace('|' . $code . '|i', $replacement, $value);

    if ($replaced !== FALSE) {
      $value = $replaced;
    }
  }
}

/**
 * Make changes to markup using cf_dom.
 *
 * @param string $text
 *   The text to alter.
 * @param array $operations
 *   A collection of operations designating what to do and not to do.
 */
function mcneese_content_formats_alter_dom(&$text, $operations) {
  if (empty($text)) return '';

  $dom = new cf_dom(NULL, TRUE, TRUE, $text);

  $prefix = 'mt_';
  $body = $dom->get_body();
  if (is_null($body)) {
    return $text;
  }

  $unsupported_tags = array();
  $unsupported_tags[] = 'font';
  $unsupported_tags[] = 'basefont';
  $unsupported_tags[] = 'big';
  $unsupported_tags[] = 'center';
  $unsupported_tags[] = 'dir';
  $unsupported_tags[] = 'frame';
  $unsupported_tags[] = 'noframes';
  $unsupported_tags[] = 'tt';

  $unsupported_attributes = array();
  $unsupported_attributes[] = 'lang';
  $unsupported_attributes[] = 'align';
  $unsupported_attributes[] = 'valign';
  $unsupported_attributes[] = 'abbr';
  $unsupported_attributes[] = 'axis';
  $unsupported_attributes[] = 'bgcolor';
  $unsupported_attributes[] = 'char';
  $unsupported_attributes[] = 'charoff';
  $unsupported_attributes[] = 'nowrap';
  $unsupported_attributes[] = 'charset';

  $unsupported_td_attr = array();
  $unsupported_td_attr[] = 'height';
  $unsupported_td_attr[] = 'scope';
  $unsupported_td_attr[] = 'width';

  $altered = FALSE;
  $all_tags = $body->getElementsByTagName('*');

  foreach ($all_tags as $tag) {
    if (in_array($tag->tagName, $operations['denied_tags'])) {
      $dom->remove_element($tag);
      $altered = TRUE;
      continue;
    }

    if ($operations['fix_links']) {
      if ($tag->tagName == 'a') {
        if ($tag->hasAttribute('href')) {
          $processed = mcneese_content_formats_get_correct_links($tag->getAttribute('href'));

          if ($processed !== FALSE) {
            $tag->setAttribute('href', $processed);
            $altered = TRUE;
          }
        }
      }
      elseif ($tag->tagName == 'img') {
        if ($tag->hasAttribute('src')) {
          $processed = mcneese_content_formats_get_correct_links($tag->getAttribute('src'));

          if ($processed !== FALSE) {
            $tag->setAttribute('src', $processed);
            $altered = TRUE;
          }
        }
      }
    }

    if ($operations['fix_markup']) {
      // replace b tags with strong
      if ($tag->tagName == 'b') {
        $dom->change_element($tag, 'strong');
        $altered = TRUE;
      }
      // replace i tags with em
      elseif ($tag->tagName == 'i') {
        $dom->change_element($tag, 'em');
        $altered = TRUE;
      }
      // replace strike tags with del
      elseif ($tag->tagName == 'strike') {
        $dom->change_element($tag, 'del');
        $altered = TRUE;
      }
      // remove all unsupported tags, but preserve their content.
      elseif (in_array($tag->tagName, $unsupported_tags)) {
        $dom->remove_element($tag);
        $altered = TRUE;
        continue;
      }
      // remove span tags with lang=".." attribute, but preserve their content.
      elseif ($tag->tagName == 'span') {
        if ($tag->hasAttribute('lang')) {
          $dom->remove_element($tag);
          $altered = TRUE;
          continue;
        }

        // remove spans that have no attributes.
        if (!$tag->hasAttributes()) {
          $dom->remove_element($tag);
          $altered = TRUE;
          continue;
        }
      }
      // problems with paragraphs.
      elseif ($tag->tagName == 'p') {
        if ($tag->hasAttribute('style')) {
          $tag->removeAttribute('style');
          $altered = TRUE;
        }

        // replace empty tags that are generally created to implement a line break
        if (!$tag->hasChildNodes()) {
          $dom->change_element($tag, 'br');
          $altered = TRUE;
        }
      }
      // strip out attributes no longer supported in html 5 for specific tags.
      elseif ($tag->tagName == 'td') {
        foreach ($unsupported_td_attr as $attr_name) {
          if ($tag->hasAttribute($attr_name)) {
            $tag->removeAttribute($attr_name);
            $altered = TRUE;
          }
        }
      }
      elseif ($tag->tagName == 'div') {
        // replace empty tags that are generally created to implement a line break
        if (!$tag->hasChildNodes()) {
          $dom->change_element($tag, 'br');
          $altered = TRUE;
        }
      }
      elseif ($tag->tagName == 'h1' || $tag->tagName == 'h2' || $tag->tagName == 'h3' || $tag->tagName == 'h4' || $tag->tagName == 'h5' || $tag->tagName == 'h6') {
        // replace empty tags that are generally created to implement a line break
        if (!$tag->hasChildNodes()) {
          $dom->change_element($tag, 'br');
          $altered = TRUE;
        }
      }


      // replace name with id (deprecate name tag, except on image maps and params).
      if ($tag->hasAttribute('name') && $tag->tagName != "map" && $tag->tagName != "param") {
        $name_value = $tag->getAttribute('name');
        $tag->removeAttribute('name');
        $tag->setAttribute('id', $name_value);
        $altered = TRUE;
      }


      // strip out unsupported attributes.
      foreach ($unsupported_attributes as $attr_name) {
        if ($tag->hasAttribute($attr_name)) {
          $tag->removeAttribute($attr_name);
          $altered = TRUE;
        }
      }
    }
  }

  if ($altered) {
    $text = $dom->get_markup();
  }
}

/**
 * Interprets link and tries to replace it with proper link if applicable.
 *
 * @param string $url
 *   The url link to process.
 *
 * @return string|bool
 *   The updated url link or FALSE otherwise.
 */
function mcneese_content_formats_get_correct_links($url) {
  global $base_path;
  global $base_root;
  global $base_url;

  $default_redirect = variable_get('redirect_default_status_code', 301);
  $base = parse_url($base_url);
  $parsed = parse_url($url);
  $altered = FALSE;

  // only process known schemes
  if (!empty($parsed['scheme']) && !in_array($parsed['scheme'], array('http', 'https'))) {
    return FALSE;
  }

  // if either host or scheme is defined, then both must be defined.
  if (!empty($parsed['scheme']) && empty($parsed['host']) || empty($parsed['scheme']) && !empty($parsed['host'])) {
    return FALSE;
  }

  // if path is empty, then there is nothing to do.
  if (empty($parsed['host']) && empty($parsed['path'])) {
    return FALSE;
  }

  // fix local paths that use absolute links.
  if (!empty($parsed['host']) && $base['host'] == $parsed['host']) {
    if (empty($parsed['path'])) {
      unset($parsed['scheme']);
      unset($parsed['host']);
      $parsed['path'] = $base_path;
      $altered = TRUE;
    }
    elseif (preg_match('@^' . $base_path . '@i', $parsed['path'])) {
      unset($parsed['scheme']);
      unset($parsed['host']);
      $altered = TRUE;
    }
  }

  if (empty($parsed['scheme'])) {
    if (preg_match('@^' . $base_path . '@i', $parsed['path'])) {
      $path = rawurldecode(preg_replace('@^' . $base_path . '@i', '', $parsed['path']));

      // check to see if a url redirection exists for the given path.
      if (function_exists('redirect_url')) {
        $redirect = redirect_load_by_source($path);

        if (is_object($redirect)) {
          // only operate on 'found' and 'permanent' redirects.
          if ((empty($redirect->status_code) && ($default_redirect == 301 || $default_redirect == 302)) || $redirect->status_code == 301 || $redirect->status_code == 302) {
            $path = $redirect->redirect;
            $altered = TRUE;
          }
        }
      }

      // check to see what drupal returns for the given path.
      $source = drupal_lookup_path('source', $path);

      if (!empty($source)) {
        $path = $source;
        $altered = TRUE;
      }

      $parsed['path'] = $base_path . $path;
    }
  }

  // recombine url
  if ($altered) {
    $new_url = $parsed['path'];

    if (isset($parsed['query'])) {
      $new_url .= $parsed['query'];
    }

    if (isset($parsed['fragment'])) {
      $new_url .= $parsed['fragment'];
    }

    return $new_url;
  }

  return FALSE;
}

/**
 * @} End of '@defgroup mcneese_content_formats McNeese Content Formats'.
 */
