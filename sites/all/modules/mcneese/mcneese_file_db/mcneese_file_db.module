<?php

/**
 * @file
 * McNeese State University File Database module.
 */

/**
 * @defgroup mcneese_file_db McNeese File Database
 * @{
 * @todo: write this documentation.
 */


define('MCNEESE_FILE_DB_TARGET', 'default');
define('MCNEESE_FILE_DB_KEY', 'file_db');
define('MCNEESE_FILE_DB_CONF_SERVER_ID', 'file_db_server_id');
define('MCNEESE_FILE_DB_SHORT_SUM_SIZE', 8);
define('MCNEESE_FILE_DB_BLOCK_SIZE', 131072);

define('MCNEESE_FILE_DB_FILE_PATH', 'f');
define('MCNEESE_FILE_DB_STYLES', 'styles');
define('MCNEESE_FILE_DB_PATH_BY_HASH', 'c');
define('MCNEESE_FILE_DB_PATH_BY_HASH_SUM', 's');
define('MCNEESE_FILE_DB_PATH_BY_HASH_SUM_EXTENSION', 'sha256sum');
define('MCNEESE_FILE_DB_PATH_BY_HASH_ALGORITHM', 'sha256');


/**
 * Implements hook_stream_wrappers().
 */
function mcneese_file_db_stream_wrappers() {
  $wrappers = array();
  $path = drupal_get_path('module', 'mcneese_file_db');

  require_once DRUPAL_ROOT . '/' . $path . '/classes/mcneese_file_db_unrestricted_stream_wrapper.inc';
  //require_once DRUPAL_ROOT . '/' . $path . '/classes/mcneese_file_db_restricted_stream_wrapper.inc';

  $wrappers[mcneese_file_db_unrestricted_stream_wrapper::SCHEME] = array (
    'name' => t("Unrestricted File Database"),
    'class' => 'mcneese_file_db_unrestricted_stream_wrapper',
    'description' => t("Unrestricted files stored in a dedicated file database and shared between multiple servers."),
    'type' => STREAM_WRAPPERS_NORMAL | STREAM_WRAPPERS_REMOTE,
    'dynamic' => TRUE,
    'remote' => TRUE,
  );
/*
  $wrappers[mcneese_file_db_restricted_stream_wrapper::SCHEME] = array (
    'name' => t("Restricted File Database"),
    'class' => 'mcneese_file_db_restricted_stream_wrapper',
    'description' => t("Restricted files stored in a dedicated file database and shared between multiple servers."),
    'type' => STREAM_WRAPPERS_NORMAL | STREAM_WRAPPERS_REMOTE,
    'dynamic' => TRUE,
    'remote' => TRUE,
  );
*/
  return $wrappers;
}

/**
 * Access callback for files.
 *
 * @param string $by
 *   (optional) Short string that defines what the arg1->arg3 are.
 * @param string $arg1
 *   (optional) A conditional argument.
 * @param string $arg2
 *   (optional) A conditional argument.
 * @param string $arg3
 *   (optional) A conditional argument.
 */
function mcneese_file_db_load_file_access($by = '', $arg1 = '', $arg2 = '', $arg3 = '') {
  if (empty($by)) {
    return FALSE;
  }

  // @todo: implement this for private files?
  // for now, just return TRUE.

  return TRUE;
}

/**
 * Builds and returns a file_db query object.
 *
 * @return object
 *   A file_db query object.
 */
function mcneese_file_db_prepare_connection() {
  $file_db = Database::getConnection(MCNEESE_FILE_DB_TARGET, MCNEESE_FILE_DB_KEY);

  return $file_db;
}

/**
 * Builds and returns a query options array.
 *
 * @return array
 *   A query options array.
 */
function mcneese_file_db_prepare_options() {
  $options = array();
  $options['target'] = MCNEESE_FILE_DB_TARGET;

  return $options;
}

/**
 * Loads the server id from the database.
 *
 * This function will cache the result to avoid repeated SQL queries.
 *
 * @return null|integer
 *   Returns a number representing this server or NULL on failure.
 */
function mcneese_file_db_get_server_id() {
  global $conf;

  if (empty($conf[MCNEESE_FILE_DB_CONF_SERVER_ID])) {
    return null;
  }

  return $conf[MCNEESE_FILE_DB_CONF_SERVER_ID];
}

/**
 * Loads the available files.
 *
 * @param array $conditions
 *   (optional) An array of conditions to apply to the database query.
 *    The following are supported:
 *    - range: an array of:
 *      - start: start range.
 *      - stop: stop range.
 *    - filename: Perform a like test against the files filename.
 *    - extension: Perform a like test against the filesextension.
 *    - mimetype: Perform a like test against the filesmimetype.
 *    - checksum: Perform a like test against the checksum.
 *    - timestamp: An array of:
 *      - operation: one of '>', '>=', '<', '<=', '<>', '=='.
 *      - stamp: timestamp to compare against.
 *
 * @return bool
 *   TRUE/FALSE depending on whether the file listing was loaded.
 */
function mcneese_file_db_load_available_files($conditions = array()) {
  global $conf;

  if (empty($conf[MCNEESE_FILE_DB_CONF_SERVER_ID])) {
    return FALSE;
  }

  try {
    $file_db = mcneese_file_db_prepare_connection();
    $options = mcneese_file_db_prepare_options();

    $query = 'SELECT mfdf.* FROM {mcneese_file_db_files} mfdf';
    $query .= ' INNER JOIN {mcneese_file_db_associations} mfda ON (mfdf.id = mfda.file_id AND mfda.server_id = :server_id)';

    $arguments = array(':server_id' => $conf[MCNEESE_FILE_DB_CONF_SERVER_ID]);

    if (!empty($conditions)) {
      $and = null;

      if (!empty($conditions['filename'])) {
        if (is_null($and)) {
          $and = '';
        }
        else {
          $and .= ' AND';
        }

        $and .= ' mfdf.filename LIKE :filename';
        $arguments[':filename'] = $conditions['filename'];
      }

      if (!empty($conditions['extension'])) {
        if (is_null($and)) {
          $and = '';
        }
        else {
          $and .= ' AND';
        }

        $and .= ' mfdf.extension LIKE :extension';
        $arguments[':extension'] = $conditions['extension'];
      }

      if (!empty($conditions['mimetype'])) {
        if (is_null($and)) {
          $and = '';
        }
        else {
          $and .= ' AND';
        }

        $and .= ' mfdf.mimetype LIKE :mimetype';
        $arguments[':mimetype'] = $conditions['mimetype'];
      }

      if (!empty($conditions['checksum'])) {
        if (is_null($and)) {
          $and = '';
        }
        else {
          $and .= ' AND';
        }

        if (strlen($conditions['checksum']) == MCNEESE_FILE_DB_SHORT_SUM_SIZE) {
          $and .= ' mfdf.checksum LIKE :checksum';
          $arguments[':checksum'] = $file_db->escapeLike($conditions['checksum']) . '%';
        }
        else {
          $and .= ' mfdf.checksum = :checksum';
          $arguments[':checksum'] = $conditions['checksum'];
        }
      }

      if (!empty($conditions['id'])) {
        if (is_null($and)) {
          $and = '';
        }
        else {
          $and .= ' AND';
        }

        $and .= ' mfdf.id = :id';
        $arguments[':id'] = $conditions['id'];
      }

      if (isset($conditions['timestamp']['operation']) && isset($conditions['timestamp']['stamp'])) {
        if (in_array($conditions['timestamp']['operation'], array('>', '>=', '<', '<=', '<>', '=='))) {
          if (is_null($and)) {
            $and = '';
          }
          else {
            $and .= ' AND';
          }

          $and .= ' mfdf.timestamp ' . $conditions['timestamp']['operation'] . ' :timestamp';
          $arguments[':timestamp'] = $conditions['timestamp'];
        }
      }

      if (!is_null($and)) {
        $query .= ' WHERE ' . $and;
      }
    }

    if (isset($conditions['range']['start']) && isset($conditions['range']['stop'])) {
      $results = $file_db->queryRange($query, $conditions['range']['start'], $conditions['range']['stop'], $arguments, $options);
    }
    else {
      $results = $file_db->query($query, $arguments, $options);
    }

    return $results->fetchAll();
  }
  catch (Exception $e) {
    cf_error::on_query_execution($e);

    throw $e;
  }

  return FALSE;
}

/**
 * Build a select query for the file table.
 *
 * @param string $checksum
 *   The checksum to compare against.
 *
 * @param bool $associated
 *   (optional) If TRUE, then limit query to associated files.
 *   If FALSE, then do not limit query to associated files.
 *
 * @return array|bool
 *   An array of:
 *   - query: The query string.
 *   - arguments: An array of query arguments.
 *
 *   If there is an error, the FALSE is returned.
 */
function mcneese_file_db_build_query_by_checksum($checksum, $associated = TRUE) {
  global $conf;

  if (empty($conf[MCNEESE_FILE_DB_CONF_SERVER_ID])) {
    return FALSE;
  }

  $built = array();
  $built['query'] = '';
  $built['arguments'] = array();

  $built['query'] = 'SELECT mfdf.* FROM {mcneese_file_db_files} mfdf';

  if ($associated) {
    $built['arguments'][':server_id'] = $conf[MCNEESE_FILE_DB_CONF_SERVER_ID];
    $built['query'] .= ' INNER JOIN {mcneese_file_db_associations} mfda ON (mfdf.id = mfda.file_id AND mfda.server_id = :server_id)';
  }

  if (count($checksum) == MCNEESE_FILE_DB_SHORT_SUM_SIZE) {
    $built['query'] .= ' WHERE mfdf.checksum LIKE :checksum';
    $built['arguments'][':checksum'] = db_like($checksum);
  }
  else {
    $built['query'] .= ' WHERE mfdf.checksum = :checksum';
    $built['arguments'][':checksum'] = $checksum;
  }

  return $built;
}

/**
 * Loads the specified file.
 *
 * @param string $by
 *   (optional) Short string that defines what the arg1->arg3 are.
 * @param string $arg1
 *   (optional) A conditional argument.
 * @param string $arg2
 *   (optional) A conditional argument.
 * @param string $arg3
 *   (optional) A conditional argument.
 *
 * @return bool
 *   TRUE on access denied, FALSE on file not found.
 */
function mcneese_file_db_load_file($by = '', $arg1 = '', $arg2 = '', $arg3 = '') {
  $filepath = '';
  $file_meta = FALSE;
  $not_modified = FALSE;

  // @todo: perform access control

  // load the file based on the arguments
  if ($by == MCNEESE_FILE_DB_PATH_BY_HASH || $by == MCNEESE_FILE_DB_PATH_BY_HASH_SUM) {
    // $arg1 = checksum
    // $arg2 = custom filename

    $if_none_match = '';

    if (isset($_SERVER['HTTP_IF_NONE_MATCH'])) {
      $if_none_match = substr($_SERVER['HTTP_IF_NONE_MATCH'], 1);
      $if_none_match = substr($if_none_match, 0, -1);
    }

    if (!empty($arg1)) {
      $filepath = mcneese_file_db_unrestricted_stream_wrapper::SCHEME . '://';

      if (!strncmp($arg1, $if_none_match, MCNEESE_FILE_DB_SHORT_SUM_SIZE)) {
        $filepath .= MCNEESE_FILE_DB_PATH_BY_HASH . '/' . $if_none_match;
        $files = (array) mcneese_file_db_load_available_files(array('checksum' => $if_none_match));
        $not_modified = TRUE;
      }
      else {
        $filepath .= MCNEESE_FILE_DB_PATH_BY_HASH . '/' . $arg1;
        $files = (array) mcneese_file_db_load_available_files(array('checksum' => $arg1));
      }

      if (!empty($files)) {
        $file_meta = array_pop($files);
        unset($files);
      }
    }
  }

  if (!empty($file_meta) && !empty($filepath)) {
    // prevent devel_shutdown from being called.
    $GLOBALS['devel_shutdown'] = FALSE;

    $mimetype =$file_meta->mimetype;

    if (empty($arg2)) {
      $filename = $file_meta->filename;

      if (!empty($file_meta->extension)) {
        $filename .= '.' . $file_meta->extension;
      }
    }
    else {
      $filename = rawurldecode($arg2);
    }

    $filesize = $file_meta->size;

    // failsafes
    if (empty($filename)) {
      $filename = 'download.txt';
    }

    if (empty($mimetype)) {
      $mimetype = 'text/plain';
    }

    if (empty($filesize)) {
      $filesize = 0;
    }

    if ($by == MCNEESE_FILE_DB_PATH_BY_HASH) {
      if (ob_get_level()) {
        ob_end_clean();
        ob_end_flush();
      }

      $content_location = '/' . MCNEESE_FILE_DB_FILE_PATH . '/' . MCNEESE_FILE_DB_PATH_BY_HASH;
      $content_location .= '/' . $file_meta->checksum . '/';
      $content_location .= $file_meta->filename . '.' . $file_meta->extension;

      header('Content-Type: ' . $mimetype);
      header('Content-Length: ' . $filesize);
      header('Content-Location: ' . $content_location);
      header('ETag: "' . MCNEESE_FILE_DB_PATH_BY_HASH_ALGORITHM . '://' . $file_meta->checksum . '"');
      header('Accept-Ranges: bytes');
      header('Last-Modified: ' . date('r', strtotime($file_meta->timestamp)));
      header('Expires: ' . date('r', strtotime('+14 days', REQUEST_TIME)));
      header('Date: ' . date('r', REQUEST_TIME));

      // allow image and text files to be viewed in place instead of downloaded.
      if (strncmp('image/', $mimetype, 6) != 0 && strncmp('text/', $mimetype, 6) != 0) {
        header('Content-Transfer-Encoding: binary');
        header('Content-Disposition: attachment; filename="' . $filename . '"');
        header('Content-Description: File Transfer');
      }

      // ETag cache optimization and other http header responses.
      if ($not_modified) {
        header('HTTP/1.1 304 Not Modified', TRUE, 304);
        exit();
      }

      // TODO: if the filesize is known, turn off the timeout and user a counter below?
      #@set_time_limit(0);

      $in = fopen($filepath, 'rb');

      stream_set_read_buffer($in, MCNEESE_FILE_DB_BLOCK_SIZE);

      // from php-5.4, this sets the actual read_bvuffer_size, unlike phps stream_set_read_buffer.
      if (function_exists('stream_set_chunk_size')) {
        stream_set_chunk_size($in, MCNEESE_FILE_DB_BLOCK_SIZE);
      }

      $count = 0;
      while (!feof($in)) {
        fpassthru($in);
      }

      fclose($in);
      exit();
    }
    else if ($by == MCNEESE_FILE_DB_PATH_BY_HASH_SUM) {
      if (ob_get_level()) {
        ob_end_clean();
        ob_end_flush();
      }

      $content_location = '/' . MCNEESE_FILE_DB_FILE_PATH . '/' . MCNEESE_FILE_DB_PATH_BY_HASH_SUM;
      $content_location .= '/' . $file_meta->checksum . '/';
      $content_location .= $file_meta->filename . '.' . $file_meta->extension;
      $content_location .= '.' . MCNEESE_FILE_DB_PATH_BY_HASH_SUM_EXTENSION;

      $data = $file_meta->checksum . '  ' . $filename;

      header('Content-Type: text/plain');
      header('Content-Length: ' . strlen($data));
      header('Content-Transfer-Encoding: binary');
      header('Content-Disposition: attachment; filename="' . $filename . '.' . MCNEESE_FILE_DB_PATH_BY_HASH_SUM_EXTENSION . '"');
      header('Content-Description: File Transfer');
      header('Content-Location: ' . $content_location);
      header('Last-Modified: ' . date('r', strtotime($file_meta->timestamp)));
      header('Expires: ' . date('r', strtotime('+14 days', REQUEST_TIME)));
      header('Date: ' . date('r', REQUEST_TIME));

      print($data);
    }

    exit();
  }

  return FALSE;
}

/**
 * Manually register known stream wrappers.
 */
function mcneese_file_db_register_stream_wrappers() {
  stream_wrapper_register('public', 'DrupalPublicStreamWrapper');
  stream_wrapper_register('temporary', 'DrupalTemporaryStreamWrapper');

  if (variable_get('file_private_path', FALSE)) {
    stream_wrapper_register('private', 'DrupalPrivateStreamWrapper');
  }

  stream_wrapper_register(mcneese_file_db_unrestricted_stream_wrapper::SCHEME, 'mcneese_file_db_unrestricted_stream_wrapper');
  //stream_wrapper_register(mcneese_file_db_restricted_stream_wrapper::SCHEME, 'mcneese_file_db_restricted_stream_wrapper');
}

/**
 * Manually process and return a binary file.
 *
 * This _must_ be called from index.php before DRUPAL_BOOTSTRAP_FULL.
 * This will hand-off to drupal on access denied or file not found.
 *
 * @param array $arguments
 *   An array of url arguments used to load a given page.
 */
function mcneese_file_db_return_file($arguments) {
  $by = '';
  $arg1 = '';
  $arg2 = '';
  $arg3 = '';

  if (isset($arguments[1])) {
    $by = $arguments[1];
  }
  if (isset($arguments[2])) {
    $arg1 = $arguments[2];
  }
  if (isset($arguments[3])) {
    $arg2 = $arguments[3];
  }
  if (isset($arguments[4])) {
    $arg3 = $arguments[4];
  }


  mcneese_file_db_register_stream_wrappers();

  $status = mcneese_file_db_load_file($by, $arg1, $arg2, $arg3);

  // this point is only reached if the file was not found.
  drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);

  if ($status) {
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
}

/**
 * Creates the appropriate image file and prints it.
 *
 * @param array $arguments
 *   An array of the url arguments for this request.
 */
function mcneese_file_db_generate_image_style($arguments) {
  if ($arguments[3] == mcneese_file_db_unrestricted_stream_wrapper::SCHEME) {
    $wrapper = new mcneese_file_db_unrestricted_stream_wrapper();
  }
  // @fixme: currently not implemented.
  //else if ($arguments[3] == mcneese_file_db_restricted_stream_wrapper::SCHEME) {
  //  $wrapper = new mcneese_file_db_restricted_stream_wrapper();
  //}
  else {
    drupal_not_found();
    drupal_exit();
  }

  array_shift($arguments);
  $image_source_uri = $arguments[2] . '://' . implode('/', $arguments);

  $file_uri = $wrapper->getTarget($image_source_uri);

  mcneese_file_db_print_image_style($file_uri);
}

/**
 * Prunts the appropriate image file.
 *
 * @param string $file_uri
 *   The image uri of the image to print.
 */
function mcneese_file_db_print_image_style($file_uri) {
  if (file_exists($file_uri)) {
    if (ob_get_level()) {
      ob_end_clean();
      ob_end_flush();
    }

    $filesize = filesize($file_uri);
    //$checksum = shasum($file_uri);

    include_once DRUPAL_ROOT . '/includes/file.mimetypes.inc';
    $mapping = file_mimetype_mapping();
    $mimetype = file_get_mimetype($file_uri, $mapping);

    // prevent devel_shutdown from being called.
    $GLOBALS['devel_shutdown'] = FALSE;

    header('Content-Type: ' . $mimetype);
    header('Content-Length: ' . $filesize);
    //header('ETag: "'' . MCNEESE_FILE_DB_PATH_BY_HASH_ALGORITHM . '://' . $checksum . '"');
    header('Accept-Ranges: bytes');

    readfile($file_uri);
    exit();
  }

  drupal_not_found();
  drupal_exit();
}

/**
 * Implements hook_file_validate().
 */
function mcneese_file_db_file_validate($file) {
  $errors = array();

  if (!file_exists($file->uri)) {
    $errors[] = t("The file was not found at: '%uri'", array('%uri' => $file->uri));
    return $errors;
  }

  $outer_parts = explode('://', $file->destination, 2);

  if ($outer_parts[0] != mcneese_file_db_unrestricted_stream_wrapper::SCHEME) {
    // @todo: add check for restricted scheme as well
    return $errors;
  }

  $checksum = hash_file(MCNEESE_FILE_DB_PATH_BY_HASH_ALGORITHM, $file->uri);
  $shortsum = substr($checksum, 0, MCNEESE_FILE_DB_SHORT_SUM_SIZE);

  $file->destination = $outer_parts[0] . '://' . MCNEESE_FILE_DB_PATH_BY_HASH . '/' . $shortsum;

  if (empty($file->filename)) {
    $file->destination .= '/file';
  }
  else {
    $file->destination .= '/' . $file->filename;
  }

  $loaded = (array) mcneese_file_db_load_available_files(array('checksum' => $checksum));

  if (empty($loaded)) return $errors;


  // If the file is not in the file_managed database table, then it must be added.
  $look_for = $outer_parts[0] . '://' . MCNEESE_FILE_DB_PATH_BY_HASH . '/' . $shortsum;

  $query = db_select('file_managed', 'fm');
  $query->fields('fm');
  $query->condition('fm.uri', db_like($look_for) . '%', 'LIKE');

  $found = (array) $query->execute()->fetchAll();

  if (empty($found)) return $errors;


  $errors[] = t("The file already exists.");
  return $errors;
}

/**
 * @} End of '@defgroup mcneese_file_db McNeese File Database'.
 */
