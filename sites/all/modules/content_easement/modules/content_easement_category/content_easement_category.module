<?php

/**
 * Implements hook_help().
 */
function content_easement_category_help($path, $arg = NULL) {
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (cf_is_empty_or_non_string($function_history, 'path', $path)){
    return;
  }

  switch ($path) {
    case 'admin/structure/easement/categories':
      $help = "Content Easement Categories are groups of node types.";
      $help .= " Each of these categories has its own default set of permissions that will be applied to all node types in this category upon creation of that node type.";
      $help .= " Categories may be limited to individual groups of users.";
      $help .= " The categories presented here are the only categories you are allowed to access.";

      return "<p>" . t($help) . "</p>";
  }
}

/**
 * Implements hook_content_easement_permission_alter().
 */
function content_easement_category_content_easement_permission_alter(&$permissions) {
  $permissions['manage easement categories'] = array(
    'title' => t("Manage Easement Categories"),
    'description' => t("Specify whether or not easement categories may be managed by some user or role."),
  );

  $permissions['create catagoryless node types'] = array(
    'title' => t("Create Categoryless Node Types"),
    'description' => t("Specify whether or not some user or role may create node types that are not part of a category."),
  );
}

/**
 * Implements hook_content_easement_init_overlay_matches_alter().
 */
function content_easement_category_content_easement_init_overlay_matches_alter(&$parent_matches, &$child_matches) {
  $child_matches[] = '/categories/edit/.*';
}

/**
 * Implements hook_menu().
 */
function content_easement_category_menu() {
  $items = array();

  $items['admin/structure/easement/categories'] = array(
    'title' => "Content Easement Categories",
    'description' => "Provides management functionality for content easements categories, such as: create, edit, end delete.",
    'page callback' => 'content_easement_category_manage_overview',
    'access arguments' => array('manage easement categories')
  );

  $items['admin/structure/easement/categories/add'] = array(
    'title' => "Add Category",
    'description' => "Add a new content easement category",
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('content_easement_category_form'),
    'access arguments' => array('manage easement categories')
  );

  $items['admin/structure/easement/categories/edit/%'] = array(
    'title' => "Edit Category",
    'description' => "Edit an existing content easement category.",
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('content_easement_category_form', 5),
    'access arguments' => array('manage easement categories')
  );

  $items['admin/structure/easement/categories/delete/%'] = array(
    'title' => "Delete Category",
    'description' => "Delete an existing content easement category.",
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('content_easement_category_delete', 5),
    'access arguments' => array('manage easement categories')
  );

  return $items;
}

/**
 * Impliments hook_node_access().
 */
function content_easement_category_node_access($node, $op, $account){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (cf_is_empty_or_non_string($function_history, 'op', $op)){
    return NODE_ACCESS_IGNORE;
  }

  if (!is_object($account)){
    cf_error_invalid_object($function_history, 'account');
    return NODE_ACCESS_IGNORE;
  }

  if (is_string($node)){
    $query = content_easement_category_get_type_mappings(array('machine_name' => $node));
  }
  else if (is_object($node)) {
    if ($node->status == NODE_NOT_PUBLISHED) {
      return NODE_ACCESS_IGNORE;
    }

    $query = content_easement_category_get_type_mappings(array('machine_name' => $node->type));
  }
  else {
    cf_error_invalid_variable(__FUNCTION__, 'node', 'Not a valid object or a valid string', array(), WATCHDOG_WARNING);
    return NODE_ACCESS_IGNORE;
  }

  // @todo: this is not the best way to do this, but it is the quickest; come up with a better solution than depending on just 1 group
  if (is_object($query)){
    $node_type_category_object = $query->execute()->fetchObject();

    if (is_object($node_type_category_object)){
      $exclusive_crud = cf_convert_from_crud($node_type_category_object->node_exclusive_crud, $function_history);

      if ($account->uid == 0){
        if (is_array($node) && $node->status == NODE_NOT_PUBLISHED) return NODE_ACCESS_IGNORE;

        $anonymous_crud = cf_convert_from_crud($node_type_category_object->node_anonymous_crud, $function_history);

        if (is_array($anonymous_crud)){
          if ($op == 'view' &&$anonymous_crud['read']) return NODE_ACCESS_ALLOW;
          else if ($anonymous_crud[$op]) return NODE_ACCESS_ALLOW;
        }

        if (is_array($exclusive_crud)){
          if ($op == 'view' && $exclusive_crud['read']) return NODE_ACCESS_DENY;
          else if ($exclusive_crud[$op]) return NODE_ACCESS_DENY;
        }
      }
      else {
        $roles = cf_user_get_rids($account->uid, $function_history);

        $roles_object = $roles->execute()->fetchAll();

        if (is_array($roles_object)){
          if ($op == 'create'){
            $role_id = $node_type_category_object->node_create_id;
          }
          else if ($op == 'view'){
            if ($node->status == NODE_NOT_PUBLISHED){
              $role_id = $node_type_category_object->node_view_unpublished_id;
            }
            else {
              $role_id = $node_type_category_object->node_read_id;
            }
          }
          else if ($op == 'update'){
            $role_id = $node_type_category_object->node_update_id;
          }
          else if ($op == 'delete'){
            $role_id = $node_type_category_object->node_delete_id;
          }
          else {
            return NODE_ACCESS_IGNORE;
          }

          if (cf_user_has_role($role_id, $account->uid, $function_history)){
            return NODE_ACCESS_ALLOW;
          }
          else {
            if ($op == 'view' && $exclusive_crud['read']) return NODE_ACCESS_DENY;
            else if ($exclusive_crud[$op]) return NODE_ACCESS_DENY;
          }
        }
      }
    }
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Used to load a category data by the category name, regardless of ones access permissions.
 */
function content_easement_category_load($machine_name) {
  if (!is_string($machine_name) || empty($machine_name)){
    return FALSE;
  }

  $results = db_query('SELECT * FROM {content_easement_categories} WHERE machine_name = :machine_name', array(':machine_name' => $machine_name))->fetchObject();

  return $results;
}

/**
 * Displays the easement content category manage page.
 */
function content_easement_category_manage_overview() {
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $category_types_object = content_easement_category_get_categories(array('mode' => 'manager'), NULL, $function_history);
  $easement_types = array();

  if (is_object($category_types_object)){
    $easement_types = $category_types_object->execute()->fetchAll();
  }

  $header = array(t("Name"), array('data' => t("Operations"), 'colspan' => '2'));
  $rows = array();

  foreach ($easement_types as $key => $value) {
    $row = array(check_plain($value->human_name) . " <small>(Machine name: " . check_plain($value->machine_name) . ")</small>");

    $row[] = array('data' => l(t("edit"), 'admin/structure/easement/categories/edit/' . check_plain($value->machine_name)) . ' ' . l(t("delete"), 'admin/structure/easement/categories/delete/' . check_plain($value->machine_name)));

    $rows[] = $row;
  }

  $build['content_easement_category_table'] = array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
    '#empty' => t("No content easement categories available. <a href='@link'>Add content easement category</a>.", array('@link' => url('admin/structure/easement/categories/add'))),
  );

  return $build;
}

/**
 * Returns a query object of possible categories.
 * This auto-limits the returned types based on whether or not a user/role has access to a given category.
 * This does not call ->execute() on the query object.
 *
 * $parameters is an array with the following possible keys:
 *   'mode' can be either 'create', 'read', 'update', 'delete', or 'manager' and defaults to 'read'
 *   'machine_name' get the category with this machine name
 *   'id' get the category with this id
 *
 * $account is the user account to base permissions off of, defaults to current user.
 */
function content_easement_category_get_categories(array $parameters = array(), $account = NULL, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  if (is_object($account)){
    $target_user = $account;
  }
  else {
    $target_user = cf_get_user(FALSE, $function_history);
  }

  $query = db_select('content_easement_categories', 'cec');

  $query->fields('cec');
  $query->orderBy('machine_name', 'ASC');

  $and = NULL;

  if (array_key_exists('id', $parameters)){
    if (!is_numeric($parameters['id'])){
      cf_error_not_numeric($function_history, 'id');
      return FALSE;
    }

    if (is_null($and)) $and = db_and();

    $and->condition('id', $parameters['id'], '=');
  }

  if (array_key_exists('machine_name', $parameters)){
    if (!preg_match('/^(\w|\d|_)+$/', $parameters['machine_name']) || strcmp(strtolower($parameters['machine_name']), $parameters['machine_name']) != 0){
      cf_error_invalid_variable($function_history, 'machine_name', "'%value' contains invalid and/or unsafe characters.", array('%value' => $parameters['machine_name']));
      return FALSE;
    }

    if (is_null($and)) $and = db_and();

    $and->condition('machine_name', $parameters['machine_name'], '=');
  }

  $mode_id = 'read';
  $is_not_manager = TRUE;

  if (array_key_exists('mode', $parameters)){
    if ($parameters['mode'] == 'create' || $parameters['mode'] == 'update' || $parameters['mode'] == 'delete'){
      $mode_id = $parameters['mode'];
    }

    if ($parameters['mode'] == 'manager'){
      if (user_access('manage easement categories', $target_user)){
        $is_not_manager = FALSE;
      }
    }
  }

  if ($is_not_manager){
    $query->innerjoin('role', 'r', 'cec.' . $mode_id . '_id = r.rid');
    $query->innerjoin('users_roles', 'ur', 'r.rid = ur.rid');

    if (is_null($and)) $and = db_and();

    $and->condition('ur.uid', $target_user->uid, '=');

    if (is_object($and)){
      $query->condition($and);
    }
    else {
      // TODO: produce an error here as the $and should be a valid object
      return FALSE;
    }
  }

  return $query;
}

/**
 * Returns a query object of possible categories mappings.
 * This does not call ->execute() on the query object
 *
 * $parameters is an array with the following possible keys:
 *   'machine_name' get the category with this machine name
 *   'type_id' get the type with this id
 *   'category_id' get the category with this id
 */
function content_easement_category_get_type_mappings(array $parameters = array(), array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  $query = db_select('content_easement_categories_type_mappings', 'cectm');

  $query->innerjoin('content_easement_categories', 'cec', 'cectm.category_id = cec.id');
  $query->innerjoin('content_easement_types', 'cet', 'cectm.type_id = cet.id');
  $query->fields('cectm');
  $query->fields('cec');
  $query->fields('cet');
  $query->orderBy('cectm.category_id', 'ASC');
  $query->orderBy('cectm.type_id', 'ASC');

  $and = NULL;

  if (array_key_exists('machine_name', $parameters)){
    if (!is_string($parameters['machine_name'])){
      cf_error_not_string($function_history, 'machine_name');
      return FALSE;
    }

    if (is_null($and)) $and = db_and();

    $and->condition('cet.type', $parameters['machine_name'], '=');
  }

  if (array_key_exists('type_id', $parameters)){
    if (!is_numeric($parameters['type_id'])){
      cf_error_not_numeric($function_history, 'type_id');
      return FALSE;
    }

    if (is_null($and)) $and = db_and();

    $and->condition('cectm.type_id', $parameters['type_id'], '=');
  }

  if (array_key_exists('category_id', $parameters)){
    if (!is_numeric($parameters['category_id'])){
      cf_error_not_numeric($function_history, 'category_id');
      return FALSE;
    }

    if (is_null($and)) $and = db_and();

    $and->condition('cectm.category_id', $parameters['category_id'], '=');
  }

  if (is_object($and)) $query->condition($and);

  return $query;
}

/**
 * This is the same as content_easement_category_get_type_mappings() excepts it adds an additional check to see if the given user has appropriate permissions.
 * This does not call ->execute() on the query object
 *
 * $parameters is an array with the following possible keys:
 *   'mode' can be either 'create', 'read', 'update', 'delete', or 'manager' and defaults to 'read'
 *   'machine_name' get the category with this machine name
 *   'type_id' get the type with this id
 *   'category_id' get the category with this id
 *
 * $account is the user account to base permissions off of, defaults to current user.
 */
function content_easement_category_get_allowed_type_mappings($parameters = array(), $account = NULL, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  if (is_object($account)){
    $target_user = $account;
  }
  else {
    $target_user = cf_get_user(FALSE, $function_history);
  }

  $mode_id = 'read';
  $is_not_manager = TRUE;

  // ensure that 'read' is the default and enforce 'read' when any invalid mode is specified
  if (array_key_exists('mode', $parameters)){
    if ($parameters['mode'] == 'create' || $parameters['mode'] == 'update' || $parameters['mode'] == 'delete'){
      $mode_id = $parameters['mode'];
    }

    if ($parameters['mode'] == 'manager'){
      if (user_access('manage easement categories', $target_user)){
        $is_not_manager = FALSE;
      }
    }

    // ensure that the 'mode' parameter does not get passed to content_easement_category_get_type_mappings() because it is not supported there
    unset($parameters['mode']);
  }

  $query = content_easement_category_get_type_mappings($parameters, $function_history);

  if (!is_object($query)) return FALSE;

  $query->innerjoin('node_type', 'nt', 'cet.type = nt.type');
  $query->fields('nt');

  if ($is_not_manager){
    $query->innerjoin('role', 'r', 'cec.' . $mode_id . '_id = r.rid');
    $query->innerjoin('users_roles', 'ur', 'r.rid = ur.rid');

    $and = db_and();

    $and->condition('ur.uid', $target_user->uid, '=');

    if (is_object($and)){
      $query->condition($and);
    }
    else {
      // TODO: produce an error here as the $and should be a valid object
      return FALSE;
    }
  }

  return $query;
}

/**
 * Return a category object with every possible option category created and set to nothing.
 */
function content_easement_category_initialize_category(){
  $category = new stdClass();
  $category->id           = NULL;
  $category->human_name   = NULL;
  $category->machine_name = NULL;

  $category->create_id = NULL;
  $category->read_id   = NULL;
  $category->update_id = NULL;
  $category->delete_id = NULL;

  $category->node_create_id = NULL;
  $category->node_read_id   = NULL;
  $category->node_update_id = NULL;
  $category->node_delete_id = NULL;
  $category->node_view_unpublished_id = NULL;

  $category->node_anonymous_crud   = NULL;
  $category->node_anonymous_create = NULL;
  $category->node_anonymous_read   = NULL;
  $category->node_anonymous_update = NULL;
  $category->node_anonymous_delete = NULL;

  $category->node_exclusive_crud   = NULL;
  $category->node_exclusive_create = NULL;
  $category->node_exclusive_read   = NULL;
  $category->node_exclusive_update = NULL;
  $category->node_exclusive_delete = NULL;

  return $category;
}

/**
 * Menu callback for add form for an easement category
 */
function content_easement_category_form($form, &$form_state, $category = NULL){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $all_roles = user_roles(TRUE);
  $all_roles = array_map('drupal_ucfirst', $all_roles);
  asort($all_roles);

  // Authenticated Users role cannot be used because it does not get added to the users_roles database table
  unset($all_roles['2']);

  if (is_string($category)){
    $category_types_object = content_easement_category_get_categories(array('machine_name' => $category, 'mode' => 'update'), NULL, $function_history);
    $category = NULL;

    if (is_object($category_types_object)){
      $category = $category_types_object->execute()->fetchObject();
    }

    if (is_object($category)){
      $anonymous_array = cf_convert_from_crud($category->node_anonymous_crud, $function_history);
      $exclusive_array = cf_convert_from_crud($category->node_exclusive_crud, $function_history);

      $category->node_anonymous_create = $anonymous_array['create'];
      $category->node_anonymous_read   = $anonymous_array['read'];
      $category->node_anonymous_update = $anonymous_array['update'];
      $category->node_anonymous_delete = $anonymous_array['delete'];

      $category->node_exclusive_create = $exclusive_array['create'];
      $category->node_exclusive_read   = $exclusive_array['read'];
      $category->node_exclusive_update = $exclusive_array['update'];
      $category->node_exclusive_delete = $exclusive_array['delete'];
    }
  }

  if (!is_object($category)){
    $category = content_easement_category_initialize_category();
  }

  $form['description'] = array(
    '#type' => 'item',
    '#title' => t("Creating a new content easement category"),
    '#description' => t("Content easement category is a group in which users with appropriate permissions may add, update, or delete node types under that category.") . "<br>" .
                      t("A node type is a form that is presented to the user whereas a node is a filled out node type form."),
  );

  $form['id'] = array(
    '#type' => 'hidden',
    '#value'=> $category->id,
  );

  $form['human_name'] = array(
    '#type' => 'textfield',
    '#title' => t("Human Name"),
    '#required' => TRUE,
    '#description' => t("This is the user-friendly name presented to users who may view this category name."),
    '#size' => 40,
    '#maxlength' => 255,
    '#default_value' => $category->human_name,
  );

  $form['machine_name'] = array(
    '#type' => 'machine_name',
    '#title' => t("Machine Name"),
    '#required' => TRUE,
    '#description' => t("This is a short machine-friendly name that is automatically prepended to all node types created under this group. This name must be unique. This name can only containt lower-case characters, numbers, and underscores."),
    '#size' => 10,
    '#maxlength' => 10,
    '#default_value' => $category->machine_name,
    '#machine_name' => array(
      'exists' => 'content_easement_category_load',
      'source' => array('human_name'),
    ),
  );

  $form['additional_settings'] = array(
    '#type' => 'vertical_tabs',
  );

  $form['node_type_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t("Node Type Settings"),
    '#group' => 'additional_settings',
    '#collapsible' => FALSE,
    '#tree' => TRUE,
  );

  $form['node_type_settings']['create_id'] = array(
    '#type' => 'select',
    '#title' => t("Create ID"),
    '#required' => TRUE,
    '#description' => t("The id of the role that is authorized to create node types under this category."),
    '#options' => $all_roles,
    '#default_value' => $category->create_id,
  );

  $form['node_type_settings']['read_id'] = array(
    '#type' => 'select',
    '#title' => t("Read ID"),
    '#required' => TRUE,
    '#description' => t("The id of the role in that is authorized to read node types under this category."),
    '#options' => $all_roles,
    '#default_value' => $category->read_id,
  );

  $form['node_type_settings']['update_id'] = array(
    '#type' => 'select',
    '#title' => t("Update ID"),
    '#required' => TRUE,
    '#description' => t("The id of the role in that is authorized to update node types under this category."),
    '#options' => $all_roles,
    '#default_value' => $category->update_id,
  );

  $form['node_type_settings']['delete_id'] = array(
    '#type' => 'select',
    '#title' => t("Delete ID"),
    '#required' => TRUE,
    '#description' => t("The id of the role in that is authorized to delete node types under this category."),
    '#options' => $all_roles,
    '#default_value' => $category->delete_id,
  );

  $form['node_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t("Node Settings"),
    '#group' => 'additional_settings',
    '#collapsible' => FALSE,
    '#tree' => TRUE,
  );

  $form['node_settings']['node_create_id'] = array(
    '#type' => 'select',
    '#title' => t("Create ID"),
    '#required' => TRUE,
    '#description' => t("The id of the role in that is authorized to create nodes under this category.") . "<br>\n" .
                      t("Set to '-None-' to not explicitly set/enforce this."),
    '#options' => array(0 => '-None-') + $all_roles,
    '#default_value' => $category->node_create_id,
  );

  $form['node_settings']['node_read_id'] = array(
    '#type' => 'select',
    '#title' => t("Read ID"),
    '#required' => TRUE,
    '#description' => t("The id of the role in that is authorized to read nodes under this category.") . "<br>\n" .
                      t("Set to '-None-' to not explicitly set/enforce this."),
    '#options' => array(0 => '-None-') + $all_roles,
    '#default_value' => $category->node_read_id,
  );

  $form['node_settings']['node_update_id'] = array(
    '#type' => 'select',
    '#title' => t("Update ID"),
    '#required' => TRUE,
    '#description' => t("The id of the role in that is authorized to update nodes under this category.") . "<br>\n" .
                      t("Set to '-None-' to not explicitly set/enforce this."),
    '#options' => array(0 => '-None-') + $all_roles,
    '#default_value' => $category->node_update_id,
  );

  $form['node_settings']['node_delete_id'] = array(
    '#type' => 'select',
    '#title' => t("Delete ID"),
    '#required' => TRUE,
    '#description' => t("The id of the role in that is authorized to delete nodes under this category.") . "<br>\n" .
                      t("Set to '-None-' to not explicitly set/enforce this."),
    '#options' => array(0 => '-None-') + $all_roles,
    '#default_value' => $category->node_delete_id,
  );

  $form['node_settings']['node_view_unpublished_id'] = array(
    '#type' => 'select',
    '#title' => t("View Unpublished ID"),
    '#required' => TRUE,
    '#description' => t("The id of the role that is authorized to view unpublished nodes under this category.") . "<br>\n" .
                      t("Set to '-None-' to not explicitly set/enforce this."),
    '#options' => array(0 => '-None-') + $all_roles,
    '#default_value' => $category->node_view_unpublished_id,
  );

  $form['node_settings']['node_anonymous_create'] = array(
    '#type' => 'checkbox',
    '#title' => t("Anonymous Can Create"),
    '#required' => FALSE,
    '#options' => array(0 => t("Deny Create"), 1 => t("Allow Create")),
    '#default_value' => $category->node_anonymous_create,
  );

  $form['node_settings']['node_anonymous_read'] = array(
    '#type' => 'checkbox',
    '#title' => t("Anonymous Can Read"),
    '#required' => FALSE,
    '#options' => array(0 => t("Deny Read"), 1 => t("Allow Read")),
    '#default_value' => $category->node_anonymous_read,
  );

  $form['node_settings']['node_anonymous_update'] = array(
    '#type' => 'checkbox',
    '#title' => t("Anonymous Can Update"),
    '#required' => FALSE,
    '#options' => array(0 => t("Deny Update"), 1 => t("Allow Update")),
    '#default_value' => $category->node_anonymous_update,
  );

  $form['node_settings']['node_anonymous_delete'] = array(
    '#type' => 'checkbox',
    '#title' => t("Anonymous Can Delete"),
    '#required' => FALSE,
    '#options' => array(0 => t("Deny Delete"), 1 => t("Allow Delete")),
    '#default_value' => $category->node_anonymous_delete,
  );

  $form['node_settings']['node_anonymous_description'] = array(
    '#type' => 'item',
    '#description' => t("Specify whether or not anonymous may create, view, update, or delete node types under this category."),
  );

  $form['node_settings']['node_exclusive_create'] = array(
    '#type' => 'checkbox',
    '#title' => t("Exclusive Create Permissions"),
    '#required' => FALSE,
    '#options' => array(0 => t("Deny Create"), 1 => t("Allow Create")),
    '#default_value' => $category->node_exclusive_create,
  );

  $form['node_settings']['node_exclusive_read'] = array(
    '#type' => 'checkbox',
    '#title' => t("Exclusive Read Permissions"),
    '#required' => FALSE,
    '#options' => array(0 => t("Deny Read"), 1 => t("Allow Read")),
    '#default_value' => $category->node_exclusive_read,
  );

  $form['node_settings']['node_exclusive_update'] = array(
    '#type' => 'checkbox',
    '#title' => t("Exclusive Update Permissions"),
    '#required' => FALSE,
    '#options' => array(0 => t("Deny Update"), 1 => t("Allow Update")),
    '#default_value' => $category->node_exclusive_update,
  );

  $form['node_settings']['node_exclusive_delete'] = array(
    '#type' => 'checkbox',
    '#title' => t("Exclusive Delete Permissions"),
    '#required' => FALSE,
    '#options' => array(0 => t("Deny Delete"), 1 => t("Allow Delete")),
    '#default_value' => $category->node_exclusive_delete,
  );

  $form['node_settings']['node_exclusive_description'] = array(
    '#type' => 'item',
    '#description' => t("Exclusive mode means that if a given user is not explicitly in this allow list, then access will be denied despite what any other access control on the system allows."),
  );

  $form['actions'] = array('#type' => 'actions');

  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t("Submit"),
    '#weight' => 40,
  );

  $form['actions']['cancel'] = array(
    '#type' => 'link',
    '#title' => t("Cancel"),
    '#href' => 'admin/structure/easement/categories',
    '#options' => isset($_GET['destination']) ? drupal_parse_url(urldecode($_GET['destination'])) : array('path' => 'admin/structure/easement/categories'),
    '#weight' => 100,
  );

  $form['#validate'] = array('content_easement_category_form_validate');
  $form['#submit']   = array('content_easement_category_form_submit');

  return $form;
}

/**
 * validate add form for an easement category
 */
function content_easement_category_form_validate($form, &$form_state){
  if (!preg_match('/^(\w|\d|_)+$/', $form_state['values']['machine_name']) || strcmp(strtolower($form_state['values']['machine_name']), $form_state['values']['machine_name']) != 0){
    form_set_error('machine_name', t("Machine name can only contain lower-case characters, numbers, and underscores. All other characters are not allowed."));
  }
  else {
    // only check if machine name already exists if the node doesn't exist or if the form_state machine name is different from the form machine name.
    if (is_null($form['id']['#value']) || $form['machine_name']['#default_value'] != $form_state['values']['machine_name']){
      $results = db_query('SELECT machine_name from {content_easement_categories} WHERE machine_name = :machine_name', array(':machine_name' => $form_state['values']['machine_name']));

      if ($results->rowCount() > 0){
        form_set_error('machine_name', t("The machine name '%machine_name' already exists and machine names must be unique.", array('%machine_name' => $form_state['values']['machine_name'])));
      }
    }
  }
}

/**
 * submit add form for an easement category
 */
function content_easement_category_form_submit($form, &$form_state){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $data = array();
  $columns = array('human_name', 'machine_name');
  $node_type_settings_columns = array('create_id', 'read_id', 'update_id', 'delete_id');
  $node_settings_columns = array('node_create_id', 'node_read_id', 'node_update_id', 'node_delete_id', 'node_view_unpublished_id');
  $primary_key = array();
  $is_new = is_null($form['id']['#value']);

  foreach ($columns as $column){
    $data[$column] = $form_state['values'][$column];
  }

  if (is_array($form_state['values']['node_type_settings'])){
    foreach ($node_type_settings_columns as $column){
      $data[$column] = $form_state['values']['node_type_settings'][$column];
    }
  }

  if (is_array($form_state['values']['node_settings'])){
    foreach ($node_settings_columns as $column){
      $data[$column] = $form_state['values']['node_settings'][$column];
    }

    $data['node_anonymous_crud'] = cf_convert_to_crud($form_state['values']['node_settings']['node_anonymous_create'] == 1, $form_state['values']['node_settings']['node_anonymous_read'] == 1, $form_state['values']['node_settings']['node_anonymous_update'] == 1, $form_state['values']['node_settings']['node_anonymous_delete'] == 1);
    $data['node_exclusive_crud'] = cf_convert_to_crud($form_state['values']['node_settings']['node_exclusive_create'] == 1, $form_state['values']['node_settings']['node_exclusive_read'] == 1, $form_state['values']['node_settings']['node_exclusive_update'] == 1, $form_state['values']['node_settings']['node_exclusive_delete'] == 1);
  }

  if (!$is_new){
    $primary_key[] = 'id';
    $data['id']    = $form['id']['#value'];
  }

  $result = drupal_write_record('content_easement_categories', $data, $primary_key);

  if ($result){
    if ($is_new){
      $message = t("The new content easement category has been created.");
    }
    else {
      $message = t("The existing content easement category has been updated.");
    }
    $message_type = 'status';
  }
  else {
    if ($is_new){
      $message = t("Failed to create the new content easement category.");
    }
    else {
      $message = t("Failed to update the existing content easement category.");
    }
    $message_type = 'error';
  }

  $form_state['redirect'] = 'admin/structure/easement/categories';

  drupal_set_message($message, $message_type);
  drupal_redirect_form($form_state);
}

/**
 * Menu callback for delete form for an easement category
 */
function content_easement_category_delete($form, &$form_state, $machine_name){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  // the $machine_name parameter is passed via the url and therefore is untrusted; validate $machine_name
  if (empty($machine_name) || !preg_match('/^(\w|\d|_)+$/', $machine_name) || strcmp(strtolower($machine_name), $machine_name) != 0){
    return array();
  }

  $category_types_object = content_easement_category_get_categories(array('machine_name' => $machine_name, 'mode' => 'delete'), NULL, $function_history);
  $found_types = array();

  if (is_object($category_types_object)){
    $found_types = $category_types_object->execute()->fetchAll();
  }

  $category = NULL;

  foreach ($found_types as $key => $value){
    if ($value->machine_name == $machine_name){
      $category = $value;
      break;
    }
  }

  if ($category === NULL){
    return array();
  }

  $form['content_easement'] = array(
    '#type' => 'hidden',
  );

  $form['content_easement']['id'] = array(
    '#type' => 'hidden',
    '#value' => $category->id,
  );

  $form['#submit'] = array('content_easement_category_delete_submit');

  return confirm_form(
    $form,
    t("Are you sure you want to delete %human_name?", array('%human_name' => $category->human_name)) . " <small>" . t("(Machine name: %machine_name)", array('%machine_name' => $machine_name)) . "</small>",
    'admin/structure/easement/categories',
    t("This action cannot be undone."),
    t("Delete"),
    t("Cancel")
  );
}

/**
 * submit delete form for an easement category
 */
function content_easement_category_delete_submit($form, &$form_state){
  $result = db_delete('content_easement_categories')->condition('id', $form['content_easement']['id']['#value'])->execute();

  if ($result){
    $message = t("The content easement category has been deleted.");
    $message_type = 'status';
  }
  else {
    $message = t("Failed to delete the content easement category.");
    $message_type = 'error';
  }

  $form_state['redirect'] = 'admin/structure/easement/categories';

  drupal_set_message($message, $message_type);
  drupal_redirect_form($form_state);
}

/**
 * Implements hook_content_easement_types_form_alter().
 */
function content_easement_category_content_easement_types_form_alter(&$form, &$form_state, $type_data){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $category_types_object  = content_easement_category_get_categories(array('mode' => 'create'), NULL, $function_history);
  $category_types_array   = array();
  $category_types_options = array();

  if (is_object($category_types_object)){
    $category_types_array = $category_types_object->execute()->fetchAll();
  }

  foreach ($category_types_array as $key => $value){
    // WORKAROUND: recent webbrowser like firefox and chrome will reset all numeric values to their own numbering system
    //             this will completely break the numbers that are defined here
    //             to prevent this the numbering system is wrapped with the prefix of 'id=' to prevent webbrowsers from breaking anything
    //             the downside is that the number will now have to be extracted from the string each time it is needed
    $category_types_options['id=' . $value->id] = $value->human_name;
  }

  $create_any_node_type = user_access('create catagoryless node types');

  $form['content_easement']['category_id'] = array(
    '#type' => 'select',
    '#title' => t("Node Type Category"),
    '#required' => !$create_any_node_type,
    '#description' => t("The category that this node type belongs under." . "<br>\n" .
                      t("This is a list of all categories in which you are authorized to create content types under and does not necessarily represent all available categories.")),
    '#options' => $category_types_options,
    '#default_value' => '',
  );

  if ($create_any_node_type){
    $form['content_easement']['category_id']['#options'] = array_merge(array('-' => 'No Category'), $form['content_easement']['category_id']['#options']);
  }

  if ($type_data['new']){
    $unique_part = preg_replace('/\./', '', REQUEST_TIME);
    $form['type']['#default_value'] = $unique_part;
  } else {
    $query = content_easement_category_get_type_mappings(array('type_id' => $type_data['id']), $function_history);

    if (is_object($query)){
      $node_type_category_object = $query->execute()->fetchObject();

      if (is_object($node_type_category_object)){
        $form['content_easement']['category_id']['#default_value'] = 'id=' . $node_type_category_object->category_id;
      }
    }
  }

  $form['type']['#type']  = 'hidden';
  $form['type']['#value'] = $form['type']['#default_value'];
}

/**
 * validate add form for an easement category
 */
function content_easement_category_content_easement_types_validate_alter($form, &$form_state, $type_data){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $category_id = preg_replace('@^id=@', '', $form_state['values']['category_id']);

  if (is_numeric($category_id)){
    $category_types_object = content_easement_category_get_categories(array('id' => $category_id, 'mode' => 'create'), NULL, $function_history);

    if (is_object($category_types_object)){
      $category = $category_types_object->execute()->fetchObject();

      if (is_object($category)){
        $type_value = preg_replace('/\./', '', REQUEST_TIME);

        if ($type_data['new']){
          $type_value = $form['type']['#default_value'];
        }

        if (preg_match('@^' . $category->machine_name . '_\d+$@', $form_state['values']['type']) == 0){
          $form_state['values']['type'] = $category->machine_name . '_' . $type_value;
        }
      }
    }
  }
  else {
    $form_state['values']['type'] = '_' . preg_replace('/\./', '', REQUEST_TIME);
  }
}

/**
 * validate add form for an easement category
 */
function content_easement_category_content_easement_types_submit_alter($form, &$form_state, $type_data){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $data = array();
  $primary_key = 'type_id';
  $data['type_id']     = $form['content_easement']['id']['#value'];
  $data['category_id'] = preg_replace('@^id=@', '', $form['content_easement']['category_id']['#value']);
  $old_category_id     = preg_replace('@^id=@', '', $form['content_easement']['category_id']['#default_value']);

  if ($type_data['new']){
    $data['type_id'] = NULL;
    $result = db_query('SELECT id FROM {content_easement_types} WHERE type = :type', array(':type' => $form_state['values']['type']));

    if ($result){
      foreach($result as $record){
        $data['type_id'] = $record->id;
        break;
      }
    }

    if (is_null($data['type_id'])){
      watchdog('error', "Failed to write to database 'content_easement_categories_type_mappings', unable to obtain a valid type_id for the type: %type", array('%type' => $form_state['values']['type']), WATCHDOG_ERROR);
      return;
    }
  }
  // if nothing has changed, then do nothing in the database
  else if ($old_category_id == $data['category_id']){
    return;
  }

  if (is_numeric($data['category_id'])){
    if ($type_data['new'] || !is_numeric($old_category_id)){
      $result = drupal_write_record('content_easement_categories_type_mappings', $data);
    }
    else {
      $result = drupal_write_record('content_easement_categories_type_mappings', $data, $primary_key);
    }
  }
  else if (!$type_data['new']) {
    $result = db_delete('content_easement_categories_type_mappings')->condition('type_id', $data['type_id'])->execute();
  }
  else {
    return;
  }

  if (!$result){
    watchdog('error', "Failed to write to database 'content_easement_categories_type_mappings' with data = '%data' and primary_key = '%primary_key'", array('%data' => print_r($data, TRUE), '%primary_key' => print_r($primary_key, TRUE)), WATCHDOG_ERROR);
  }
}

/**
 * Delete type mappings for deleted node types.
 */
function content_easement_category_content_easement_node_type_delete_alter($info, $type_data){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_object($info)){
    cf_error_invalid_object($function_history, 'info');
    return;
  }

  if (!is_array($type_data)){
    cf_error_invalid_array($function_history, 'type_data');
    return;
  }

  $result = db_delete('content_easement_categories_type_mappings')
    ->condition('type_id', $type_data['id'])
    ->execute();
}
