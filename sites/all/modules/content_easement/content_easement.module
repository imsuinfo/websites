<?php

/**
 * Implements hook_init().
 */
function content_easement_init() {
  $mode = overlay_get_mode();
  $user = cf_get_user(FALSE, array(__FUNCTION__));

  $use_overlay = (isset($user->data['overlay']) && $user->data['overlay']);

  if (empty($mode) && isset($_GET['q']) && user_access('access easement overlay') && $use_overlay) {
    if (preg_match('@^admin/structure/easement/types@', $_GET['q']) > 0){
      $current_path = current_path();

      // After overlay is enabled on the page, redirect to admin/structure/easement/types#overlay=some_path to actually enable the overlay.
      if (isset($_SESSION['overlay_enable_redirect']) && $_SESSION['overlay_enable_redirect']) {
        unset($_SESSION['overlay_enable_redirect']);
        drupal_goto('admin/structure/easement/types', array('fragment' => 'overlay=' . $current_path));
      }

      // allow other modules to specify which paths should be parents or children
      $parent_matches = array();
      $child_matches  = array('/add');

      drupal_alter('content_easement_init_overlay_matches', $parent_matches, $child_matches);

      // instead of doing multiple preg_matches, do a single match with a computed preg string
      $parent_match_string = '@^admin/structure/easement/types';
      $child_match_string  = '@^admin/structure/easement/types';

      if (count($parent_matches) > 0){
        $parent_match_string .= '(';

        foreach($parent_matches as $key => $value){
          $parent_match_string .= '|' . $value;
        }

        $parent_match_string .= ')';
      }

      if (count($child_matches) > 0){
        $child_match_string .= '(';

        foreach($child_matches as $key => $value){
          $child_match_string .= '|' . $value;
        }

        $child_match_string .= ')';
      }

      $parent_match_string .= '$@';
      $child_match_string  .= '$@';

      if (preg_match($parent_match_string, $_GET['q']) > 0){
        overlay_set_mode('parent');
      } else if (preg_match($child_match_string, $_GET['q']) > 0){
        if (isset($_GET['render']) && $_GET['render'] == 'overlay') {
          // If this page shouldn't be rendered here, redirect to the parent.
          if (!path_is_admin($current_path)) {
            overlay_close_dialog($current_path);
          }

          overlay_set_mode('child');

          // Unset the render parameter to avoid it being included in URLs on the page.
          unset($_GET['render']);
        }
      }
      // default to parent
      else {
        overlay_set_mode('parent');
      }
    }
  }
}

/**
 * Implements hook_exit().
 */
function content_easement_exit() {
  overlay_exit();
}

/**
 * Implements hook_permission().
 */
function content_easement_permission() {
  $permissions = array();

  $permissions['manage easement node types'] = array(
    'title' => t("Manage Easement Node Types"),
    'description' => t("This is similar to 'Administer content types'. This is safer than 'Administer content types' but also provides less functionality. This gives users the ability to manage content easement node types but not any other node type."),
  );

  $permissions['access easement overlay'] = array(
    'title' => t("Access Easement Overlay"),
    'description' => t("View easement pages in the overlay."),
  );

  // normally other modules can implement their own hook_permission
  // however, in order to help improve organization of the permission page, this hook is provided so that all sub-modules may have their permissions appear under the parent group
  drupal_alter('content_easement_permission', $permissions);

  return $permissions;
}

/**
 * Implements hook_menu().
 */
function content_easement_menu() {
  $items = array();

  $items['admin/structure/easement'] = array(
    'title' => "Content Easement",
    'description' => "Content easement provides a somewhat less complicated and more automated way than that of the drupal core node type management pages.",
    'page callback' => 'content_easement_manage_menu_page',
    'file' => 'menu.inc',
    'file path' => drupal_get_path('module', 'content_easement') . '/includes',
    'access callback' => 'content_easement_access',
    'access arguments' => array(),
  );

  // There are a few reasons why these menus are added here
  // - drupal core does not allow 'access arguments' to have multiple permissions
  // - not all drupal pages can be altered, nameley 'node_overview_types'
  // - many of the pages need special permissions applied, but no hooks are available in the node type
  // The end result is that I am forced to re-implement and re-cycled code in order to get proper access rights to make node type management easier and safer for non-admin (but still trusted) users
  $items['admin/structure/easement/types'] = array(
    'title' => "Manage Node Types",
    'description' => "Manage node types, including default status, fields, comment settings, etc.",
    'page callback' => 'content_easement_overview_types',
    'access callback' => 'content_easement_access',
    'access arguments' => array(),
    'file' => 'content_types.inc',
    'file path' => drupal_get_path('module', 'content_easement') . '/includes',
  );

  $items['admin/structure/easement/types/list'] = array(
    'title' => "List",
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/structure/easement/types/add'] = array(
    'title' => "Add Node Type",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_type_form'),
    'access callback' => 'content_easement_access',
    'access arguments' => array(),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'content_types.inc',
    'file path' => drupal_get_path('module', 'node'),
  );

  $items['admin/structure/easement/types/manage/%node_type'] = array(
    'title' => "Edit Node Type",
    'title callback' => 'node_type_page_title',
    'title arguments' => array(5),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_type_form', 5),
    'access callback' => 'content_easement_access',
    'access arguments' => array(5),
    'file' => 'content_types.inc',
    'file path' => drupal_get_path('module', 'node'),
  );

  $items['admin/structure/easement/types/manage/%node_type/edit'] = array(
    'title' => "Edit",
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/structure/easement/types/manage/%node_type/delete'] = array(
    'title' => "Delete",
    'page arguments' => array('node_type_delete_confirm', 5),
    'access callback' => 'content_easement_access',
    'access arguments' => array(5),
    'file' => 'content_types.inc',
    'file path' => drupal_get_path('module', 'node'),
  );

  return $items;
}

/**
 * Returns a query object meant to return all available easement node types
 * This does not call ->execute() on the query objct
 *
 * To add a test against the id, try: query->condition('id', $id, '=');
 * To add a test against the type, try: query->condition('type', strtolower($type), '=');
 */
function content_easement_get_types(array $function_history = array()) {
  $query = db_select('content_easement_types', 'cet');

  $query->innerjoin('node_type', 'nt', 'cet.type = nt.type');
  $query->fields('cet');
  $query->fields('nt');
  $query->orderBy('cet.type', 'ASC');

  return $query;
}

/**
 * Given a node type string, return the content easement type unique id if one exists.
 */
function content_easement_get_type_id($type) {
  if (cf_is_empty_or_non_string(__FUNCTION__, 'type', $type, WATCHDOG_ERROR)){
    return FALSE;
  }

  $record = db_query('SELECT id FROM {content_easement_types} WHERE type = :type', array(':type' => $type))->fetchObject();

  if ($record){
    return $record->id;
  }

  return FALSE;
}

/**
 * Implements hook_form_alter() for node_type_form.
 */
function content_easement_form_node_type_form_alter(&$form, &$form_state, $form_id) {
  if (!is_array($form)){
    cf_error_invalid_array(__FUNCTION__, 'form', WATCHDOG_ERROR);
    return;
  }

  if (cf_is_not_form_state(__FUNCTION__, 'form_state', $form_state, WATCHDOG_ERROR)){
    return;
  }

  $new_type = empty($form['#node_type']->type);

  // load the node type unique id if this is not a new form
  if ($new_type){
    $type_id = NULL;
  }
  else {
    $type_id = content_easement_get_type_id($form['#node_type']->type);
  }

  // do not add types created outside of content easement to the content easement database tables
  if ($type_id !== FALSE){
    content_easement_modify_node_type_form($form, $form_state, $form_id, $type_id);
  }
}

/**
 * Implements hook_form_alter() for node_type_delete_confirm.
 */
function content_easement_form_node_type_delete_confirm_alter(&$form, &$form_state, $form_id) {
  if (!isset($_GET['q']) || preg_match('@^admin/structure/easement/types(/.*)$@', $_GET['q']) == 0){
    return;
  }

  content_easement_field_ui_add_cancel_button($form, 'admin/structure/easement/types', 100, array(__FUNCTION__));

  // call our own custom submit function to ensure that the destination gets preserved
  $form['#submit'][] = 'content_easement_node_type_delete_confirm_submit';
}

/**
 * Ensure redirect after delete goes to the content easement path and not the content type path.
 */
function content_easement_node_type_delete_confirm_submit($form, &$form_state) {
  $form_state['redirect'] = 'admin/structure/easement/types';
}

/**
 * This is part of the content_easement_form_node_type_form_alter() function that focuses on:
 *  - adding a cancel button
 *  - adding content_easement_types_form_alter hooks
 *  - injecting a hidden type_id value
 */
function content_easement_modify_node_type_form(&$form, &$form_state, $form_id, $type_id){
  // only alter node type form when it is used from the content easement specific pages
  if (!isset($_GET['q']) || !preg_match('@^admin/structure/easement/types(/.*)$@', $_GET['q'])){
    return;
  }

  $form['content_easement'] = array(
    '#type' => 'fieldset',
    '#title' => t("Easement Settings"),
    '#group' => 'additional_settings',
    '#collapsible' => FALSE,
  );

  $form['content_easement']['id'] = array(
    '#type' => 'hidden',
    '#value' => $type_id,
  );

  $form['actions']['cancel'] = array(
    '#type' => 'link',
    '#title' => t("Cancel"),
    '#href' =>  'admin/structure/easement/types',
    '#weight' => 100,
  );

  if (isset($_GET['destination'])){
    $form['actions']['cancel']['#options'] = drupal_parse_url(urldecode($_GET['destination']));
  }

  $form['#submit'][]   = 'content_easement_types_submit';
  $form['#validate'][] = 'content_easement_types_validate';

  // protect the submit and validate functionality from alter functions
  $submit_array = $form['#submit'];
  $validate_array = $form['#validate'];

  $type_data = array('id' => $type_id, 'type' => $form['#node_type']->type, 'new' => ($type_id == NULL ? TRUE : FALSE));

  // allow other modules to make their own changes
  drupal_alter('content_easement_types_form', $form, $form_state, $type_data);

  $form['#submit'] = $submit_array;
  $form['#validate'] = $validate_array;
}

/**
 * validate add form for an easement category
 */
function content_easement_types_validate($form, &$form_state){
  if (!is_array($form)){
    cf_error_invalid_array(__FUNCTION__, 'form', WATCHDOG_ERROR);
    return;
  }

  if (cf_is_not_form_state(__FUNCTION__, 'form_state', $form_state, WATCHDOG_ERROR)){
    return;
  }

  $type_data = array('id' => $form['content_easement']['id']['#value'], 'type' => $form['#node_type']->type, 'new' => empty($form['#node_type']->type));

  // allow other modules to perform their own validations
  drupal_alter('content_easement_types_validate', $form, $form_state, $type_data);
}

/**
 * submit add form for an easement category
 */
function content_easement_types_submit($form, &$form_state){
  if (!is_array($form)){
    cf_error_invalid_array(__FUNCTION__, 'form', WATCHDOG_ERROR);
    return;
  }

  if (cf_is_not_form_state(__FUNCTION__, 'form_state', $form_state, WATCHDOG_ERROR)){
    return;
  }

  $data = array();
  $columns = array('type');
  $primary_key = array();
  $new_type = empty($form['#node_type']->type);

  foreach ($columns as $column){
    $data[$column] = $form_state['values'][$column];
  }

  // if this is not a new type, then get the unique id for this node type
  if (!$new_type){
    $primary_key[] = 'id';
    $data['id']    = $form['content_easement']['id']['#value'];
  }

  $form_state['redirect'] = 'admin/structure/easement/types';

  $result = drupal_write_record('content_easement_types', $data, $primary_key);

  if ($result){
    $type_data = array('type' => $form_state['values']['type'], 'new' => $new_type);
    //$type_data = array('type' => $form['#node_type']->type, 'new' => $new_type);

    if ($new_type){
      $type_data['id'] = content_easement_get_type_id($data['type']);
    }
    else {
      $type_data['id'] = $form_state['values']['id'];
    }

    // allow other modules to perform their own validations
    drupal_alter('content_easement_types_submit', $form, $form_state, $type_data);
  }
  else {
    // when something goes wrong during an add new type, make sure to delete the node type if it was created
    if ($new_type && db_query('SELECT type FROM {node_type} WHERE type = :type', array(':type' => $data['type']))->rowCount() > 0){
      node_type_delete($form_state['values']['type']);

      $message = "Removed the just created node type %name due to an error during the content easement type submit process.";
      $message_array = array('%name' => $form_state['values']['name']);

      watchdog('node', $message, $message_array, WATCHDOG_ERROR, l(t("view"), 'admin/structure/types'));
      drupal_set_message(t($message, $message_array), 'error');
    }
  }
}

/**
 * When a node type is deleted, make sure to delete the content_easement_types data as well.
 */
function content_easement_node_type_delete($info) {
  if (!is_object($info)){
    cf_error_invalid_object(__FUNCTION__, 'info', WATCHDOG_ERROR);
    return;
  }

  $type_data = array();
  $type_data['type'] = $info->type;
  $type_data['id']   = content_easement_get_type_id($type_data['type']);

  // make a copy so that the $info object can not be changed
  $information = $info;

  // allow other modules to perform their own validations
  drupal_alter('content_easement_node_type_delete', $information, $type_data);

  db_delete('content_easement_types')->condition('type', $info->type)->execute();
}

/**
 * Content easement access functions similar to that of user_access()
 * The purpose is to ensure whether or not a user has access to the given page based on multiple access permissions
 *
 * The primary use for this is hook_menu access callbacks
 *
 * Menu callbacks that do not have node type arguments should pass an empty string as the node_type
 * The node_type can be a node object or a string
 */
function content_easement_access($node_type = '', $account = NULL, array $function_history = array()) {
  if (is_object($node_type)){
    $type = $node_type->type;
  }
  else {
    $type = $node_type;
  }

  if (user_access('administer content types', $account)){
    return TRUE;
  }

  if (user_access('manage easement node types', $account)){
    if ($type === ''){
      return TRUE;
    }

    if ($type != ''){
      $query = content_easement_get_types(array_merge($function_history, array(__FUNCTION__)));

      if (is_object($query)){
        $query->condition('nt.type', strtolower($type), '=');
        $results = $query->execute()->rowCount();

        if ($results == 1){
          return TRUE;
        }
      }
    }
  }

  return FALSE;
}
