<?php

/**
 * @file
 * Module file for the workbench menu project.
 */

/**
 * Implements hook_help().
 */
function workbench_menu_help($path, $arg) {
  $output = '';

  switch ($path) {
    case "admin/help#workbench_menu":
      $output .= '<p>' . t("This module provides an alternative menuing system to the one provided by drupal. This utilizes the access control system provided by workbench_access. The only access type supported at this time is taxonomy.") . '</p>';
      return $output;
  }
}

/**
 * Implements hook_permission().
 */
function workbench_menu_permission() {
  $permissions = array();

  $permissions['edit workbench menu'] = array(
    'title' => t("Edit Workbench Menu"),
    'description' => t("Grants permissions to alter any workbench menus in which a user is in the workbench access section associated with that menu."),
  );

  $permissions['change workbench menu path'] = array(
    'title' => t("Change Workbench Menu Path"),
    'description' => t("Grants permissions to alter the menu path or related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu breadcrumb'] = array(
    'title' => t("Change Workbench Menu Breadcrumb"),
    'description' => t("Grants permissions to alter the menu breadcrumb or related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu parent'] = array(
    'title' => t("Change Workbench Menu Parent"),
    'description' => t("Grants permissions to alter the menu parent related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu hidden'] = array(
    'title' => t("Change Workbench Menu Hidden"),
    'description' => t("Grants permissions to alter the menu hidden related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu item active path'] = array(
    'title' => t("Change Workbench Menu Item Active Path"),
    'description' => t("Grants permissions to alter the active path for any menu item in which a user is able to edit."),
  );

  $permissions['administer workbench menu'] = array(
    'title' => t("Administer Workbench Menu"),
    'description' => t("Grants permissions to alter all workbench menus and perform administrative tasks."),
  );

  return $permissions;
}

/**
 * Implements hook_entity_info().
 */
function workbench_menu_entity_info() {
  $types['workbench_menu'] = array(
    'label' => t('Workbench menu'),
    'base table' => 'workbench_menus',
    'controller class' => 'WorkbenchMenuController',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'id',
    ),
  );
  return $types;
}

/**
 * Implements hook_menu().
 */
function workbench_menu_menu() {
  $items = array();

  $items['admin/config/workbench/access/menus'] = array(
    'title' => "Menus",
    'description' => "Settings for workbench menus.",
    'page callback' => 'workbench_menu_admin_settings',
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'user_access',
    'access arguments' => array('administer workbench menu'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/config/workbench/access/menus/%/%/items'] = array(
    'title' => "Menu Items",
    'description' => "Settings for workbench menus items.",
    'page callback' => 'workbench_menu_admin_item_settings',
    'page arguments' => array(5, 6),
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'user_access',
    'access arguments' => array('administer workbench menu'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  $items['admin/workbench/menus'] = array(
    'title' => "My Menus",
    'description' => "Settings for workbench menus you have access to alter.",
    'page callback' => 'workbench_menu_edit_settings',
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'workbench_menu_edit_access',
    'access arguments' => array(3, 4),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/workbench/menus/%/%/items'] = array(
    'title' => "Menu Items",
    'description' => "Settings for workbench menus items.",
    'page callback' => 'workbench_menu_edit_item_settings',
    'page arguments' => array(3, 4),
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'workbench_menu_edit_access',
    'access arguments' => array(3, 4),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  $items['workbench_menu/autocomplete_nid'] = array(
    'title' => '',
    'page callback' => 'workbench_menu_autocomplete_nid',
    'access callback' => 'workbench_menu_edit_access',
    'type' => MENU_CALLBACK,
  );

  $items['workbench_menu/autocomplete_fid'] = array(
    'title' => '',
    'page callback' => 'workbench_menu_autocomplete_fid',
    'access callback' => 'workbench_menu_edit_access',
    'type' => MENU_CALLBACK,
  );

  $items['workbench_menu/autocomplete_menu_id'] = array(
    'title' => '',
    'page callback' => 'workbench_menu_autocomplete_menu_id',
    'access callback' => 'workbench_menu_edit_access',
    'type' => MENU_CALLBACK,
  );

  $items['workbench_menu/autocomplete_menu_item_id'] = array(
    'title' => '',
    'page callback' => 'workbench_menu_autocomplete_menu_item_id',
    'access callback' => 'workbench_menu_edit_access',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_workbench_access_save().
 */
function workbench_menu_workbench_access_save($section) {
  if (variable_get('workbench_access', 'taxonomy') != 'taxonomy') {
    return;
  }

  if (!is_numeric($section['access_id'])) {
    return;
  }

  $fields = array();
  $fields['access_id'] = $section['access_id'];
  $fields['path'] = '';

  // mysql does not assign defaults on text fields, so fix that.
  if (db_driver() == 'mysql') {
    $fields['breadcrumb_name'] = '';
  }

  $query = db_insert('workbench_menus');
  $query->fields($fields);
  $query->execute();
}

/**
 * Implements hook_workbench_access_delete().
 */
function workbench_menu_workbench_access_delete($section) {
  if (variable_get('workbench_access', 'taxonomy') != 'taxonomy') {
    return;
  }

  if (!is_numeric($section['access_id'])) {
    return;
  }

  $query = db_select('workbench_menus', 'wm');
  $query->fields('wm', array('id', 'access_id'));
  $query->condition('wm.access_id', $section['access_id']);

  $records = (array) $query->execute()->fetchAll();

  if (empty($records)) {
    return;
  }

  foreach ($records as &$record) {
    $query = db_delete('workbench_menu_items');
    $query->condition('menu_id', $record->id);
    $query->execute();

    $query = db_delete('workbench_menus');
    $query->condition('id', $record->id);
    $query->execute();
  }
}

/**
 * Implements hook_theme().
 */
function workbench_menu_theme($existing, $type, $theme, $path) {
  $themes = array();

  $themes['workbench_menu_admin_settings_form'] = array(
    'render element' => 'form',
    'file' => 'workbench_menu.admin.inc',
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $themes['workbench_menu_settings_table'] = array(
    'file' => 'workbench_menu.admin.inc',
    'template' => 'workbench_menu_settings_table',
    'variables' => array(
      'table' => array(),
      'add_path' => '',
    ),
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $themes['workbench_menu_edit_settings_form'] = array(
    'render element' => 'form',
    'file' => 'workbench_menu.admin.inc',
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $list = array();
  $list['items'] = '';
  $list['title'] = '';
  $list['attributes'] = array();

  $themes['workbench_menu_list'] = array(
    'template' => 'workbench_menu_list',
    'variables' => array(
      'list' => $list,
      'data' => array(),
      'child' => FALSE,
    ),
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $data = array();
  $data['id'] = 0;
  $data['menu_id'] = 0;
  $data['menu_count'] = 0;
  $data['even_menu'] = FALSE;
  $data['settings'] = array();
  $data['even_item'] = TRUE;
  $data['count_item'] = 0;
  $data['even_item_local'] = TRUE;
  $data['count_item_local'] = 0;
  $data['depth'] = 0;
  $data['trail_is_active'] = FALSE;
  $data['path_current'] = '';

  $themes['workbench_menu_item'] = array(
    'template' => 'workbench_menu_item',
    'variables' => array(
      'data' => $data,
    ),
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  return $themes;
}

/**
 * Implements hook_block_info().
 */
function workbench_menu_block_info() {
  $blocks = array();

  $blocks['workbench_menu_block'] = array(
    'info' => t("Workbench Menu"),
    'weight' => -1,
    'status' => 1,
    'region' => 'sidebar_first',
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function workbench_menu_block_view($delta = '') {
  $path = request_path();

  if (empty($path)) {
    return array();
  }

  $parts = explode('/', $path);
  $paths = array();
  $path_string = '';

  $path2 = current_path();
  $matches = array();

  // not all /node/[nid]* paths have aliases (such as: /node/123/edit might not have an alias and /node/123 might have an alias).
  // be sure to handle the /node/[nid]* paths as if they were invalid_trail paths for the /node/[nid] alias.
  $matched = preg_match('@^node/(\d+)(/.*|$|\?.*|#.*)@', $path, $matches);

  if ($matched > 0) {
    $path_alias = drupal_get_path_alias('node/' . $matches[1]);
    $parts = explode('/', $path_alias . $matches[2]);
  }

  if (count($parts) == 0) {
    return array();
  }

  // Load the cached menus or to do the initial processing.
  $markup = array();
  $menu_cache_id = 'workbench_menu-menus_at-' . $parts[0];
  $breadcrumb_cache_id = 'workbench_menu-breadcrumbs_at-' . $parts[0];
  $menus_cached = &drupal_static($menu_cache_id, array());
  $breadcrumbs_cached = &drupal_static($breadcrumb_cache_id, array());
  $menus_processed = array();
  $save_cache = FALSE;
  $path_tree = array();
  $menu_markup = array();
  $menu_depth = -1;
  $menu_count = 0;
  $breadcrumb_tree = array();

  if ($cached_menu = cache_get($menu_cache_id, 'cache_menu')) {
    $menus_cached = $cached_menu->data;
    unset($cached_menu);
  }

  if ($cached_breadcrumb = cache_get($breadcrumb_cache_id, 'cache_menu')) {
    $breadcrumbs_cached = $cached_breadcrumb->data;
    unset($cached_breadcrumb);
  }

  foreach ($parts as &$part) {
    $path_string .= $part;
    $paths[] = $path_string;

    if (empty($menus_cached[$path_string])) {
      $menus_cached[$path_string] = (array) workbench_menu_build_menus($path_string, $menus_processed, $breadcrumbs_cached);

      if (!empty($menus_cached[$path_string])) $save_cache = TRUE;
    }

    if (!empty($menus_cached[$path_string])) {
      $path_tree[] = $path_string;
      $menu_depth++;
    }

    $path_string .= '/';
  }

  if ($save_cache) {
    cache_set($menu_cache_id, $menus_cached, 'cache_menu');
    cache_set($breadcrumb_cache_id, $breadcrumbs_cached, 'cache_menu');
  }

  $path_string = preg_replace('|/$|', '', $path_string);
  $show_parents = TRUE;
  $assign_breadcrumbs = TRUE;
  $path_tree2 = $path_tree;

  while (!empty($path_tree) && $show_parents) {
    $current_path = array_pop($path_tree);

    if ($assign_breadcrumbs) {
      while (!empty($path_tree2)) {
        $current_path2 = array_pop($path_tree2);

        if (!empty($breadcrumbs_cached[$current_path2])) {
          $bc = array_merge(array('<a href="' . base_path() . '">' . t("Home") . '</a>'), $breadcrumbs_cached[$current_path2]);

          drupal_set_breadcrumb($bc);
          break;
        }
      }

      $assign_breadcrumbs = FALSE;
    }

    if (!empty($menus_cached[$current_path]['structure'])) {
      $data = workbench_menu_render_menus($menus_cached[$current_path], $path_string, $show_parents, $menu_depth, $menu_count);

      foreach ($data as $key => &$value) {
        if (isset($menu_markup[$key])) {
          $menu_markup[$key] .= $value;
        }
        else {
          $menu_markup[$key] = $value;
        }
      }
    }

    $menu_depth--;
    $menu_count++;
  }

  if (empty($menu_markup)) {
    return array();
  }

  $block = array();
  $block['subject'] = '';
  $block['content'] = array(
    '#markup' => implode(' ', $menu_markup),
    '#attached' => array(
      'css' => array(drupal_get_path('module', 'workbench_menu') . '/includes/workbench_menu.css'),
      'js' => array(drupal_get_path('module', 'workbench_menu') . '/includes/workbench_menu.js'),
    ),
  );

  return $block;
}

/**
 * Process and build the menus for a given path.
 *
 * @param string $path_string
 *   A string containing the url path of the menu to generate.
 * @param array $menus_processed
 *   An array of menu ids defining which menus have already been
 *   processed.
 * @param array|false $breadcrumbs
 *   An array of breadcrumbs that will be auto populated by this
 *   function.
 *   Each array key will be the path in which a given array of
 *   breadcrumbs relate to.
 *   If FALSE, then breadcrumbs will not be populated.
 * @param bool $skip_hidden
 *   When set to TRUE (default), the hidden menus are skipped.
 *   When set to FALSE, hidden menus are built.
 *
 * @return array
 *   An array with the following structure:
 *   - structure: A nested array containing the weights and item ids.
 *   - settings: A flat array containing the properties of each item.
 *
 * @see drupal_set_breadcrumb()
 */
function workbench_menu_build_menus($path_string, &$menus_processed, &$breadcrumbs, $skip_hidden = TRUE) {
  $menus = (array) workbench_menu_get_menus(array('path' => array($path_string)), 'id');

  $menu_even = TRUE;
  $menu_total = count($menus);
  $menu_current = 0;

  $built_menus = array();
  $built_menus['structure'] = array();
  $built_menus['menus'] = array();

  foreach ($menus as $menu_id => &$menu) {
    if ($skip_hidden && $menu->hidden) {
      continue;
    }

    $menus_processed[$menu->id] = NULL;

    $built_menu = array();
    $built_menu['structure'] = array();
    $built_menu['settings'] = array();
    $built_menu['id'] = $menu->id;
    $built_menu['access_id'] = $menu->access_id;
    $built_menu['path'] = $menu->path;
    $built_menu['weight'] = $menu->weight;
    $built_menu['show_parents'] = $menu->show_parents;
    $built_menu['breadcrumb_name'] = $menu->breadcrumb_name;

    $variables = array();
    $variables['menus_processed'] = &$menus_processed;

    if ($breadcrumbs === FALSE) {
      $variables['breadcrumbs_all'] = FALSE;
    }
    else {
      $variables['breadcrumbs_all'] = &$breadcrumbs;
    }


    $menu_name = $menu->breadcrumb_name;
    $top_level = array(l($menu_name, $menu->path));
    $breadcrumbs[$menu->path] = $top_level;

    if (empty($menu->items['nested'])) {
      $menu_total--;
      continue;
    }

    foreach ($menu->items['nested'] as &$item) {
      $variables['parent_path'] = $menu->path;
      $variables['menu_path'] = $menu->path;
      $variables['breadcrumbs'] = $top_level;

      $data = workbench_menu_build_menu_item($menu, $item, $variables);

      foreach ($data['structure'] as $weight_id => &$weight_data) {
        foreach ($weight_data as $weight_data_id => $weight_data_data) {
          $built_menu['structure'][$weight_id][$weight_data_id] = $weight_data_data;
        }
      }

      foreach ($data['settings'] as $child_id => &$child_settings) {
        $built_menu['settings'][$child_id] = $child_settings;
      }

      $built_menus['structure'][$menu->weight][$menu->id] = $built_menu;
    }
  }

  return $built_menus;
}

/**
 * Process and build the menu items.
 *
 * @param object $menu
 *   A menu object as returned by workbench_menu_get_menus().
 * @param array $item
 *   A menu item as stored in $menu->items['nested'].
 * @param array $variables
 *   An array containing the following keys:
 *   - 'menus_processed': An array containing menu access ids whose
 *   array keys are the menu ids.
 *   - 'breadcrumbs_all':
 *   An array of breadcrumbs whose keys are path strings or FALSE.
 *   If it is FALSE, then breadcrumbs will not be processed.
 *   - 'parent_path': A string of the path of a parent menu item.
 *   - 'breadcrumbs': A breadcrumb array associated with this menu
 *   item.
 *   It is structured such that it can be directly passed to
 *   drupal_set_breadcrumb().
 *
 * @return array
 *   An array with the following structure:
 *   - structure: A nested array containing the weights and item ids.
 *   - settings: A flat array containing the properties of each item.
 *
 * @see workbench_menu_get_menus()
 * @see drupal_set_breadcrumb()
 */
function workbench_menu_build_menu_item($menu, $item, &$variables) {
  $built_menu = array();

  $item_id = & $item['item']->id;

  $structure = array();
  $structure[$item['item']->weight] = array($item_id => array());

  $settings = array();
  $settings[$item_id] = array();

  $item_settings = & $settings[$item_id];

  $item_settings['type'] = '';
  $item_settings['expand'] = 'expand_auto';
  $item_settings['label'] = check_plain($item['item']->human_name);
  $item_settings['attributes'] = array();
  $item_settings['attributes']['class'] = array();
  $item_settings['attributes']['class'][] = 'menu_item';
  $item_settings['attributes']['class'][] = 'menu_item-id-' . $item_id;
  $item_settings['prefix'] = '';
  $item_settings['postfix'] = '';
  $item_settings['outside_link'] = FALSE;
  $item_settings['top_link'] = FALSE;
  $item_settings['active_path'] = '';
  $item_settings['breadcrumbs'] = array();

  $process_children = TRUE;

  foreach ($item['item']->item_type as &$type) {
    $item_settings['type'] = $type->machine_name;
    $item_settings['attributes']['class'][] = 'menu_item-type-' . $type->machine_name;
    break;
  }

  foreach ($item['item']->expand as &$expand) {
    $item_settings['expand'] = $expand->machine_name;
    $item_settings['attributes']['class'][] = 'menu_item-expand-' . $expand->machine_name;
    break;
  }

  $active_path = preg_replace('/%20/', ' ', $item['item']->active_path);

  $alter_settings = array();
  $alter_settings['menu'] = clone($menu);
  $alter_settings['item'] = $item;
  $alter_settings['settings'] = &$item_settings;
  $alter_settings['active_path'] = $active_path;
  $alter_settings['variables'] = &$variables;

  // menu item menus are other menus embedded inside the current menu.
  if ($item_settings['type'] == 'item_menu') {
    $field = & $item['item']->properties['menu'];
    $item_menus = array();

    if (cf_is_integer($field)) {
      $item_menus = (array) workbench_menu_get_menus(array('id' => $field), 'id');
    }
    else {
      $matched = preg_match('@\[id: (\d+)\]\s*$@', $field, $matches);

      if ($matched > 0) {
        if (cf_is_integer($matches[1])) {
          $item_menus = (array) workbench_menu_get_menus(array('id' => $matches[1]), 'id');
        }
      }
    }

    if (empty($item_menus)) {
      if (class_exists('cf_error')) {
        cf_error::invalid_variable('item_menus', "Failed to find workbench menu with menu id of %id" , array('%id' => $field), WATCHDOG_WARNING);
      }

      return array('structure' => array(), 'settings' => array());
    }

    $item_menu = array_pop($item_menus);

    // prevent infinite loops, only process menus once and do not process menus that point to self.
    if ($menu->id == $field || array_key_exists($item_menu->id, $variables['menus_processed'])) {
      return array('structure' => array(), 'settings' => array());
    }

    $variables['menus_processed'][$item_menu->id] = NULL;

    $breadcrumbs_temporary = FALSE;
    $built_menus = workbench_menu_build_menus($item_menu->path, $variables['menus_processed'], $breadcrumbs_temporary, FALSE);
    $data = array();

    if (isset($built_menus['structure'][$item_menu->weight][$item_menu->id])) {
      $data['structure'] = $built_menus['structure'][$item_menu->weight][$item_menu->id]['structure'];
      $data['settings'] = $built_menus['structure'][$item_menu->weight][$item_menu->id]['settings'];
    }
    else {
      $data['structure'] = array();
      $data['settings'] = array();
    }

    if ($item_settings['expand'] != "expand_auto") {
      foreach ($data['structure'] as $row_key => &$row_value) {
        foreach ($row_value as $key => &$value) {
          $data['settings'][$key]['expand'] = $item_settings['expand'];
        }
      }
    }

    return $data;
  }

  // menu item menu items are parts of another menu embeded inside of the current menu.
  if ($item_settings['type'] == 'item_menu_item') {
    $field_menu = & $item['item']->properties['menu'];
    $field_menu_item = & $item['item']->properties['menu_item'];
    $item_menus = array();

    if (cf_is_integer($field_menu)) {
      $item_menus = (array) workbench_menu_get_menus(array('id' => $field_menu), 'id');
    }
    else {
      $matches = array();
      $matched = preg_match('@\[id: (\d+)\]\s*$@', $field_menu, $matches);

      if ($matched > 0) {
        if (cf_is_integer($matches[1])) {
          $item_menus = (array) workbench_menu_get_menus(array('id' => $matches[1]), 'id');
        }
      }
    }

    // return if not items were found.
    if (empty($item_menus)) {
      return array('structure' => array(), 'settings' => array());
    }

    $item_menu = array_pop($item_menus);
    $item_menu_item = NULL;
    $item_menu_item_id = NULL;

    if (cf_is_integer($field_menu_item)) {
      $item_menu_item_id = $field_menu_item;
    }
    else {
      $matches = array();
      $matched = preg_match('@\[id: (\d+)\]\s*$@', $field_menu_item, $matches);

      if ($matched > 0) {
        if (cf_is_integer($matches[1])) {
          $item_menu_item_id = $matches[1];
        }
      }
    }

    // Unable to determine the item menu item id.
    if (is_null($item_menu_item_id)) {
      return array('structure' => array(), 'settings' => array());
    }

    $process_children = FALSE;

    $item_menu_item_variables = array();
    $item_menu_item_variables['menus_processed'] = $variables['menus_processed'];
    $item_menu_item_variables['parent_path'] = $item_menu->path;
    $item_menu_item_variables['menu_path'] = $item_menu->path;
    $item_menu_item_variables['breadcrumbs'] = array(l($item_menu->breadcrumb_name, $item_menu->path));

    if ($variables['breadcrumbs_all'] === FALSE) {
      $item_menu_item_variables['breadcrumbs_all'] = FALSE;
    }
    else {
      $item_menu_item_variables['breadcrumbs_all'] = &$breadcrumbs;
    }

    $history_stack = array();
    $current_stack = array_reverse($item_menu->items['nested'], TRUE);

    while (!empty($current_stack)) {
      $nested_item = array_pop($current_stack);

      if ($nested_item['item']->id == $item_menu_item_id) {
        $item_menu_item = &$nested_item;
        array_push($item_menu->items['nested'], $nested_item);
        break;
      }

      if (!empty($nested_item['children'])) {
        array_push($history_stack, $current_stack);

        $current_stack = array_reverse($nested_item['children'], TRUE);
        continue;
      }

      if (empty($current_stack) && !empty($history_stack)) {
        $current_stack = array_pop($history_stack);
      }
    }

    unset($history_stack);
    unset($current_stack);

    if (is_null($item_menu_item)) {
      drupal_alter(__FUNCTION__, $alter_settings);
      return array('structure' => array(), 'settings' => $settings);
    }

    // do not process item_menu and item_menu_item types
    if ($item_menu_item['item']->item_type[0]->machine_name == 'item_menu' || $item_menu_item['item']->item_type[0]->machine_name == 'item_menu_item') {
      return array('structure' => array(), 'settings' => $settings);
    }

    $data = workbench_menu_build_menu_item($item_menu, $item_menu_item, $item_menu_item_variables);

    // failed to find the menu item.
    if (empty($data['structure'])) {
      return array('structure' => array(), 'settings' => array());
    }

    $structure[$item['item']->weight][$item_id] = $data['structure'][$item_menu_item['item']->weight][$item_menu_item_id];

    $item_settings['label'] = $data['settings'][$item_menu_item_id]['label'];
    $item_settings['prefix'] = $data['settings'][$item_menu_item_id]['prefix'];
    $item_settings['postfix'] = $data['settings'][$item_menu_item_id]['postfix'];
    $item_settings['outside_link'] = $data['settings'][$item_menu_item_id]['outside_link'];
    $item_settings['top_link'] = $data['settings'][$item_menu_item_id]['top_link'];
    $item_settings['active_path'] = $data['settings'][$item_menu_item_id]['active_path'];

    foreach ($data['settings'][$item_menu_item_id]['attributes'] as $attribute => &$value) {
      if ($attribute == 'id' || $attribute == 'class') continue;
      $item_settings['attributes'][$attribute] = $value;
    }

    $item_settings['attributes']['class'][] = 'menu_item-type-' . $data['settings'][$item_menu_item_id]['type'];

    unset($data['settings'][$item_menu_item_id]);

    foreach ($data['settings'] as $child_id => &$child_settings) {
      $settings[$child_id] = $child_settings;
    }

    $built_menu['structure'] = $structure;
    $built_menu['settings'] = $settings;
    return $built_menu;
  }

  // menu item labels are parts of a menu that do not link to anything.
  if ($item_settings['type'] == 'item_label') {
    if (isset($item['item']->properties['disabled']) && $item['item']->properties['disabled']) {
      $item_settings['attributes']['class'][] = 'disabled';
      $item_settings['clickable'] = FALSE;
    }
    elseif (isset($item['item']->properties['clickable']) && $item['item']->properties['clickable']) {
      $item_settings['attributes']['class'][] = 'clickable';
      $item_settings['attributes']['class'][] = 'noscript';
      $item_settings['attributes']['href'] = array('');
      $item_settings['clickable'] = TRUE;
    }
  }

  // menu item links are parts of a menu that link to some url, file, or id (local or remote).
  if ($item_settings['type'] == 'item_link' || $item_settings['type'] == 'item_node') {
    $link_path = '';
    $process = TRUE;
    $parsed_url = array();
    $matches = array();

    if ($item_settings['type'] == 'item_link') {
      $matched = preg_match('@^/node/(\d+)(/.*|$|\?.*|#.*)@', $item['item']->properties['url'], $matches);
    }
    else {
      $matched = preg_match('@^(\d+)($|\?.*|#.*)@', $item['item']->properties['node_id'], $matches);

      if ($matched == 0) {
        $matched = preg_match('@\[nid: (\d+)\]\s*($|\?.*|#.*)@', $item['item']->properties['node_id'], $matches);
      }
    }

    if ($matched > 0) {
      if (isset($matches[2])) {
        $link_extras = $matches[2];
      }

      if (cf_is_integer($matches[1])) {
        $path_alias = drupal_get_path_alias('node/' . $matches[1]) . $link_extras;
        $parsed_url = parse_url($path_alias);

        if (!empty($parsed_url['path'])) {
          $link_path = '/' . $parsed_url['path'];
          $active_path = $parsed_url['path'];
        }

        if (!empty($parsed_url['query'])) {
          $link_path .= '?' . $parsed_url['query'];
        }

        if (!empty($parsed_url['fragment'])) {
          $link_path .= '#' . $parsed_url['fragment'];
        }

        // check to see if the node still exists.
        $query = db_select('node', 'n');
        $query->fields('n', array('nid'));
        $query->condition('n.nid', $matches[1]);

        $results = $query->execute()->fetchAll();

        if (empty($results)) {
          $item_settings['attributes']['title'] = array(t("Page Not Found: !path_alias.", array('!path_alias' => check_plain($path_alias))));
          $process = FALSE;
          $link_path = '';
        }
      }
    }

    if ($process && empty($link_path)) {
      if ($item['item']->properties['url'] == '<top>') {
        $item_settings['attributes']['class'][] = 'menu_item-menu_top';
        $item_settings['top_link'] = TRUE;

        $link_path = '/' . $menu->path;
        $active_path = $menu->path;
      }
      else {
        $link_path = $item['item']->properties['url'];

        if (valid_url($link_path, TRUE)) {
          $parsed_url = parse_url($link_path);
          $remote_url = check_plain($parsed_url['host']);

          $item_settings['prefix'] .= '<div class="' . 'menu_item-icon ' . 'menu_item-icon_external"></div>';
          $item_settings['attributes']['title'] = array(t("This links to the external website: !remote_url.", array('!remote_url' => $remote_url)));
        }
        else {
          $matches = array();

          if (preg_match('/^mailto:(.*)/', $link_path, $matches) > 0) {
            $item_settings['prefix'] .= '<div class="' . 'menu_item-icon ' . 'menu_item-icon_mail"></div>';
            $item_settings['attributes']['title'] = array(t("Send an e-mail to: !email_address.", array('!email_address' => check_plain($matches[1]))));
          }
          elseif (preg_match('@^(/|#)@', $link_path) === 0) {
            $link_path = '/' . $menu->path . '/' . $link_path;
          }
        }
      }
    }

    if (!empty($link_path)) {
      $item_settings['attributes']['href'] = array($link_path);
    }

    $item_settings['outside_link'] = (preg_match('@^' . $menu->path . '/@', $link_path) > 0);

    unset($matches);
    unset($matched);
    unset($link_path);
  }

  if ($item_settings['type'] == 'item_file') {
    $icon = check_plain($item['item']->properties['file_type']);
    $filename = '';
    $link_path = '';
    $process = TRUE;

    $matches = array();
    $matched = preg_match('@\[fid: (\d+)\]\s*$@i', $item['item']->properties['file'], $matches);

    if ($matched > 0) {
      $match = array_pop($matches);

      if (cf_is_integer($match)) {
        $query = db_select('file_managed', 'fm');
        $query->fields('fm', array('uri', 'filename'));
        $query->condition('fm.fid', $match);
        $query->condition('fm.status', 1);

        $results = $query->execute()->fetchAll();

        if (!empty($results)) {
          $result = array_pop($results);
          $filename = $result->filename;
          $parts = explode('://', $result->uri, 2);
          $instance = file_stream_wrapper_get_instance_by_scheme($parts[0]);
          $instance->setUri($result->uri);
          $link_path = $instance->getExternalUrl();
        }

        $process = FALSE;
      }
    }

    if ($process) {
      // it is possible for a local node to generate/return itself as a file.
      $matches = array();
      $matched = preg_match('@^/node/(\d+)(/.*|$|\?.*|#.*)@', $item['item']->properties['file'], $matches);

      if ($matched > 0) {
        $path_alias = drupal_get_path_alias('node/' . $matches[1]);

        if (isset($matches[2])) {
          $path_alias .= $matches[2];
        }

        $parsed_url = parse_url($path_alias);

        if (!empty($parsed_url['path'])) {
          $link_path = '/' . $parsed_url['path'];
          $active_path = $parsed_url['path'];
          $process = FALSE;
        }

        if (!empty($parsed_url['query'])) {
          $link_path .= '?' . $parsed_url['query'];
        }

        if (!empty($parsed_url['fragment'])) {
          $link_path .= '#' . $parsed_url['fragment'];
        }

        // check to see if the node still exists and use the node title.
        $query = db_select('node', 'n');
        $query->fields('n', array('nid', 'title'));
        $query->condition('n.nid', $matches[1]);

        $results = $query->execute()->fetchAll();

        if (empty($results)) {
          $link_path = '';
          $filename = $path_alias;
        }
        else {
          $result = array_pop($results);
          $filename = $result->title;
        }
      }
    }

    if ($process) {
      $link_path = $item['item']->properties['file'];
      $filename = check_plain(rawurldecode(basename($link_path)));

      if (valid_url($link_path, TRUE)) {
        $parsed_url = parse_url($link_path);
        $remote_url = check_plain($parsed_url['host']);

        $item_settings['prefix'] = '<div class="' . 'menu_item-icon ' . 'menu_item-icon_' . $icon . '"></div>';
        $item_settings['attributes']['title'] = array(t("Download !filename from the external website: !remote_url.", array('!filename' => $filename, '!remote_url' => $remote_url)));
        $item_settings['attributes']['class'][] = 'menu_item-external_url';
      }
      else {
        $item_settings['prefix'] .= '<div class="' . 'menu_item-icon ' . 'menu_item-icon_' . $icon . '"></div>';
        $item_settings['attributes']['title'] = array(t("Download !filename.", array('!filename' => $filename)));
      }
    }
    else {
      $item_settings['prefix'] .= '<div class="' . 'menu_item-icon ' . 'menu_item-icon_' . $icon . '"></div>';
      $item_settings['attributes']['title'] = array(t("Download: !filename.", array('!filename' => $filename)));

      if (empty($link_path)) {
        $item_settings['attributes']['title'] = array(t("File Not Found: !filename.", array('!filename' => $filename)));
      }
    }

    if (!empty($link_path)) {
      $item_settings['attributes']['href'] = array($link_path);
    }

    $item_settings['postfix'] = '';

    unset($icon);
    unset($filename);
    unset($matches);
    unset($matched);
    unset($link_path);
  }

  if ($item['item']->active_path == '<top>') {
    $active_path = $variables['menu_path'];
  }
  elseif (empty($item_settings['active_path']) && !empty($item['item']->active_path)) {
    if (preg_match('@^/@', $item['item']->active_path) == 0) {
      $active_path = $variables['parent_path'] . '/' . $item['item']->active_path;
    }
    else {
      $active_path = $variables['menu_path'] . $item['item']->active_path;
    }
  }

  if (!empty($active_path)) {
    $active_path = preg_replace('/%20/', ' ', $active_path);

    $item_settings['active_path'] = $active_path;

    if ($active_path != $variables['menu_path']) {
      $variables['breadcrumbs'][] = l($item_settings['label'], $active_path, array('html' => TRUE));
    }

    if ($variables['breadcrumbs_all'] !== FALSE) {
      if (preg_match('@^' . $variables['parent_path'] . '/@', $active_path) > 0) {
        $variables['breadcrumbs_all'][$active_path] = $variables['breadcrumbs'];
      }
    }
  }
  else {
    $variables['breadcrumbs'][] = '<span>' . $item_settings['label'] . '</span>';
  }

  if ($variables['breadcrumbs_all'] === FALSE) {
    unset($item_settings['breadcrumbs']);
  }
  else {
    $item_settings['breadcrumbs'] = $variables['breadcrumbs'];
  }

  if ($process_children && !empty($item['children'])) {
    foreach ($item['children'] as &$child) {
      $child_variables = array();
      $child_variables['menus_processed'] = &$variables['menus_processed'];
      $child_variables['parent_path'] = $variables['parent_path'];
      $child_variables['menu_path'] = $variables['menu_path'];
      $child_variables['breadcrumbs'] = $variables['breadcrumbs'];

      if ($variables['breadcrumbs_all'] === FALSE) {
        $child_variables['breadcrumbs_all'] = FALSE;
      }
      else {
        $child_variables['breadcrumbs_all'] = &$variables['breadcrumbs_all'];
      }

      if (!empty($active_path)) {
        $child_variables['parent_path'] = $active_path;
      }

      $data = workbench_menu_build_menu_item($menu, $child, $child_variables);

      foreach ($data['structure'] as $structure_id => &$structure_data) {
        foreach ($structure_data as $structure_data_id => $structure_data_data) {
          $structure[$item['item']->weight][$item_id][$structure_id][$structure_data_id] = $structure_data_data;
        }
      }

      foreach ($data['settings'] as $child_id => &$child_settings) {
        $settings[$child_id] = $child_settings;
      }
    }
  }

  // @todo: write the api for this alter function
  drupal_alter(__FUNCTION__, $alter_settings);

  $built_menu['structure'] = $structure;
  $built_menu['settings'] = $settings;
  return $built_menu;
}

/**
 * Render the contents of a pre-built menu into a html menus.
 *
 * @param array $built_menu
 *   An array with the following structure:
 *   - weight: A nested array containing the weights and item ids.
 *   - settings: A flat array containing the properties of each item.
 * @param string $path_current
 *   A string containing the complete url path that is currently
 *   active.
 * @param bool $show_parents
 *   A boolean representing whether or not the parent menus should be
 *   renderred.
 *   This is populated after renderring the given menu to tell the
 *   caller if it is okay to or not to render the parent menus.
 * @param int $menu_depth
 *   A number representing the recursive depth of a menu.
 * @param int $menu_count
 *   An auto-incremented number assigned to the menu.
 *
 * @return array
 *   An array with the following structure:
 *   - markup: A string of the renderred html markup.
 *   - breadcrumb: An array as of breadcrumb data as needed by
 *   drupal_set_breadcrumb().
 *
 * @see workbench_menu_build_menus()
 * @see drupal_set_breadcrumb()
 */
function workbench_menu_render_menus($built_menus, $path_current, &$show_parents, $menu_depth, $menu_count) {
  $even_menu = TRUE;
  $rendered = array();

  foreach ($built_menus['structure'] as $built_menus_weight => &$menus) {
    $rendered[$built_menus_weight] = '';

    foreach ($menus as $menu_id => &$menu_data) {
      $list = array();
      $list['items'] = array();
      $list['attributes'] = array();
      $list['attributes']['class'] = array();
      $list['attributes']['class'][] = 'workbench_menu';
      $list['attributes']['class'][] = 'workbench_menu-id-' . $menu_id;
      $list['attributes']['class'][] = 'workbench_menu-weight-' . $built_menus_weight;
      $list['attributes']['class'][] = 'workbench_menu-count-' . $menu_count;
      $list['attributes']['class'][] = 'workbench_menu-depth-' . $menu_depth;
      $list['attributes']['class'][] = 'menu';

      if (!$menu_data['show_parents']) $show_parents = FALSE;

      $variables = array();
      $variables['menu_id'] = &$menu_id;
      $variables['menu_depth'] = $menu_depth;
      $variables['menu_weight'] = $built_menus_weight;
      $variables['menu_count'] = $menu_count;
      $variables['even_menu'] = &$even_menu;
      $variables['settings'] = &$menu_data['settings'];
      $variables['even_item'] = TRUE;
      $variables['count_item'] = 0;
      $variables['even_item_local'] = TRUE;
      $variables['count_item_local'] = 0;
      $variables['depth'] = 0;
      $variables['trail_is_active'] = FALSE;
      $variables['path_current'] = $path_current;

      foreach ($menu_data['structure'] as $weight => &$items) {
        foreach ($items as $id => &$children) {
          $variables['id'] = $id;
          $variables['children'] = &$children;

          $list['items'][] = theme('workbench_menu_item', array('data' => &$variables));
        }
      }

      $rendered[$built_menus_weight] .= theme('workbench_menu_list', array('list' => $list, 'data' => $variables));

      $even_menu = !$even_menu;
    }
  }

  return $rendered;
}

/**
 * Render the contents of a pre-built menu item into html menu items.
 */
function template_preprocess_workbench_menu_item(&$vars) {
  $variables = &$vars['data'];

  if (empty($variables['settings'])) {
    return;
  }

  $variables['even_item'] = !$variables['even_item'];
  $variables['count_item']++;
  $variables['even_item_local'] = !$variables['even_item_local'];
  $variables['count_item_local']++;
  $variables['trail_is_active'] = FALSE;
  $variables['invalid_trail_active'] = FALSE;
  $variables['clickable_label'] = FALSE;

  if ($variables['settings'][$variables['id']]['type'] == 'item_label') {
    if (!empty($variables['settings'][$variables['id']]['clickable'])) {
      $variables['clickable_label'] = TRUE;
    }
  }

  $variables['child_list'] = array();

  // provide an active text string for purposes of accessibility.
  $variables['active_text'] = '';

  if ($variables['settings'][$variables['id']]['active_path'] == $variables['path_current']) {
    $variables['trail_is_active'] = TRUE;
    $variables['settings'][$variables['id']]['attributes']['class'][] = 'active';
    $variables['active_text'] =' <span class="element-invisible">' . t("(active menu item)") . '</span>';
  }
  else {
    if (preg_match('@' . $variables['settings'][$variables['id']]['active_path'] . '@', $variables['path_current']) > 0) {
      $path_current_parts = explode('/', $variables['path_current']);

      while (!empty($path_current_parts)) {
        if (implode('/', $path_current_parts) == $variables['settings'][$variables['id']]['active_path']) {
          $variables['invalid_trail_active'] = TRUE;
          $variables['trail_is_active'] = TRUE;
          $variables['settings'][$variables['id']]['attributes']['class'][] = 'invalid_active';
          break;
        }

        array_pop($path_current_parts);
      }
    }
  }

  if ($variables['trail_is_active'] && isset($variables['settings'][$variables['id']]['breadcrumbs'])) {
    $bc = array_merge(array('<a href="' . base_path() . '">' . t("Home") . '</a>'), $variables['settings'][$variables['id']]['breadcrumbs']);

    drupal_set_breadcrumb($bc);
  }

  if (empty($variables['children'])) {
    $variables['settings'][$variables['id']]['attributes']['class'][] = 'leaf';
  }
  else {
    $child_variables = array();
    $child_variables['settings'] = &$variables['settings'];
    $child_variables['even_item'] = &$variables['even_item'];
    $child_variables['count_item'] = &$variables['count_item'];
    $child_variables['even_item_local'] = TRUE;
    $child_variables['count_item_local'] = 0;
    $child_variables['depth'] = $variables['depth'] + 1;
    $child_variables['trail_is_active'] = FALSE;
    $child_variables['invalid_trail_active'] = FALSE;
    $child_variables['clickable'] = FALSE;
    $child_variables['path_current'] = $variables['path_current'];

    $child_list = array();

    foreach ($variables['children'] as $weight => &$items) {
      foreach ($items as $id => &$children) {
        $child_variables['id'] = $id;
        $child_variables['children'] = &$children;

        $child_list[] = theme('workbench_menu_item', array('data' => &$child_variables));

        if ($child_variables['trail_is_active']) {
          $variables['trail_is_active'] = TRUE;

          if ($child_variables['invalid_trail_active']) {
            $variables['invalid_trail_active'] = TRUE;
          }
        }
      }
    }

    if ($variables['trail_is_active'] || $variables['clickable_label']) {
      if ($variables['settings'][$variables['id']]['expand'] == 'expand_always' || $variables['settings'][$variables['id']]['expand'] == 'expand_auto') {
        $variables['child_list'] = &$child_list;

        if ($variables['clickable_label']) {
          $variables['settings'][$variables['id']]['attributes']['class'][] = 'collapsed';
        }
        else {
          $variables['settings'][$variables['id']]['attributes']['class'][] = 'expanded';
        }
      }
      elseif ($variables['settings'][$variables['id']]['expand'] == 'expand_never') {
        $variables['settings'][$variables['id']]['attributes']['class'][] = 'collapsed';

        if ($variables['invalid_trail_active']) {
          $variables['settings'][$variables['id']]['attributes']['class'][] = 'invalid_active';
        }
        else {
          $variables['settings'][$variables['id']]['attributes']['class'][] = 'active';
          $variables['active_text'] =' <span class="element-invisible">' . t("(active menu item)") . '</span>';
        }
      }
    }
    else {
      if ($variables['settings'][$variables['id']]['expand'] == 'expand_always') {
        $variables['settings'][$variables['id']]['attributes']['class'][] = 'expanded';
        $variables['child_list'] = &$child_list;
      }
      elseif ($variables['settings'][$variables['id']]['expand'] == 'expand_never' || $variables['settings'][$variables['id']]['expand'] == 'expand_auto') {
        $variables['settings'][$variables['id']]['attributes']['class'][] = 'collapsed';
      }
    }
  }

  if ($variables['trail_is_active'] || preg_match('@^' . $variables['settings'][$variables['id']]['active_path'] . '/@', $variables['path_current']) > 0) {
    $variables['settings'][$variables['id']]['attributes']['class'][] = 'active-trail';

    if ($variables['clickable_label']) {
      $noscript_key = array_search('noscript', $variables['settings'][$variables['id']]['attributes']['class']);

      if ($noscript_key !== FALSE) {
        unset($variables['settings'][$variables['id']]['attributes']['class'][$noscript_key]);
      }

      unset($noscript_key);
    }
  }

  $variables['settings'][$variables['id']]['attributes']['class'][] = ($variables['even_item'] ? 'even' : 'odd') ;
  $variables['settings'][$variables['id']]['attributes']['class'][] = ($variables['even_item_local'] ? 'local_even' : 'local_odd') ;
  $variables['settings'][$variables['id']]['attributes']['class'][] = 'row-' . $variables['count_item'];
  $variables['settings'][$variables['id']]['attributes']['class'][] = 'local_row-' . $variables['count_item_local'];
  $variables['settings'][$variables['id']]['attributes']['class'][] = 'depth-' . $variables['depth'];

  // if href is empty for items that require href, then append a broken link css class.
  if ($variables['settings'][$variables['id']]['type'] != 'item_label') {
    if (!isset($variables['settings'][$variables['id']]['attributes']['href'])) {
      $variables['settings'][$variables['id']]['attributes']['class'][] = 'menu_item-broken_link';
    }
  }

  $variables['count_item']++;
  $variables['even_item_local'] = !$variables['even_item_local'];
  $variables['count_item_local']++;
}

/**
 * Obtain a list of available menus.
 *
 * @param bool $with_path
 *   When TRUE, this prepends the url path of the menu to help make names less ambiguous.
 * @param bool $with_id
 *   When TRUE, this prepends the id of the menu to help make names less ambiguous.
 *
 * @return array
 *  An array of options with the menus taxonomy id as the key and the
 *  taxonomy human name as the value.
 */
function workbench_menu_get_menus_options_list($with_path = FALSE, $with_id = FALSE) {
  $variation = $with_path ? 't' : 'f';
  $variation .= $with_id ? 't' : 'f';

  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (isset($options_list[$variation])) {
    return $options_list[$variation];
  }

  $options_list = array();
  $menus = (array) workbench_menu_get_menus(array(), 'id');

  foreach ($menus as $id => &$menu) {
    $options_list[$variation][$menu->access_id] = $menu->breadcrumb_name;

    if ($with_path) {
      $options_list[$variation][$menu->access_id] .= " [url:" . $menu->path . "]";
    }

    if ($with_id) {
      $options_list[$variation][$menu->access_id] .= " [id:" . $menu->id . "]";
    }
  }

  asort($options_list[$variation]);

  return $options_list[$variation];
}

/**
 * Obtains the menus associated with a given path or paths.
 *
 * This matches against the menus that are the depest-level children
 * of a given path.
 * That is, if there exist menus at /a/, /a/b/, and /a/b/c/ and the
 * current path is /a/b/d, then only the menu at path /a/b/ is
 * returned.
 *
 * @param string|array $paths
 *   A path string or an array of path strings.
 *   If a string is passed, the string will be broken down into an
 *   array of parts like this: '/a/b/c/d' -> array('a', 'a/b',
 *   'a/b/c', 'a/b/c/d').
 *   If an array is passed, the strings will be used as is without
 *   being broken down.
 *
 * @return array
 *   An array of menu objects for the given path.
 */
function workbench_menu_get_menus_at_paths($paths) {
  if (is_string($paths)) {
    $parts = explode('/', $paths);
    $matches = array();
    $path_string = '';

    foreach ($parts as &$part) {
      $path_string .= $part;
      $matches[] = $path_string;
      $path_string .= '/';
    }
  }
  elseif (is_array($paths)) {
    $matches = &$paths;
  }
  else {
    if (class_exists('cf_error')) {
      cf_error::invalid_variable('paths', "Must be a string or an array of strings.");
    }

    return array();
  }

  return (array) workbench_menu_get_menus(array('path' => $matches, 'fast' => NULL), 'id');
}

/**
 * Obtains the menus associated with a given node or node id.
 *
 * @param $node_or_nid
 *   A node or a node id.
 *
 * @return
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_menus_at_node($node_or_nid) {
  if (!is_object($node_or_nid) && !is_numeric($node_or_nid)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_variable('node_or_nid', "Must be either a node object or a number.");
    }

    return array();
  }

  if (is_numeric($node_or_nid)) {
    $node = node_load($node_or_nid);
  }
  else {
    $node = &$node_or_nid;
  }

  if (!property_exists($node, 'workbench_access') || empty($node->workbench_access)) {
    return array();
  }

  $path_node = 'node/' . $node->nid;
  $path_alias = drupal_get_path_alias($path_node);

  if ($path_alias == $path_node) {
    $menus = (array) workbench_menu_get_menus(array('access_id' => $node->workbench_access, 'fast' => NULL), 'id');

    return $menus;
  }

  return workbench_menu_get_menus_at_paths($path_alias);
}

/**
 * Obtains the menus for the given menu ids.
 *
 * @param array $conditions
 *   (optional) An array with the following possible keys:
 *   - id: A unique id representing a specific menu or an array of
 *   ids.
 *   - access_id: A unique access id representing a specific
 *   workbench access group or an array of access ids.
 *   - path: A path string associated with a given meny or an array
 *   of path strings.
 *   - fast: An array key whose value should be NULL. When specified, this will
 *   perform a fast load. The fast load does not perform the additional
 *   (expensive) operations that build the menu.
 * @param string|null $keyed
 *   (optional) A string matching one of the following: 'id',
 *   'access_id'
 *   When this is NULL, the default behavior is to return the array
 *   exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array
 *   will use the specified key name.
 *
 * @return array
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_menus($conditions = array(), $keyed = NULL) {
  if (!is_array($conditions)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_array('conditions');
    }

    return array();
  }

  $query = db_select('workbench_menus', 'wm');
  $query->innerjoin('workbench_access', 'wa', 'wm.access_id = wa.access_id');
  $query->fields('wm');

  $query->orderBy('weight', 'ASC');
  $query->orderBy('id', 'ASC');

  $and = db_and();
  $and->condition('wa.access_type', 'taxonomy');

  if (isset($conditions['id'])) {
    if (is_numeric($conditions['id'])) {
      $and->condition('id', $conditions['id']);
    }
    elseif (is_array($conditions['id']) && !empty($conditions['id'])) {
      $and->condition('id', $conditions['id'], 'IN');
    }
  }

  if (isset($conditions['access_id'])) {
    if (is_numeric($conditions['access_id'])) {
      $and->condition('wm.access_id', $conditions['access_id']);
    }
    elseif (is_array($conditions['access_id']) && !empty($conditions['access_id'])) {
      $and->condition('wm.access_id', $conditions['access_id'], 'IN');
    }
  }

  if (isset($conditions['path'])) {
    if (is_string($conditions['path'])) {
      $and->condition('path', $conditions['path']);
    }
    elseif (is_array($conditions['path']) && !empty($conditions['path'])) {
      $and->condition('path', $conditions['path'], 'IN');
    }
  }

  $query->condition($and);
  $menus = array();

  if ($keyed == 'id' || $keyed == 'access_id') {
    try {
      $records = $query->execute();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }

      return array();
    }

    foreach ($records as $record) {
      if (!is_object($record)) continue;

      $menus[$record->$keyed] = $record;
    }
  }
  else {
    try {
      $menus = (array) $query->execute()->fetchAll();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }
    }
  }

  // load all menu additional menu data
  if (!empty($menus) && !array_key_exists('fast', $conditions)) {
    $static_menus = &drupal_static(__FUNCTION__, NULL);

    if (is_null($static_menus)) {
      $static_menus = array('menu' => array(), 'access_id' => array());
    }

    foreach ($menus as &$menu) {
      if (isset($static_menus['menu'][$menu->id])) {
        $menu = $static_menus['menu'][$menu->id];
        continue;
      }
      else {
        $static_menus['menu'][$menu->id] = &$menu;
      }

      $menu->items = (array) workbench_menu_get_load_menu_items(array('menu_id' => $menu->id), 'id');

      // only load the taxonomy name to get the term name if one is not already defined in the breadcrumb name.
      if (empty($menu->breadcrumb_name)) {
        $taxonomy = taxonomy_term_load($menu->access_id);
        $menu->breadcrumb_name = $taxonomy->name;
      }

      $static_menus['menu'][$menu->id] = $menu;
      $static_menus['access_id'][$menu->access_id] = $menu->id;
    }
  }

  return $menus;
}

/**
 * Save the settings for one or more menus.
 *
 * This function clears the workbench_menu menu cache.
 *
 * @param array $item_ids
 *   An array of menu setting arrays with the following keys:
 *   - 'id': (optional) This is the primary key for a specific row in
 *   the workbench_menu table.
 *   - 'access_id': This is the unique access_id that represents the
 *   workbench access group to save.
 *   - 'path': This is the url path string of the menu.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function workbench_menu_save_menus($menus) {
  if (!is_array($menus)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_array('menus');
    }

    return FALSE;
  }

  if (empty($menus)) {
    return TRUE;
  }

  $static_menus = &drupal_static('workbench_menu_get_menus', NULL);
  $transaction = db_transaction();

  try {
    foreach ($menus as $key => &$menu) {
      if (!is_array($menu)) {
        if (class_exists('cf_error')) {
          cf_error::invalid_array('menus[' . $key . ']');
        }

        continue;
      }

      $query = db_select('workbench_menus', 'wm');
      $query->fields('wm');

      $record = array();
      $record['path'] = $menu['path'];
      $record['weight'] = $menu['weight'];
      $record['show_parents'] = $menu['show_parents'];
      $record['hidden'] = $menu['hidden'];
      $record['breadcrumb_name'] = $menu['breadcrumb_name'];

      if (isset($menu['id'])) {
        $record['id'] = $menu['id'];

        $query->condition('id', $menu['id']);

        $existing = (array) $query->execute()->fetchAll();

        if (empty($existing)) {
          unset($record['id']);
        }

        unset($query);
      }
      elseif (isset($menu['access_id'])) {
        $record['access_id'] = $menu['access_id'];

        $query->condition('access_id', $menu['access_id']);

        $existing = (array) $query->execute()->fetchAll();

        if (!empty($existing)) {
          $row = array_pop($existing);
          $record['id'] = $row->id;
        }

        unset($query);
      }

      if (isset($record['id'])) {
        $rx = drupal_write_record('workbench_menus', $record, array('id'));
      }
      else {
        drupal_write_record('workbench_menus', $record);
      }

      foreach ($menu['items'] as &$menu_item) {
        $record = array();

        $record['menu_id'] = $menu_item['menu_id'];
        $record['parent_id'] = $menu_item['parent_id'];
        $record['properties'] = $menu_item['properties'];

        if (property_exists($menu_item, 'id')) {
          $record['id'] = $menu_item['id'];
          drupal_write_record('workbench_menu_items', $record, array('id'));
        }
        else {
          drupal_write_record('workbench_menu_items', $record);
        }
      }

      if (isset($menu['id'])) {
        $static_menus['menu'][$menu['id']] = $menu;
      }
      elseif (isset($menu['access_id'])) {
        $query = db_select('workbench_menus', 'wm');
        $query->fields('wm');
        $query->condition('access_id', $menu['access_id']);

        $records = (array) $query->execute()->fetchAll();

        if (!empty($records)) {
          $record = array_pop($records);
          $static_menus['menu'][$record->id] = $menu;
        }
      }
    }

    // enforce transaction execution
    unset($transaction);
  }
  catch (Exception $e) {
    $transaction->rollback();

    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }

    return FALSE;
  }

  return TRUE;
}

/**
 * Loads menu items from the database based on the given conditions.
 *
 * @param array $conditions
 *   (optional) An array with the following possible keys:
 *   - 'id' A unique id representing a specific item or an array of
 *   ids.
 *   - 'menu_id' A unique menu id representing a specific menu or an
 *   array of menu ids.
 *   - 'parent_id' A unique parent id representing a specific parent
 *   or an array of parent ids.
 *   - 'human_name' A human name string of a menu item or an array of
 *   human name strings.
 *   - 'weight' A number representing the weight or an array of
 *   weight numbers.
 * @param string|null $keyed
 *   (optional) A string matching one of the following: 'id',
 *   'menu_id'.
 *   When this is NULL, the default behavior is to return the array
 *   exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array
 *   will use the specified key name.
 *
 * @return array
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_load_menu_items($conditions = array(), $keyed = NULL) {
  $sorted_menu_items = array();
  $sorted_menu_items['flat'] = array();
  $sorted_menu_items['nested'] = array();

  if (!is_array($conditions)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_array('conditions');
    }

    return $sorted_menu_items;
  }

  $query = db_select('workbench_menu_items', 'wmi');
  $query->fields('wmi');

  $query->orderBy('wmi.parent_id', 'ASC');
  $query->orderBy('wmi.weight', 'ASC');
  $query->orderBy('wmi.human_name', 'ASC');
  $query->orderBy('wmi.id', 'ASC');

  foreach (array('e' => 'expand', 'it' => 'item_type') as $key => $name) {
    $results = array();
    $wmo = 'wmko' . $key;
    $wm = 'wmk' . $key;

    $query->innerjoin('workbench_menu_' . $name . 's',  $wm, 'wmi.id = ' . $wm . '.item_id');
    $query->innerjoin('workbench_menu_options_' . $name,  $wmo, $wm . '.' . $name . '_id = ' . $wmo . '.id');
    $query->addField($wmo, 'id', $name . '_id');
    $query->addField($wmo, 'machine_name', $name . '_machine_name');
    $query->addField($wmo, 'human_name', $name . '_human_name');
    $query->addField($wmo, 'description', $name . '_description');
  }

  $and = db_and();

  if (isset($conditions['id'])) {
    if (is_numeric($conditions['id'])) {
      $and->condition('wmi.id', $conditions['id']);
    }
    elseif (is_array($conditions['id']) && !empty($conditions['id'])) {
      $and->condition('wmi.id', $conditions['id'], 'IN');
    }
  }

  if (isset($conditions['menu_id'])) {
    if (is_numeric($conditions['menu_id'])) {
      $and->condition('wmi.menu_id', $conditions['menu_id']);
    }
    elseif (is_array($conditions['menu_id']) && !empty($conditions['menu_id'])) {
      $and->condition('wmi.menu_id', $conditions['menu_id'], 'IN');
    }
  }

  if (isset($conditions['parent_id'])) {
    if (is_numeric($conditions['parent_id'])) {
      $and->condition('wmi.parent_id', $conditions['parent_id']);
    }
    elseif (is_array($conditions['parent_id']) && !empty($conditions['parent_id'])) {
      $and->condition('wmi.parent_id', $conditions['parent_id'], 'IN');
    }
  }

  if (isset($conditions['weight'])) {
    if (is_numeric($conditions['weight'])) {
      $and->condition('wmi.weight', $conditions['weight']);
    }
    elseif (is_array($conditions['weight']) && !empty($conditions['weight'])) {
      $and->condition('wmi.weight', $conditions['weight'], 'IN');
    }
  }

  if (isset($conditions['human_name'])) {
    if (is_string($conditions['human_name'])) {
      $and->condition('wmi.human_name', $conditions['human_name']);
    }
    elseif (is_array($conditions['human_name']) && !empty($conditions['human_name'])) {
      $and->condition('wmi.human_name', $conditions['human_name'], 'IN');
    }
  }

  $query->condition($and);
  $menu_items = array();

  if ($keyed == 'id' || $keyed == 'menu_id') {
    try {
      $records = $query->execute();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }

      return $sorted_menu_items;
    }

    foreach ($records as $record) {
      if (!is_object($record)) continue;

      $menu_items[$record->$keyed] = $record;
    }
  }
  else {
    try {
      $menu_items = (array) $query->execute()->fetchAll();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }
    }
  }

  if (!empty($menu_items)) {
    foreach ($menu_items as $menu_item_key => &$menu_item) {
      $id = $menu_item->id;

      if (isset($sorted_menu_items['flat'][$id]) && isset($sorted_menu_items['flat'][$id]['item']) && is_object($sorted_menu_items['flat'][$id]['item'])) {
        foreach (array('expand', 'item_type') as $name) {
          $results = new stdClass();
          $results->id = $menu_item->{$name . '_id'};
          $results->machine_name = $menu_item->{$name . '_machine_name'};
          $results->human_name = $menu_item->{$name . '_human_name'};
          $results->description = $menu_item->{$name . '_description'};

          unset($menu_item->{$name . '_id'});
          unset($menu_item->{$name . '_machine_name'});
          unset($menu_item->{$name . '_human_name'});
          unset($menu_item->{$name . '_description'});

          array_push($sorted_menu_items['flat'][$id]['item']->$name, $results);
        }

        continue;
      }

      foreach (array('expand', 'item_type') as $name) {
        $results = new stdClass();
        $results->id = $menu_item->{$name . '_id'};
        $results->machine_name = $menu_item->{$name . '_machine_name'};
        $results->human_name = $menu_item->{$name . '_human_name'};
        $results->description = $menu_item->{$name . '_description'};

        unset($menu_item->{$name . '_id'});
        unset($menu_item->{$name . '_machine_name'});
        unset($menu_item->{$name . '_human_name'});
        unset($menu_item->{$name . '_description'});

        $menu_item->$name = array($results);
      }

      $sorted_menu_items['flat'][$id] = array();
      $sorted_menu_items['flat'][$id]['children'] = array();
      $sorted_menu_items['flat'][$id]['item'] = $menu_item;

      if ($menu_item->parent_id == 0) {
        $sorted_menu_items['nested'][$id] = &$sorted_menu_items['flat'][$id];
      }
      else {
        if (!isset($sorted_menu_items['flat'][$menu_item->parent_id])) {
          $sorted_menu_items['flat'][$menu_item->parent_id] = array();
          $sorted_menu_items['flat'][$menu_item->parent_id]['children'] = array();
        }

        $sorted_menu_items['flat'][$menu_item->parent_id]['children'][$id] = &$sorted_menu_items['flat'][$id];
      }

      $menu_item->properties = unserialize($menu_item->properties);
    }
  }

  return $sorted_menu_items;
}

/**
 * Obtains a select list of for menu items loaded from the database.
 *
 * @param array $conditions
 *   (optional)An array that is passed directly to
 *   workbench_menu_get_load_menu_items().
 * @param string|null $keyed
 *   (optional) A string that is passed directly to
 *   workbench_menu_get_load_menu_items().
 *
 * @return array
 *   A processed array select list of menu objects for the given
 *   node.
 *
 * @see workbench_menu_get_load_menu_items()
 */
function workbench_menu_get_load_menu_items_select_list_options($conditions = array(), $keyed = NULL) {
  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (is_null($options_list)) {
    $items = (array) workbench_menu_get_load_menu_items($conditions, $keyed);

    foreach ($items['flat'] as &$i) {
      $available_parents[$i['item']->id] = $i['item']->human_name;
    }

    $data = array();
    $data['options'] = array('0' => "<No Parent>");

    foreach ($items['nested'] as &$nested_item) {
      workbench_menu_get_load_menu_items_select_list_options_recursive_walk($nested_item, $data);
    }

    $options_list = $data['options'];
  }

  return $options_list;
}

/**
 * Load menu item children.
 *
 * This function is recursive.
 *
 * @param object $item
 *   The menu item object.
 * @param array $data
 *   An array of data globally shared between the different recursive calls.
 *
 * @see workbench_menu_get_load_menu_items_select_list_options()
 */
function workbench_menu_get_load_menu_items_select_list_options_recursive_walk(&$item, &$data) {
  if (!isset($data['depth'])) {
    $data['depth'] = 0;
  }

  $item_id = & $item['item']->id;

  if ($data['depth'] > 0) {
    $data['options'][$item_id] = str_repeat('- ', $data['depth']) . $item['item']->human_name;
  }
  else {
    $data['options'][$item_id] = $item['item']->human_name;
  }

  if (!empty($item['children'])) {
    $data['depth']++;

    foreach ($item['children'] as &$child) {
      workbench_menu_get_load_menu_items_select_list_options_recursive_walk($child, $data);
    }

    $data['depth']--;
  }
}

/**
 * Validate that a user has menu edit access.
 *
 * @param string|null $access_type
 *   The type of access requested (e.g. taxonomy).
 *   If NULL is passed, then this simply returnes whether or not the
 *   user has 'edit workbench menu' access.
 *
 * @param int|null $access_id
 *   The access_id to validate against.
 *   If NULL is passed, then this simply returnes whether or not the
 *   user has 'edit workbench menu' access.
 *
 * @see workbench_access_get_access_tree()
 */
function workbench_menu_edit_access($access_type = NULL, $access_id = NULL) {
  if (user_access('admin workbench menu')) {
    return TRUE;
  }

  if ($access_type == NULL || $access_id == NULL) {
    return user_access('edit workbench menu');
  }

  if (!user_access('edit workbench menu')) return FALSE;

  if ($access_type == 'taxonomy') {
    $access = workbench_access_get_access_tree();

    if (array_key_exists($access_id, $access)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Clears the workbench menu cache for the menu cache for some path.
 *
 * @param string $path
 *   A string representing the path to clear.
 */
function workbench_menu_clear_cache_at_path($path) {
  $parts = explode('/', $path);
  $menu_cache_id = 'workbench_menu-menus_at-' . $parts[0];
  $breadcrumb_cache_id = 'workbench_menu-breadcrumbs_at-' . $parts[0];

  $cached_menu = cache_get($menu_cache_id, 'cache_menu');
  $cached_breadcrumb = cache_get($breadcrumb_cache_id, 'cache_menu');

  while (!empty($parts)) {
    $subpath = implode('/', $parts);
    $part = array_pop($parts);

    if (empty($part)) continue;

    if ($cached_menu) {
      $menus_cached = $cached_menu->data;
      unset($menus_cached[$subpath]);
    }

    if ($cached_breadcrumb) {
      $breadcrumbs_cached = $cached_breadcrumb->data;
      unset($breadcrumbs_cached[$subpath]);
    }
  }

  if ($cached_menu) {
    cache_set($menu_cache_id, $menus_cached, 'cache_menu');
  }

  if ($cached_breadcrumb) {
    cache_set($menu_cache_id, $breadcrumbs_cached, 'cache_menu');
  }
}

/**
 * Generates the JS array for workbench node id autocomplete fields.
 *
 * This pulls the first 15 results that match the specified string.
 *
 * @param string $string
 *   A string to match node titles against.
 * @return array
 *   An array of string matches.
 */
function workbench_menu_autocomplete_nid($string) {
  if (!is_string($string)) {
    if (class_exists('cf_error')) {
      cf_error::not_string('string');
    }

    return array();
  }

  // do not allow anonymous to utilize this jquery search
  $user = cf_current_user();
  if ($user->uid == 0) {
    return array();
  }

  $matches = array();
  $results = db_query_range('SELECT nid, title FROM {node} WHERE LOWER(title) LIKE LOWER(:string) ORDER BY title', 0, 9, array(':string' => db_like($string) . '%'));

  foreach ($results as $result) {
    $name = $result->title . ' [nid: ' . $result->nid . ']';
    $matches[$name] = check_plain($name);
  }

  if (count($matches) < 9) {
    $results = db_query_range('SELECT nid, title FROM {node} WHERE LOWER(title) LIKE LOWER(:string) ORDER BY title', 0, 9 - count($matches), array(':string' => '%' . db_like($string) . '%'));

    foreach ($results as $result) {
      $name = $result->title . ' [nid: ' . $result->nid . ']';
      $matches[$name] = check_plain($name);
    }
  }

  if (module_exists('devel')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }

  drupal_json_output($matches);
}

/**
 * Generates the JS array for workbench file id autocomplete fields.
 *
 * This pulls the first 10 results that match the specified string.
 *
 * @param string $string
 *   A string to match node titles against.
 * @return array
 *   An array of string matches.
 */
function workbench_menu_autocomplete_fid($string) {
  if (!is_string($string)) {
    if (class_exists('cf_error')) {
      cf_error::not_string('string');
    }

    return array();
  }

  // do not allow anonymous to utilize this jquery search
  $user = cf_current_user();
  if ($user->uid == 0) {
    return array();
  }

  // only allowed wrappers are processed
  $wrappers = file_get_stream_wrappers(STREAM_WRAPPERS_READ | STREAM_WRAPPERS_VISIBLE);
  if (empty($wrappers)) {
    return array();
  }

  try {
    $or = db_or();
    foreach ($wrappers as $w => &$wrapper) {
      $or->condition('fm.uri', db_like($w) . '://%', 'LIKE');
    }

    $lstring = drupal_strtolower($string);

    $query = db_select('file_managed', 'fm');

    $query->fields('fm', array('fid', 'filename'));
    $query->condition('fm.filename', db_like($lstring) . '%', 'LIKE');
    $query->condition('fm.status', 1);
    $query->condition($or);
    $query->range(0, 9);

    $matches = array();
    $results = $query->execute();

    foreach ($results as $result) {
      $name = $result->filename . ' [fid: ' . $result->fid . ']';
      $matches[$name] = check_plain($name);
    }

    if (count($matches) < 9) {
      $query->condition('fm.filename', '%' . db_like($lstring) . '%', 'LIKE');
      $query->condition($or);
      $query->condition('fm.status', 1);
      $query->range(0, 9 - count($matches));

      $results = $query->execute();

      foreach ($results as $result) {
        $name = $result->filename . ' [fid: ' . $result->fid . ']';
        $matches[$name] = check_plain($name);
      }
    }
  }
  catch (Exception $e) {
    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }

    return array();
  }

  if (module_exists('devel')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }

  drupal_json_output($matches);
}

/**
 * Generates the JS array for workbench menu id autocomplete fields.
 *
 * This pulls the first 10 results that match the specified string.
 *
 * @param string $string
 *   A string to match node titles against.
 * @return array
 *   An array of string matches.
 */
function workbench_menu_autocomplete_menu_id($string) {
  if (!is_string($string)) {
    if (class_exists('cf_error')) {
      cf_error::not_string('string');
    }

    return array();
  }

  // do not allow anonymous to utilize this jquery search
  $user = cf_current_user();
  if ($user->uid == 0) {
    return array();
  }

  $query_string = 'SELECT ttd.name AS name, wm.id AS id FROM {taxonomy_term_data} AS ttd INNER JOIN {workbench_menus AS wm ON ttd.tid = CAST(wm.access_id AS integer) WHERE LOWER(name) LIKE LOWER(:string) ORDER BY name';

  $matches = array();
  $results = db_query_range($query_string, 0, 9, array(':string' => db_like($string) . '%'));

  foreach ($results as $result) {
    $name = $result->name . ' [id: ' . $result->id . ']';
    $matches[$name] = check_plain($name);
  }

  if (count($matches) < 9) {
    $results = db_query_range($query_string, 0, 9 - count($matches), array(':string' => '%' . db_like($string) . '%'));

    foreach ($results as $result) {
      $name = $result->name . ' [id: ' . $result->id . ']';
      $matches[$name] = check_plain($name);
    }
  }

  if (module_exists('devel')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }

  drupal_json_output($matches);
}

/**
 * Generates the JS array for workbench menu item id autocomplete fields.
 *
 * This pulls the first 10 results that match the specified string.
 *
 * @param string $string
 *   A string to match node titles against.
 * @return array
 *   An array of string matches.
 */
function workbench_menu_autocomplete_menu_item_id($string) {
  if (!is_string($string)) {
    if (class_exists('cf_error')) {
      cf_error::not_string('string');
    }

    return array();
  }

  // do not allow anonymous to utilize this jquery search
  $user = cf_current_user();
  if ($user->uid == 0) {
    return array();
  }

  $query_string = 'SELECT wmi.id, wmi.human_name FROM {workbench_menu_items} wmi inner join {workbench_menu_item_types} wmit on wmi.id = wmit.item_id left join workbench_menu_options_item_type wmoit on wmit.item_type_id = wmoit.id WHERE LOWER(wmi.human_name) LIKE LOWER(:string) AND NOT (wmoit.machine_name = \'item_menu\' OR wmoit.machine_name = \'item_menu_item\') ORDER BY wmi.human_name';

  $matches = array();
  $results = db_query_range($query_string, 0, 9, array(':string' => db_like($string) . '%'));

  foreach ($results as $result) {
    $name = $result->human_name . ' [id: ' . $result->id . ']';
    $matches[$name] = check_plain($name);
  }

  if (count($matches) < 9) {
    $results = db_query_range($query_string, 0, 9, array(':string' => '%' . db_like($string) . '%'));

    foreach ($results as $result) {
      $name = $result->human_name . ' [id: ' . $result->id . ']';
      $matches[$name] = check_plain($name);
    }
  }

  if (module_exists('devel')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }

  drupal_json_output($matches);
}

/**
 * Perform a db check to see if a menu with the given id exists.
 *
 * @param int $menu_id
 *   The numeric id for the given menu.
 * @param int $is_access_id
 *   (optional) If set to TRUE, then the menu_id is instead an access_id.
 *
 * @return bool|null
 *   Returns TRUE/FALSE if the item exists and NULL on error.
 */
function workbench_menu_menu_exists($menu_id = NULL, $is_access_id = FALSE) {
  if (!is_numeric($menu_id)) {
    if (class_exists('cf_error')) {
      cf_error::not_numeric('menu_id');
    }

    return NULL;
  }

  if (!is_bool($is_access_id)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_bool('is_access_id');
    }

    return NULL;
  }

  $query = db_select('workbench_menus', 'wm');

  $query->fields('wm');

  if ($is_access_id) {
    $query->condition('wm.access_id', $menu_id);
  }
  else {
    $query->condition('wm.id', $menu_id);
  }

  $executed = $query->execute();

  return $executed->rowCount() > 0;
}

/**
 * Perform a db check to see if a menu item with the given id exists.
 *
 * When a menu id is specified, then this returns TRUE/FALSE depending on
 * whether or not that item exists and is associated with the specified menu.
 *
 * @param int $item_id
 *   The numeric id for the given menu item.
 * @param int $menu_id
 *   (optional) numeric id for the given menu.
 * @param int $is_access_id
 *   (optional) If set to TRUE, then the menu_id is instead an access_id.
 *
 * @return bool|null
 *   Returns TRUE/FALSE if the item exists and NULL on error.
 */
function workbench_menu_menu_item_exists($item_id, $menu_id = NULL, $is_access_id = FALSE) {
  if (!is_numeric($item_id)) {
    if (class_exists('cf_error')) {
      cf_error::not_numeric('item_id');
    }

    return NULL;
  }

  $query = db_select('workbench_menu_items', 'wmi');
  $query->fields('wmi');
  $query->condition('wmi.id', $item_id);

  if (!is_null($menu_id)) {
    if (!is_numeric($menu_id)) {
      if (class_exists('cf_error')) {
        cf_error::not_numeric('menu_id');
      }

      return NULL;
    }

    if (!is_bool($is_access_id)) {
      if (class_exists('cf_error')) {
        cf_error::invalid_bool('is_access_id');
      }

      return NULL;
    }

    if ($is_access_id) {
      $query->innerjoin('workbench_menus', 'wm', 'wm.id = wmi.menu_id');
      $query->condition('wm.access_id', $menu_id);
    }
    else {
      $query->condition('wmi.menu_id', $menu_id);
    }
  }

  $executed = $query->execute();

  return $executed->rowCount() > 0;
}
