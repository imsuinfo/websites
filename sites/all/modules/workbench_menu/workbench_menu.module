<?php

/**
 * @file
 * Module file for the workbench menu project.
 */

/**
 * Implements hook_help().
 */
function workbench_menu_help($path, $arg) {
  $output = '';

  switch ($path) {
    case "admin/help#workbench_menu":
      $output .= '<p>' . t("This module provides an alternative menuing system to the one provided by drupal. This utilizes the access control system provided by workbench_access. The only access type supported at this time is taxonomy.") . '</p>';
      return $output;
  }
}

/**
 * Implements hook_permission().
 */
function workbench_menu_permission() {
  $permissions = array();

  $permissions['edit workbench menu'] = array(
    'title' => t("Edit Workbench Menu"),
    'description' => t("Grants permissions to alter any workbench menus in which a user is in the workbench access section associated with that menu."),
  );

  $permissions['change workbench menu path'] = array(
    'title' => t("Change Workbench Menu Path"),
    'description' => t("Grants permissions to alter the menu path for any workbench menus in which a user is able to edit."),
  );

  $permissions['administer workbench menu'] = array(
    'title' => t("Administer Workbench Menu"),
    'description' => t("Grants permissions to alter all workbench menus and perform administrative tasks."),
  );

  return $permissions;
}

/**
 * Implements hook_menu().
 */
function workbench_menu_menu() {
  $items = array();

  $items['admin/config/workbench/access/menus'] = array(
    'title' => "Menus",
    'description' => "Settings for workbench menus.",
    'page callback' => 'workbench_menu_admin_settings',
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'user_access',
    'access arguments' => array('administer workbench menu'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/config/workbench/access/menus/%/%/items'] = array(
    'title' => "Menu Items",
    'description' => "Settings for workbench menus items.",
    'page callback' => 'workbench_menu_admin_item_settings',
    'page arguments' => array(5, 6),
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'user_access',
    'access arguments' => array('administer workbench menu'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  $items['admin/workbench/menus'] = array(
    'title' => "My Menus",
    'description' => "Settings for workbench menus you have access to alter.",
    'page callback' => 'workbench_menu_edit_settings',
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'workbench_menu_edit_access',
    'access arguments' => array(3, 4),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/workbench/menus/%/%/items'] = array(
    'title' => "Menu Items",
    'description' => "Settings for workbench menus items.",
    'page callback' => 'workbench_menu_edit_item_settings',
    'page arguments' => array(3, 4),
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'workbench_menu_edit_access',
    'access arguments' => array(3, 4),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  return $items;
}

/**
 * Implements hook_workbench_access_save().
 */
function workbench_menu_workbench_access_save($section){
  if (variable_get('workbench_access', 'taxonomy') != 'taxonomy') {
    return;
  }

  if (!is_numeric($section['access_id'])){
    return;
  }

  $query = db_insert('workbench_menus');
  $query->fields(array('access_id' => $section['access_id'], 'path' => ''));
  $query->execute();
}

/**
 * Implements hook_workbench_access_delete().
 */
function workbench_menu_workbench_access_delete($section){
  if (variable_get('workbench_access', 'taxonomy') != 'taxonomy') {
    return;
  }

  if (!is_numeric($section['access_id'])){
    return;
  }

  $query = db_select('workbench_menu_items', 'wmi');
  $query->innerjoin('workbench_menus',  'wm', 'wm.id = mni.menu_id');
  $query->fields('wmi', array('id'));
  $query->condition('wm.access_id', $section['access_id']);

  try {
    $records = (array) $query->execute()->fetchAll();

    if (empty($records)){
      return;
    }

    foreach ($records as &$record){
      foreach (array('expand', 'item_type') as $name){
        $query = db_delete('workbench_menu_' . $name . 's', 'wmn');
        $query->condition('wmn.item_id', $record->id);
        $query->execute();
      }
    }

    $query = db_delete('workbench_menu_items');
    $query->condition('item_id', $record->id);
    $query->execute();

    $query = db_delete('workbench_menus');
    $query->condition('access_id', $section['access_id']);
    $query->execute();
  }
  catch (Exception $e) {
    cf_error_on_query_execution($function_history, $e);

    return array();
  }
}

/**
 * Implements hook_theme().
 */
function workbench_menu_theme($existing, $type, $theme, $path) {
  $themes = array();

  $themes['workbench_menu_admin_settings_form'] = array(
    'render element' => 'form',
    'file' => 'workbench_menu.admin.inc',
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $themes['workbench_menu_edit_settings_form'] = array(
    'render element' => 'form',
    'file' => 'workbench_menu.admin.inc',
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  return $themes;
}

/**
 * Implements hook_block_info().
 */
function workbench_menu_block_info() {
  $blocks = array();

  $blocks['workbench_menu_block'] = array(
    'info' => t("Workbench Menu"),
    'weight' => -1,
    'status' => 1,
    'region' => 'sidebar_first',
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function workbench_menu_block_view($delta = ''){
  cf_error_append_history($function_history, __FUNCTION__);

  $path = request_path();

  if (empty($path)){
    return array();
  }

  $path_parts = explode('/', $path);

  if (count($path_parts) == 0){
    return array();
  }

  // @todo: consider cacheing the entire process below into static and database such that the loaded data need not be processed again.
  // @todo: once this is done, consider removing the menu caching code from the menu load function.

  $menus = workbench_menu_get_menus_at_path($path, $function_history);

  // load the workbench menus for /node/[nid]/* paths as well
  if (empty($menus)){
    $node = menu_get_object();

    if (is_object($node) && property_exists($node, 'nid') && property_exists($node, 'vid')){
      $menus = workbench_menu_get_menus_at_node($node, $function_history);
    }

    if (empty($menus)){
      return array();
    }
  }

  $menu_markup = '';
  $breadcrumbs = array();

  $menu_even = TRUE;
  $menu_total = count($menus);
  $menu_current = 0;

  foreach ($menus as &$menu){
    $reversed_path_parts = array_reverse($path_parts);
    $combined_path = '';
    $depth = 1;

    foreach ($path_parts as &$path_part){
      $combined_path .= $path_part;

      if ($combined_path == $menu->path){
        $count = 0;
        while ($count < $depth){
          array_pop($reversed_path_parts);
          $count++;
        }

        array_push($reversed_path_parts, '<top>');
        break;
      }

      $combined_path .= '/';
      $depth++;
    }

    if (empty($menu->items['nested'])){
      // when at the top-level path for some group, provide that group path as a link instead of using an empty breadcrumb.
      // @todo provide an administrative interface for defining how things like this can be handled.
      // @todo handle multiple menus that may conflict with each other for assigning the breadcrumb
      if ($path == $menu->path){
        $breadcrumbs = array(l(t($menu->taxonomy->name), $menu->path));
      }

      continue;
    }

    $list = array();
    $list['items'] = array();
    $list['type'] = 'ul';

    $item_variables = array();
    $item_variables['even'] = TRUE;
    $item_variables['local_even'] = TRUE;
    $item_variables['total'] = count($menu->items['flat']);
    $item_variables['current'] = 0;
    $item_variables['row'] = 0;
    $item_variables['depth'] = 0;
    $item_variables['menu'] = &$menu;
    $item_variables['reverse_path'] = $reversed_path_parts;
    $item_variables['complete_path'] = implode('/', $path_parts);
    $item_variables['current_trail'] = &$breadcrumbs;
    $item_variables['trail_path'] = '';
    $item_variables['loaded_menus'] = array($menu->access_id => &$menu);
    $item_variables['process_children'] = TRUE;

    foreach ($menu->items['nested'] as &$item){
      $list_items = workbench_menu_block_view_recursively_build_menu($item, $item_variables, $function_history);

      if (!empty($list_items)){
        foreach ($list_items as &$list_item){
          $list['items'][] = $list_item;
        }
      }
    }

    // when at the top-level path for some group, provide that group path as a link instead of using an empty breadcrumb.
    // @todo provide an administrative interface for defining how things like this can be handled.
    // @todo handle multiple menus that may conflict with each other for assigning the breadcrumb
    if ($path == $menu->path){
      $breadcrumbs = array(l(t($menu->taxonomy->name), $menu->path));
    }

    $menu_even = !$menu_even;
    $menu_current++;

    $menu_classes = 'workbench_menu-menu menu';
    $menu_classes .= ' workbench_menu-menu-' . ($menu_even ? 'even even' : 'odd odd');
    $menu_classes .= ' workbench_menu-menu-row_' . $menu_current;

    $menu_wrapper_classes = 'workbench_menu-menu_wrapper';
    $menu_wrapper_classes .= ' workbench_menu-menu_wrapper-' . ($menu_even ? 'even' : 'odd');
    $menu_wrapper_classes .= ' workbench_menu-menu_wrapper-row_' . $menu_current;

    if ($menu_current == 1){
      $menu_classes .= ' workbench_menu-menu-first';
      $menu_wrapper_classes .= ' workbench_menu-menu_wrapper-first first';
    }

    if ($menu_current == $menu_total){
      $menu_classes .= ' workbench_menu-menu-last';
      $menu_wrapper_classes .= ' workbench_menu-menu_wrapper-last last';
    }

    $list['attributes'] = array('id' => 'workbench_menu-menu_' . check_plain($menu->id), 'class' => $menu_classes);

    $menu_markup .= '<div id="workbench_menu-menu_wrapper-' . check_plain($menu->id) . '" class="' . $menu_wrapper_classes . '">' . theme('item_list', $list) . '</div>';
  }

  if (!empty($breadcrumbs)){
    drupal_set_breadcrumb($breadcrumbs);
  }

  if (empty($menu_markup)){
    return array();
  }

  $block = array();
  $block['subject'] = '';
  $block['content'] = array(
    '#markup' => $menu_markup,
    '#attached' => array(
      'css' => array(drupal_get_path('module', 'workbench_menu') . '/includes/workbench_menu.css'),
    ),
  );

  return $block;
}

/**
 * Recursively walkthrough the nested menu items to construct the entire menu.
 *
 * @param $function_history (optional)
 *   An array of function names, ie: array('0' => 'my_function_name').
 */
function workbench_menu_block_view_recursively_build_menu(&$item, $variables, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  $type = '';
  foreach ($item['item']->item_type as &$t){
    $type = $t->machine_name;
    break;
  }

  $list_items = array();
  $list_item = array();
  $expand_children = TRUE;
  $expand_auto = FALSE;
  $external_link = FALSE;
  $item_classes = 'workbench_menu-menu_item';
  $current_path = '';
  $active_trail = FALSE;
  $active = FALSE;

  foreach ($item['item']->expand as &$expand){
    // if the item has no visibility, then..
    if ($expand->machine_name === 'expand_never'){
      $expand_children = FALSE;
    }
    else if ($expand->machine_name === 'expand_auto'){
      $expand_auto = TRUE;
    }

    break;
  }

  if (!empty($item['item']->active_path)){
    if (preg_match('@^/@i', $item['item']->active_path) == 0){
      if (!empty($variables['reverse_path'])){
        $current_path = array_pop($variables['reverse_path']);

        if (!empty($current_path)){
          if ($current_path == $item['item']->active_path){
            $active_trail = TRUE;

            if (empty($variables['reverse_path']) || empty($item['children'])){
              $active = TRUE;
              $variables['active'] = TRUE;
            }
          }
          else {
            if (!empty($variables['reverse_path'])){
              $depth = 1;
              $combined_path = $current_path . '/';

              foreach ($variables['reverse_path'] as &$path_part){
                $combined_path .= $path_part;

                if ($combined_path == $item['item']->active_path){
                  $active_trail = TRUE;

                  $count = 0;
                  while ($count < $depth){
                    array_pop($variables['reverse_path']);
                    $count++;
                  }

                  if (empty($variables['reverse_path']) || empty($item['children'])){
                    $active = TRUE;
                    $variables['active'] = TRUE;
                  }

                  break;
                }

                $combined_path .= '/';
                $depth++;
              }
            }
          }
        }
      }

      if ($item['item']->active_path == '<top>'){
        $variables['trail_path'] .= $variables['menu']->path;
      }
      else {
        $variables['trail_path'] .= '/' . $item['item']->active_path;
      }
    }
    else {
      $current_path = $variables['menu']->path . $item['item']->active_path;
      $variables['trail_path'] = $current_path;

      if ($current_path == $variables['complete_path']){
        $active_trail = TRUE;
        $active = TRUE;
        $variables['active'] = TRUE;
      }
    }
  }

  if ($type != 'item_menu' && $type != 'item_menu_item' || (($type == 'item_menu' || $type == 'item_menu_item') && !$expand_children)){
    $variables['current_trail'][] = l(t($item['item']->human_name), $variables['trail_path']);
    $variables['even'] = !$variables['even'];
    $variables['local_even'] = !$variables['local_even'];
    $variables['current']++;
    $variables['row']++;
  }

  $item_classes .= ' workbench_menu-menu_item-type-' . $type;
  $item_classes .= ' ' . ($variables['even'] ? 'even' : 'odd');
  $item_classes .= ' local_' . ($variables['local_even'] ? 'even' : 'odd');
  $item_classes .= ' row_' . $variables['row'];
  $item_classes .= ' local_row_' . $variables['current'];
  $item_classes .= ' depth_' . $variables['depth'];

  if (!empty($item['children']) && $variables['process_children']){
    if ($expand_children){
      $child_variables = array();
      $active_child = FALSE;
      $current = 0;
      $child_variables['local_even'] = TRUE;
      $child_variables['even'] = &$variables['even'];
      $child_variables['row'] = &$variables['row'];
      $child_variables['total'] = count($item['children']);
      $child_variables['current'] = &$current;
      $child_variables['depth'] = $variables['depth'] + 1;
      $child_variables['menu'] = &$variables['menu'];
      $child_variables['reverse_path'] = $variables['reverse_path'];
      $child_variables['active'] = &$active_child;
      $child_variables['complete_path'] = &$variables['complete_path'];
      $child_variables['current_trail'] = &$variables['current_trail'];
      $child_variables['trail_path'] = $variables['trail_path'];
      $child_variables['loaded_menus'] = &$variables['loaded_menus'];
      $child_variables['process_children'] = TRUE;

      $list_item['children'] = array();

      foreach ($item['children'] as &$child){
        $child_lists = workbench_menu_block_view_recursively_build_menu($child, $child_variables, $function_history);

        if ($child_variables['active']){
          $active_trail = TRUE;
          $variables['active'] = TRUE;
        }

        if (!empty($child_lists)){
          foreach ($child_lists as &$child_list){
            $list_item['children'][] = &$child_list;
          }
        }
      }

      if (empty($list_item['children'])){
        unset($list_item['children']);
      }
      else {
        $item_classes .= ' menu';
      }
    }
  }

  if ($active_trail){
    $item_classes .= ' active-trail';
  }
  else {
    array_pop($variables['current_trail']);

    if ($expand_auto){
      $expand_children = FALSE;
    }
  }

  if ($active){
    $item_classes .= ' active';
    array_pop($variables['current_trail']);
  }

  if (!empty($list_item['children'])){
    if ($expand_children){
      $item_classes .= ' expanded';
    }
    else {
      $item_classes .= ' collapsed';
      unset($list_item['children']);
    }
  }
  else {
    $item_classes .= ' leaf';
  }

  switch ($type){
    case 'item_label':
      $list_item['data'] = '<span>' . check_plain($item['item']->human_name) . '</span>';

      if (isset($item['item']->properties['disabled']) && $item['item']->properties['disabled']){
        $item_classes .= ' disabled';
      }
      break;

    case 'item_link':
      $url_prefix = '';
      $prepend = '';
      $append = '';
      $tags = '';

      if ($active || $active_trail){
        $tags .= ' class="';

        if ($active_trail) $tags .= 'active-trail';
        if ($active) $tags .= ' active';

        $tags .= '"';
      }

      if ($item['item']->properties['url'] == '<top>'){
        $list_item['data'] = $prepend . '<a' . $tags . ' href="' . check_url('/' . $variables['menu']->path) . '">' . check_plain($item['item']->human_name) . '</a>';
      }
      else {
        if (valid_url($item['item']->properties['url'], TRUE)){
          $parsed_url = parse_url($item['item']->properties['url']);
          $remote_url = check_plain($parsed_url['host']);
          $prepend .= '<div class="workbench_menu-menu_item-icon workbench_menu-menu_item-icon_external"></div>';
          $tags .= ' title="' . t("This links to the external website: !remote_url.", array('!remote_url' => $remote_url)) . '"';
        }
        else {
          if (preg_match('@^(/|#)@', $item['item']->properties['url']) === 0){
            $url_prefix = '/' . $variables['menu']->path . '/';
          }
        }

        $list_item['data'] = $prepend . '<a' . $tags . ' href="' . check_url($url_prefix . $item['item']->properties['url']) . '">' . check_plain($item['item']->human_name) . '</a>' . $append;
      }
      break;

    case 'item_file':
      $url_prefix = '';
      $prepend = '';
      $append = '';
      $tags = '';

      if ($active || $active_trail){
        $tags .= ' class="';

        if ($active_trail) $tags .= 'active-trail';
        if ($active) $tags .= ' active';

        $tags .= '"';
      }

      $icon = check_plain($item['item']->properties['file_type']);
      $filename = check_plain(rawurldecode(basename($item['item']->properties['file'])));

      if (valid_url($item['item']->properties['file'], TRUE)){
        $parsed_url = parse_url($item['item']->properties['file']);
        $remote_url = check_plain($parsed_url['host']);
        $prepend .= '<div class="workbench_menu-menu_item-icon workbench_menu-menu_item-icon_' . $icon. '"></div>';
        $tags .= ' title="' . t("Download !filename from the external website: !remote_url.", array('!filename' => $filename, '!remote_url' => $remote_url)) . '"';
      }
      else {
        $prepend .= '<div class="workbench_menu-menu_item-icon workbench_menu-menu_item-icon_' . $icon. '"></div>';
        $tags .= ' title="' . t("Download !filename.", array('!filename' => $filename)) . '"';
      }

      $list_item['data'] = $prepend . '<a' . $tags . ' href="' . check_url($url_prefix . $item['item']->properties['file']) . '">' . check_plain($item['item']->human_name) . '</a>' . $append;
      break;

    case 'item_menu':
      $other_menus = (array) workbench_menu_get_menus(array('access_id' => $item['item']->properties['menu']), 'id', $function_history);
      $other_menu = array_pop($other_menus);

      // under no circumstances should a menu be recursively processed more than once.
      if (array_key_exists($other_menu->access_id, $variables['loaded_menus'])){
        return array();
      }

      $variables['loaded_menus'][$other_menu->access_id] = &$other_menu;
      $item_variables['menus_processed'][] = $item['item']->properties['menu'];

      // recursively walk through the other menu
      $other_current = 0;
      $child_variables = array();
      $child_variables['local_even'] = TRUE;
      $child_variables['even'] = &$variables['even'];
      $child_variables['row'] = &$variables['row'];
      $child_variables['total'] =  count($other_menu->items['flat']);
      $child_variables['current'] = &$other_current;
      $child_variables['depth'] = $variables['depth'];
      $child_variables['menu'] = &$other_menu;
      $child_variables['reverse_path'] = $variables['reverse_path'];
      $child_variables['active'] = FALSE;
      $child_variables['complete_path'] = &$variables['complete_path'];
      $child_variables['current_trail'] = &$variables['current_trail'];
      $child_variables['trail_path'] = $variables['trail_path'];
      $child_variables['loaded_menus'] = &$variables['loaded_menus'];
      $child_variables['process_children'] = $expand_children;

      if (!empty($other_menu->items['nested'])){
        foreach ($other_menu->items['nested'] as &$child){
          $child_items = workbench_menu_block_view_recursively_build_menu($child, $child_variables, $function_history);

          if (!empty($child_items)){
            foreach ($child_items as &$child_item){
              $list_items[] = &$child_item;
            }
          }
        }
      }

      return $list_items;
  }

  if (!empty($list_item)){
    $list_item['id'] = array('id' => 'workbench_menu-menu_' . check_plain($variables['menu']->id) .'-item_' . check_plain($item['item']->id));
    $list_item['class'] = array('class' => $item_classes);

    $list_items[] = &$list_item;
  }

  return $list_items;
}

/**
 * Returns an array of options that are supported by this module or extending modules for the given type.
 *
 * @param type
 *   A string representing the type of option to load.
 *   Known types are:
 *   - expand
 *   - position
 *   - item_type
 * @param option (optional)
 *   Providing a valid numeric id or machine name string will cause the return value to only contain the option that matches this string or numeric id.
 * @param $function_history (optional)
 *   An array of function names, ie: array('0' => 'my_function_name').
 *
 * @return
 *   An array of options that are supported by this module or extending modules.
 *   The array keys are the machine names for each option.
 */
function workbench_menu_get_options($type, $option = NULL, array $function_history = array()){
  $options = &drupal_static(__FUNCTION__, NULL);

  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_string($type)){
    cf_error_not_string($function_history, 'type');
    return array();
  }

  if (!is_null($option) && !is_string($option)){
    cf_error_not_string($function_history, 'option');
    return array();
  }

  if (isset($options[$type])){
    if (!is_null($option)){
      if (is_numeric($option)){
        foreach ($options[$type] as $key => &$value){
          if ($value->id == $option){
            return $options[$type][$key];
          }
        }
      }
      else {
        if (isset($options[$type][$option])){
          return $options[$type][$option];
        }
      }

      return array();
    }

    return $options[$type];
  }

  // $type is turned into a database table name, so only allow lowercase characters and underscores
  if (preg_match('/^(\w|_)+$/', $type) == 0){
    return array();
  }

  $type = strtolower($type);

  $table = 'workbench_menu_options_' . $type;

  $query = db_select($table, 'wmot');

  $query->fields('wmot');
  $query->orderBy('wmot.id', 'ASC');

  try {
    $records = $query->execute()->fetchAll();
  }
  catch (Exception $e) {
    cf_error_on_query_execution($function_history, $e);

    return array();
  }

  $options[$type] = array();

  foreach ($records as &$record){
    if (!is_object($record)) continue;

    $options[$type][$record->machine_name] = &$record;
  }

  if (!is_null($option)){
    if (is_numeric($option)){
      foreach ($options[$type] as $key => &$value){
        if ($value->id == $option){
          return $options[$type][$key];
        }
      }
    }
    else {
      if (isset($options[$type][$option])){
        return $options[$type][$option];
      }
    }

    return array();
  }


  return $options[$type];
}

/**
 * Returns a list of options.
 * This is only a list of the machine_name and human_name of the select lists.
 * Use this for populating select lists, radio buttons, and check boxes.
 *
 * @param type
 *   A string representing the type of option to load.
 *   Known types are:
 *   - expand
 *   - position
 *   - item_type
 * @param option (optional)
 *   Providing a valid array of options as returned by workbench_menu_get_options() and it will be properly converted into a options list.
 * @param $function_history (optional)
 *   An array of function names, ie: array('0' => 'my_function_name').
 *
 * @return
 *  An array of options that are supported by this module or extending modules.
 *  The array keys are the standard machine name and the array value is the human name.
 *
 * @see workbench_menu_get_options()
 */
function workbench_menu_get_options_list($type, $options = NULL, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (isset($options_list[$type])){
    return $options_list[$type];
  }

  if (is_null($options)){
    $options = workbench_menu_get_options($type, NULL, $function_history);
  }

  if (!is_array($options_list)){
    $options_list = array();
  }

  $options_list[$type] = array();

  foreach ($options as $machine_name => $value){
    if (!is_object($value)) continue;

    $options_list[$type][$value->machine_name] = $value->human_name;
  }

  return $options_list[$type];
}

/**
 * Obtain a list of available menus.
 *
 * @param $function_history (optional)
 *   An array of function names, ie: array('0' => 'my_function_name').
 *
 * @return
 *  An array of options with the menus taxonomy id as the key and the taxonomy human name as the value.
 */
function workbench_menu_get_menus_options_list(array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (isset($options_list)){
    return $options_list;
  }

  $tree = workbench_access_get_active_tree();
  $options_list = array();

  foreach ($tree['active'] as $key => &$active){
    if (!is_numeric($key)) unset($tree['active'][$key]);
  }

  $terms = taxonomy_term_load_multiple(array_keys($tree['active']));

  foreach ($terms as &$term){
    $options_list[$term->tid] = $term->name;
  }

  asort($options_list);

  return $options_list;
}

/**
 * Obtains the menus associated with a given path.
 *
 * @param path
 *   A path string.
 *
 * @return
 *   An array of menu objects for the given path.
 */
function workbench_menu_get_menus_at_path($path, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_string($path)){
    cf_error_not_string($function_exists, 'path');
    return array();
  }

  $parts = explode('/', $path);
  $matches = array();
  $path_string = '';

  foreach ($parts as &$part){
    $path_string .= $part;
    $matches[] = $path_string;
    $path_string .= '/';
  }

  $menus = (array) workbench_menu_get_menus(array('path' => $matches), 'id', $function_history);

  return $menus;
}

/**
 * Obtains the menus associated with a given node or node id.
 *
 * @param node_or_nid
 *   A node or a node id.
 *
 * @return
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_menus_at_node($node_or_nid, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_object($node_or_nid) && !is_numeric($node_or_nid)){
    cf_error_invalid_variable($function_history, 'node_or_nid', "Must be either a node object or a number");
    return array();
  }

  if (is_numeric($node_or_nid)){
    $node = node_load($node_or_nid);
  }
  else {
    $node = &$node_or_nid;
  }

  if (!property_exists($node, 'workbench_access') || empty($node->workbench_access)){
    return array();
  }

  $menus = (array) workbench_menu_get_menus(array('access_id' => $node->workbench_access), 'id', $function_history);

  return $menus;
}

/**
 * Obtains the menus for the given menu ids.
 *
 * @param $conditions (optional)
 *   An array with the following possible keys:
 *   - id: A unique id representing a specific menu or an array of ids.
 *   - access_id: A unique access id representing a specific workbench access group or an array of access ids.
 *   - path: A path string associated with a given meny or an array of path strings.
 *   - reset: If this key exists, then the cache will not be used.
 *     Otherwise, use as much cache data whenever possible to reduce the number of database queries.
 * @param $keyed (optional)
 *   A string matching one of the following: 'id', 'access_id'
 *   When this is NULL, the default behavior is to return the array exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array will use the specified key name.
 *
 * @return
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_menus($conditions = array(), $keyed = NULL, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_array($conditions)){
    cf_error_invalid_array($function_history, 'conditions');
    return array();
  }

  $reset = FALSE;

  if (array_key_exists('reset', $conditions)){
    $reset = TRUE;
  }

  $query = db_select('workbench_menus', 'wm');
  $query->innerjoin('workbench_access', 'wa', 'wm.access_id = wa.access_id');
  $query->fields('wm');

  $sort_by = 'id';
  $sort_order = 'ASC';

  $query->orderBy('id', 'ASC');

  $and = db_and();
  $and->condition('wa.access_type', 'taxonomy');

  if (isset($conditions['id'])){
    if (is_numeric($conditions['id'])){
      $and->condition('id', $conditions['id']);
    }
    else if (is_array($conditions['id']) && !empty($conditions['id'])){
      $and->condition('id', $conditions['id'], 'IN');
    }
  }

  if (isset($conditions['access_id'])){
    if (is_numeric($conditions['access_id'])){
      $and->condition('wm.access_id', $conditions['access_id']);
    }
    else if (is_array($conditions['access_id']) && !empty($conditions['access_id'])){
      $and->condition('wm.access_id', $conditions['access_id'], 'IN');
    }
  }

  if (isset($conditions['path'])){
    if (is_string($conditions['path'])){
      $and->condition('path', $conditions['path']);
    }
    else if (is_array($conditions['path']) && !empty($conditions['path'])){
      $and->condition('path', $conditions['path'], 'IN');
    }
  }

  $query->condition($and);
  $menus = array();

  if ($keyed == 'id' || $keyed == 'access_id'){
    try {
      $records = $query->execute();
    }
    catch (Exception $e) {
      cf_error_on_query_execution($function_history, $e);
      return array();
    }

    foreach ($records as $record){
      if (!is_object($record)) continue;

      $menus[$record->$keyed] = $record;
    }
  }
  else {
    try {
      $menus = (array) $query->execute()->fetchAll();
    }
    catch (Exception $e) {
      cf_error_on_query_execution($function_history, $e);
    }
  }

  // load all menu additional menu data
  if (!empty($menus)){
    $static_menus = &drupal_static(__FUNCTION__, NULL);
    $cache_changed = FALSE;

    if (is_null($static_menus)){
      if ($menu_cache = cache_get('workbench_menu_cache_menus')){
        $static_menus = $menu_cache->data;
        unset($menu_cache);
      }
      else {
        $static_menus = array('menu' => array(), 'access_id' => array());
      }
    }

    foreach ($menus as &$menu){
      if (!$reset){
        if (isset($static_menus['menu'][$menu->id])){
          $menu = $static_menus['menu'][$menu->id];
          continue;
        }
        else {
          $static_menus['menu'][$menu->id] = &$menu;
        }
      }
      else {
        $static_menus['menu'][$menu->id] = &$menu;
      }

      $menu->items = (array) workbench_menu_get_load_menu_items(array('menu_id' => $menu->id), 'id', $function_history);
      $menu->taxonomy = taxonomy_term_load($menu->access_id);

      $static_menus['menu'][$menu->id] = $menu;
      $static_menus['access_id'][$menu->access_id] = $menu->id;
      $cache_changed = TRUE;
    }

    if ($cache_changed){
      cache_set('workbench_menu_cache_menus', $static_menus, 'cache_menu');
    }
  }

  return $menus;
}

/**
 * Save the settings for one or more menus.
 * This function clears the workbench_menu menu cache.
 *
 * @param item_ids
 *   An array of menu setting arrays with the following keys:
 *   - 'id': (optional) This is the primary key for a specific row in the workbench_menu table.
 *   - 'access_id': This is the unique access_id that represents the workbench access group to save.
 *   - 'path': This is the url path string of the menu.
 * @param $function_history (optional)
 *   An array of function names, ie: array('0' => 'my_function_name').
 *
 * @return
 *   TRUE on success, FALSE otherwise.
 */
function workbench_menu_save_menus($menus, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_array($menus)){
    cf_error_invalid_array($function_history, 'menus');
    return FALSE;
  }

  if (empty($menus)){
    return TRUE;
  }

  $static_menus = &drupal_static('workbench_menu_get_menus', NULL);

  if (is_null($static_menus)){
    if ($menu_cache = cache_get('workbench_menu_cache_menus')){
      $static_menus = $menu_cache->data;
      unset($menu_cache);
    }
  }

  $transaction = db_transaction();

  try {
    foreach ($menus as $key => &$menu){
      if (!is_array($menu)){
        cf_error_invalid_array($function_history, 'menus[' . $key . ']');
        continue;
      }

      $query = db_select('workbench_menus', 'wm');
      $query->fields('wm');

      $record = array();
      $record['path'] = $menu['path'];

      if (isset($menu['id'])){
        $record['id'] = $menu['id'];

        $query->condition('id', $menu['id']);

        $existing = (array) $query->execute()->fetchAll();

        if (empty($existing)){
          unset($record['id']);
        }

        unset($query);
      }
      else if (isset($menu['access_id'])){
        $record['access_id'] = $menu['access_id'];

        $query->condition('access_id', $menu['access_id']);

        $existing = (array) $query->execute()->fetchAll();

        if (!empty($existing)){
          $row = array_pop($existing);
          $record['id'] = $row->id;
        }

        unset($query);
      }

      if (isset($record['id'])){
        drupal_write_record('workbench_menus', $record, array('id'));
      }
      else {
        drupal_write_record('workbench_menus', $record);
      }

      foreach ($menu['items'] as &$menu_item){
        $record = array();

        $record['menu_id'] = $menu_item['menu_id'];
        $record['parent_id'] = $menu_item['parent_id'];
        $record['properties'] = $menu_item['properties'];

        if (property_exists($menu_item, 'id')){
          $record['id'] = $menu_item['id'];
          drupal_write_record('workbench_menu_items', $record, array('id'));
        }
        else {
          drupal_write_record('workbench_menu_items', $record);
        }

        foreach (array('expand', 'item_type') as $name){
          $query = db_delete('workbench_menu_options_' . $name);
          $query->condition($name . '_id', $menu_item['id']);
          $query->execute();

          foreach ($menu_item[$name] as &$id){
            $record = array();
            $record['menu_id'] = $menu_item['id'];
            $record[$name . '_id'] = $id;
            drupal_write_record('workbench_menu_items', $record);
          }
        }
      }

      if (isset($menu['id'])){
        $static_menus['menu'][$menu['id']] = $menu;
      }
      else if (isset($menu['access_id'])){
        $query = db_select('workbench_menus', 'wm');
        $query->fields('wm');
        $query->condition('access_id', $menu['access_id']);

        $records = (array) $query->execute()->fetchAll();

        if (!empty($records)){
          $record = array_pop($records);
          $static_menus['menu'][$record->id] = $menu;
        }
      }
    }

    cache_set('workbench_menu_cache_menus', $static_menus, 'cache_menu');

    // enforce transaction execution
    unset($transaction);
  }
  catch (Exception $e) {
    $transaction->rollback();
    cf_error_on_query_execution($function_history, $e);
    return FALSE;
  }

  return TRUE;
}

/**
 * Loads menu items from the database based on the given conditions.
 *
 * @param $conditions (optional)
 *   An array with the following possible keys:
 *   - 'id' A unique id representing a specific item or an array of ids.
 *   - 'menu_id' A unique menu id representing a specific menu or an array of menu ids.
 *   - 'parent_id' A unique parent id representing a specific parent or an array of parent ids.
 *   - 'human_name' A human name string of a menu item or an array of human name strings.
 *   - 'weight' A number representing the weight or an array of weight numbers.
 * @param $keyed (optional)
 *   A string matching one of the following: 'id', 'menu_id'
 *   When this is NULL, the default behavior is to return the array exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array will use the specified key name.
 * @param $function_history (optional)
 *   An array of function names, ie: array('0' => 'my_function_name').
 *
 * @return
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_load_menu_items($conditions = array(), $keyed = NULL, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  $sorted_menu_items = array();
  $sorted_menu_items['flat'] = array();
  $sorted_menu_items['nested'] = array();

  if (!is_array($conditions)){
    cf_error_invalid_array($function_history, 'conditions');
    return $sorted_menu_items;
  }

  $query = db_select('workbench_menu_items', 'wmi');
  $query->fields('wmi');

  $query->orderBy('parent_id', 'ASC');
  $query->orderBy('weight', 'ASC');
  $query->orderBy('human_name', 'ASC');
  $query->orderBy('id', 'ASC');

  $and = db_and();

  if (isset($conditions['id'])){
    if (is_numeric($conditions['id'])){
      $and->condition('id', $conditions['id']);
    }
    else if (is_array($conditions['id']) && !empty($conditions['id'])){
      $and->condition('id', $conditions['id'], 'IN');
    }
  }

  if (isset($conditions['menu_id'])){
    if (is_numeric($conditions['menu_id'])){
      $and->condition('menu_id', $conditions['menu_id']);
    }
    else if (is_array($conditions['menu_id']) && !empty($conditions['menu_id'])){
      $and->condition('menu_id', $conditions['menu_id'], 'IN');
    }
  }

  if (isset($conditions['parent_id'])){
    if (is_numeric($conditions['parent_id'])){
      $and->condition('parent_id', $conditions['parent_id']);
    }
    else if (is_array($conditions['parent_id']) && !empty($conditions['parent_id'])){
      $and->condition('parent_id', $conditions['parent_id'], 'IN');
    }
  }

  if (isset($conditions['weight'])){
    if (is_numeric($conditions['weight'])){
      $and->condition('weight', $conditions['weight']);
    }
    else if (is_array($conditions['weight']) && !empty($conditions['weight'])){
      $and->condition('weight', $conditions['weight'], 'IN');
    }
  }

  if (isset($conditions['human_name'])){
    if (is_string($conditions['human_name'])){
      $and->condition('human_name', $conditions['human_name']);
    }
    else if (is_array($conditions['human_name']) && !empty($conditions['human_name'])){
      $and->condition('human_name', $conditions['human_name'], 'IN');
    }
  }

  $query->condition($and);
  $menu_items = array();

  if ($keyed == 'id' || $keyed == 'menu_id'){
    try {
      $records = $query->execute();
    }
    catch (Exception $e) {
      cf_error_on_query_execution($function_history, $e);
      return $sorted_menu_items;
    }

    foreach ($records as $record){
      if (!is_object($record)) continue;

      $menu_items[$record->$keyed] = $record;
    }
  }
  else {
    try {
      $menu_items = (array) $query->execute()->fetchAll();
    }
    catch (Exception $e) {
      cf_error_on_query_execution($function_history, $e);
    }
  }

  if (!empty($menu_items)){
    // use a separate queries to load all many-to-many relationships
    foreach ($menu_items as $id => &$menu_item){
      if (!isset($sorted_menu_items['flat'][$id])){
        $sorted_menu_items['flat'][$id] = array();
        $sorted_menu_items['flat'][$id]['children'] = array();
      }

      $sorted_menu_items['flat'][$id]['item'] = $menu_item;

      if ($menu_item->parent_id == 0){
        $sorted_menu_items['nested'][$id] = &$sorted_menu_items['flat'][$id];
      }
      else {
        if (!isset($sorted_menu_items['flat'][$menu_item->parent_id])){
          $sorted_menu_items['flat'][$menu_item->parent_id] = array();
          $sorted_menu_items['flat'][$menu_item->parent_id]['children'] = array();
        }

        $sorted_menu_items['flat'][$menu_item->parent_id]['children'][$id] = &$sorted_menu_items['flat'][$id];
      }

      $menu_item->properties = unserialize($menu_item->properties);

      foreach (array('expand', 'item_type') as $name){
        $results = array();

        $query = db_select('workbench_menu_options_' . $name, 'wmon');
        $query->innerjoin('workbench_menu_' . $name . 's',  'wmn', 'wmon.id = wmn.' . $name . '_id');
        $query->fields('wmon');
        $query->addField('wmn', 'item_id', 'item_id');

        $query->condition('wmn.item_id', $id);

        try {
          $records = $query->execute();

          foreach ($records as $record){
            $results[$record->id] = $record;
          }
        }
        catch (Exception $e) {
          cf_error_on_query_execution($function_history, $e);
        }

        $menu_item->$name = $results;
      }
    }
  }

  return $sorted_menu_items;
}

/**
 * Obtains a select list of for menu items loaded from the database based on the given conditions.
 *
 * @param $conditions (optional)
 *   An array that is passed directly to workbench_menu_get_load_menu_items().
 * @param $keyed (optional)
 *   A string that is passed directly to workbench_menu_get_load_menu_items().
 * @param $function_history (optional)
 *   An array of function names, ie: array('0' => 'my_function_name').
 *
 * @return
 *   A processed array select list of menu objects for the given node.
 *
 * @see workbench_menu_get_load_menu_items()
 */
function workbench_menu_get_load_menu_items_select_list_options($conditions = array(), $keyed = NULL, array $function_history = array()){
  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (is_null($options_list)){
    $items = (array) workbench_menu_get_load_menu_items($conditions, $keyed, $function_history);

    foreach ($items['flat'] as &$i){
      $available_parents[$i['item']->id] = $i['item']->human_name;
    }

    $data = array();
    $data['options'] = array('0' => "<No Parent>");

    foreach ($items['nested'] as &$nested_item){
      workbench_menu_get_load_menu_items_select_list_options_recursive_walk($nested_item, $data, $function_history);
    }

    $options_list = $data['options'];
  }

  return $options_list;
}

/**
 * Recursively walk through each menu item until there is are no longer any children menu items.
 * This is expected only to be called by workbench_menu_get_load_menu_items_select_list_options().
 *
 * @param $item
 *   The menu item object.
 * @param $data
 *   An array of data globally shared between the different recursive calls.
 * @param $function_history (optional)
 *   An array of function names, ie: array('0' => 'my_function_name').
 *
 * @see workbench_menu_get_load_menu_items_select_list_options()
 */
function workbench_menu_get_load_menu_items_select_list_options_recursive_walk(&$item, &$data, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  if (!isset($data['depth'])){
    $data['depth'] = 0;
  }

  if ($data['depth'] > 0){
    $data['options'][$item['item']->id] = str_repeat('- ', $data['depth']) . $item['item']->human_name;
  }
  else {
    $data['options'][$item['item']->id] = $item['item']->human_name;
  }

  if (!empty($item['children'])){
    $data['depth']++;

    foreach ($item['children'] as &$child){
      workbench_menu_get_load_menu_items_select_list_options_recursive_walk($child, $data, $function_history);
    }

    $data['depth']--;
  }
}

/**
 * Validate that a user has access to edit a given access type and id.
 *
 * @param $access_type
 *   The type of access requested (e.g.g taxonomy).
 *   If NULL is passed, then this simply returnes whether or not the user has 'edit workbench menu' access.
 *
 * @param $access_type_id
 *   The access_id to validate
 *   If NULL is passed, then this simply returnes whether or not the user has 'edit workbench menu' access.
 */
function workbench_menu_edit_access($access_type = NULL, $access_type_id = NULL){
  if ($access_type == NULL || $access_type_id == NULL) return user_access('edit workbench menu');

  if (!user_access('edit workbench menu')) return FALSE;

  if ($access_type == 'taxonomy'){
    $access = workbench_access_get_access_tree();

    if (array_key_exists($access_type_id, $access)){
      return TRUE;
    }
  }

  return FALSE;
}
