<?php

/**
 * @file
 * Module file for the workbench menu project.
 */

/**
 * Implements hook_help().
 */
function workbench_menu_help($path, $arg) {
  $output = '';

  switch ($path) {
    case "admin/help#workbench_menu":
      $output .= '<p>' . t("This module provides an alternative menuing system to the one provided by drupal. This utilizes the access control system provided by workbench_access. The only access type supported at this time is taxonomy.") . '</p>';
      return $output;
  }
}

/**
 * Implements hook_permission().
 */
function workbench_menu_permission() {
  $permissions = array();

  $permissions['edit workbench menu'] = array(
    'title' => t("Edit Workbench Menu"),
    'description' => t("Grants permissions to alter any workbench menus in which a user is in the workbench access section associated with that menu."),
  );

  $permissions['change workbench menu path'] = array(
    'title' => t("Change Workbench Menu Path"),
    'description' => t("Grants permissions to alter the menu path or related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu breadcrumb'] = array(
    'title' => t("Change Workbench Menu Breadcrumb"),
    'description' => t("Grants permissions to alter the menu breadcrumb or related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu parent'] = array(
    'title' => t("Change Workbench Menu Parent"),
    'description' => t("Grants permissions to alter the menu parent related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['administer workbench menu'] = array(
    'title' => t("Administer Workbench Menu"),
    'description' => t("Grants permissions to alter all workbench menus and perform administrative tasks."),
  );

  return $permissions;
}

/**
 * Implements hook_entity_info().
 */
function workbench_menu_entity_info() {
  $types['workbench_menu'] = array(
    'label' => t('Workbench menu'),
    'base table' => 'workbench_menus',
    'controller class' => 'WorkbenchMenuController',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'id',
    ),
  );
  return $types;
}

/**
 * Implements hook_menu().
 */
function workbench_menu_menu() {
  $items = array();

  $items['admin/config/workbench/access/menus'] = array(
    'title' => "Menus",
    'description' => "Settings for workbench menus.",
    'page callback' => 'workbench_menu_admin_settings',
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'user_access',
    'access arguments' => array('administer workbench menu'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/config/workbench/access/menus/%/%/items'] = array(
    'title' => "Menu Items",
    'description' => "Settings for workbench menus items.",
    'page callback' => 'workbench_menu_admin_item_settings',
    'page arguments' => array(5, 6),
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'user_access',
    'access arguments' => array('administer workbench menu'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  $items['admin/workbench/menus'] = array(
    'title' => "My Menus",
    'description' => "Settings for workbench menus you have access to alter.",
    'page callback' => 'workbench_menu_edit_settings',
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'workbench_menu_edit_access',
    'access arguments' => array(3, 4),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/workbench/menus/%/%/items'] = array(
    'title' => "Menu Items",
    'description' => "Settings for workbench menus items.",
    'page callback' => 'workbench_menu_edit_item_settings',
    'page arguments' => array(3, 4),
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'workbench_menu_edit_access',
    'access arguments' => array(3, 4),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  return $items;
}

/**
 * Implements hook_workbench_access_save().
 */
function workbench_menu_workbench_access_save($section) {
  if (variable_get('workbench_access', 'taxonomy') != 'taxonomy') {
    return;
  }

  if (!is_numeric($section['access_id'])) {
    return;
  }

  $query = db_insert('workbench_menus');
  $query->fields(array('access_id' => $section['access_id'], 'path' => ''));
  $query->execute();
}

/**
 * Implements hook_workbench_access_delete().
 */
function workbench_menu_workbench_access_delete($section) {
  if (variable_get('workbench_access', 'taxonomy') != 'taxonomy') {
    return;
  }

  if (!is_numeric($section['access_id'])) {
    return;
  }

  $query = db_select('workbench_menus', 'wm');
  $query->fields('wm', array('id', 'access_id'));
  $query->condition('wm.access_id', $section['access_id']);

  $records = (array) $query->execute()->fetchAll();

  if (empty($records)) {
    return;
  }

  foreach ($records as &$record) {
    $query = db_delete('workbench_menu_items');
    $query->condition('menu_id', $record->id);
    $query->execute();

    $query = db_delete('workbench_menus');
    $query->condition('id', $record->id);
    $query->execute();
  }
}

/**
 * Implements hook_theme().
 */
function workbench_menu_theme($existing, $type, $theme, $path) {
  $themes = array();

  $themes['workbench_menu_admin_settings_form'] = array(
    'render element' => 'form',
    'file' => 'workbench_menu.admin.inc',
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $themes['workbench_menu_edit_settings_form'] = array(
    'render element' => 'form',
    'file' => 'workbench_menu.admin.inc',
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  return $themes;
}

/**
 * Implements hook_block_info().
 */
function workbench_menu_block_info() {
  $blocks = array();

  $blocks['workbench_menu_block'] = array(
    'info' => t("Workbench Menu"),
    'weight' => -1,
    'status' => 1,
    'region' => 'sidebar_first',
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function workbench_menu_block_view($delta = '') {
  cf_error_append_history($function_history, __FUNCTION__);

  $path = request_path();

  if (empty($path)) {
    return array();
  }

  $parts = explode('/', $path);
  $paths = array();
  $path_string = '';

  $path2 = current_path();
  $matches = array();

  // not all /node/[nid]* paths have aliases (such as: /node/123/edit might not have an alias and /node/123 might have an alias).
  // be sure to handle the /node/[nid]* paths as if they were invalid_trail paths for the /node/[nid] alias.
  $matched = preg_match('@^node/(\d+)(/.*|$|\?.*|#.*)@', $path, $matches);

  if ($matched > 0) {
    $path_alias = drupal_get_path_alias('node/' . $matches[1]);
    $parts = explode('/', $path_alias . $matches[2]);
  }

  if (count($parts) == 0) {
    return array();
  }

  // Load the cached menus or to do the initial processing.
  $markup = array();
  $menu_cache_id = 'workbench_menu-menus_at-' . $parts[0];
  $breadcrumb_cache_id = 'workbench_menu-breadcrumbs_at-' . $parts[0];
  $menus_cached = &drupal_static($menu_cache_id, array());
  $breadcrumbs_cached = &drupal_static($breadcrumb_cache_id, array());
  $menus_processed = array();
  $save_cache = FALSE;
  $path_tree = array();
  $menu_markup = array();
  $menu_depth = 0;
  $breadcrumb_tree = array();

  if ($cached_menu = cache_get($menu_cache_id, 'cache_menu')) {
    $menus_cached = $cached_menu->data;
    unset($cached_menu);
  }

  if ($cached_breadcrumb = cache_get($breadcrumb_cache_id, 'cache_menu')) {
    $breadcrumbs_cached = $cached_breadcrumb->data;
    unset($cached_breadcrumb);
  }

  foreach ($parts as &$part) {
    $path_string .= $part;
    $paths[] = $path_string;
    $menu_depth++;

    if (empty($menus_cached[$path_string])) {
      $menus_cached[$path_string] = (array) workbench_menu_build_menus($path_string, $menus_processed, $breadcrumbs_cached, $function_history);

      if (!empty($menus_cached[$path_string])) $save_cache = TRUE;
    }

    if (!empty($menus_cached[$path_string])) {
      $path_tree[] = $path_string;
    }

    $path_string .= '/';
  }

  if ($save_cache) {
    cache_set($menu_cache_id, $menus_cached, 'cache_menu');
    cache_set($breadcrumb_cache_id, $breadcrumbs_cached, 'cache_menu');
  }

  $path_string = preg_replace('|/$|', '', $path_string);
  $show_parents = TRUE;
  $assign_breadcrumbs = TRUE;
  $path_tree2 = $path_tree;

  while (!empty($path_tree) && $show_parents) {
    $current_path = array_pop($path_tree);

    if ($assign_breadcrumbs) {
      while (!empty($path_tree2)) {
        $current_path2 = array_pop($path_tree2);

        if (!empty($breadcrumbs_cached[$current_path2])) {
          $bc = $breadcrumbs_cached[$current_path2];

          // always show the topmost breadcrumb even when on the top-level path.
          // (this is different from normal-breadcrumb behavior and is intentional.)
          // @todo: look into providing an option for users to control this behavior.
          if (count($bc) > 1) {
            array_pop($bc);
          }

          drupal_set_breadcrumb($bc);
          break;
        }
      }

      $assign_breadcrumbs = FALSE;
    }

    if (!empty($menus_cached[$current_path]['structure'])) {
      $data = workbench_menu_render_menus($menus_cached[$current_path], $path_string, $show_parents, $menu_depth, $function_history);

      foreach ($data as $key => &$value) {
        if (isset($menu_markup[$key])) {
          $menu_markup[$key] .= $value;
        }
        else {
          $menu_markup[$key] = $value;
        }
      }
    }

    $menu_depth--;
  }

  if (empty($menu_markup)) {
    return array();
  }

  $block = array();
  $block['subject'] = '';
  $block['content'] = array(
    '#markup' => implode(' ', $menu_markup),
    '#attached' => array(
      'css' => array(drupal_get_path('module', 'workbench_menu') . '/includes/workbench_menu.css'),
    ),
  );

  return $block;
}

/**
 * Process and build the menus for a given path.
 *
 * @param string $path_string
 *   A string containing the url path of the menu to generate.
 * @param array $menus_processed
 *   An array of menu ids defining which menus have already been
 *   processed.
 * @param array|false $breadcrumbs
 *   An array of breadcrumbs that will be auto populated by this
 *   function.
 *   Each array key will be the path in which a given array of
 *   breadcrumbs relate to.
 *   If FALSE, then breadcrumbs will not be populated.
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @return array
 *   An array with the following structure:
 *   - structure: A nested array containing the weights and item ids.
 *   - settings: A flat array containing the properties of each item.
 *
 * @see drupal_set_breadcrumb()
 */
function workbench_menu_build_menus($path_string, &$menus_processed, &$breadcrumbs, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  $menus = (array) workbench_menu_get_menus(array('path' => array($path_string)), 'id', $function_history);

  $menu_even = TRUE;
  $menu_total = count($menus);
  $menu_current = 0;

  $built_menus = array();
  $built_menus['structure'] = array();
  $built_menus['menus'] = array();

  foreach ($menus as $menu_id => &$menu) {
    $menus_processed[$menu->access_id] = NULL;

    $built_menu = array();
    $built_menu['structure'] = array();
    $built_menu['settings'] = array();
    $built_menu['id'] = $menu->id;
    $built_menu['access_id'] = $menu->access_id;
    $built_menu['path'] = $menu->path;
    $built_menu['weight'] = $menu->weight;
    $built_menu['show_parents'] = $menu->show_parents;
    $built_menu['breadcrumb_name'] = $menu->breadcrumb_name;
    $built_menu['taxonomy'] = $menu->taxonomy;

    $variables = array();
    $variables['menus_processed'] = &$menus_processed;

    if ($breadcrumbs === FALSE){
      $variables['breadcrumbs_all'] = FALSE;
    }
    else {
      $variables['breadcrumbs_all'] = &$breadcrumbs;
    }

    if (empty($menu->breadcrumb_name)) {
      $menu_name = $menu->taxonomy->name;
    }
    else {
      $menu_name = $menu->breadcrumb_name;
    }

    $top_level = array(l($menu_name, $menu->path));
    $breadcrumbs[$menu->path] = $top_level;

    if (empty($menu->items['nested'])) {
      $menu_total--;
      continue;
    }

    foreach ($menu->items['nested'] as &$item) {
      $variables['parent_path'] = $menu->path;
      $variables['menu_path'] = $menu->path;
      $variables['breadcrumbs'] = $top_level;

      $data = workbench_menu_build_menu_item($menu, $item, $variables, $function_history);

      foreach ($data['structure'] as $weight_id => &$weight_data) {
        foreach ($weight_data as $weight_data_id => $weight_data_data) {
          $built_menu['structure'][$weight_id][$weight_data_id] = $weight_data_data;
        }
      }

      foreach ($data['settings'] as $child_id => &$child_settings) {
        $built_menu['settings'][$child_id] = $child_settings;
      }

      $built_menus['structure'][$menu->weight][$menu->id] = $built_menu;
    }
  }

  return $built_menus;
}

/**
 * Process and build the menu items.
 *
 * @param object $menu
 *   A menu object as returned by workbench_menu_get_menus().
 * @param array $item
 *   A menu item as stored in $menu->items['nested'].
 * @param array $variables
 *   An array containing the following keys:
 *   - 'menus_processed': An array containing menu access ids whose
 *   array keys are the menu ids.
 *   - 'breadcrumbs_all':
 *   An array of breadcrumbs whose keys are path strings or FALSE.
 *   If it is FALSE, then breadcrumbs will not be processed.
 *   - 'parent_path': A string of the path of a parent menu item.
 *   - 'breadcrumbs': A breadcrumb array associated with this menu
 *   item.
 *   It is structured such that it can be directly passed to
 *   drupal_set_breadcrumb().
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 *
 * @return array
 *   An array with the following structure:
 *   - structure: A nested array containing the weights and item ids.
 *   - settings: A flat array containing the properties of each item.
 *
 * @see workbench_menu_get_menus()
 * @see drupal_set_breadcrumb()
 */
function workbench_menu_build_menu_item($menu, $item, &$variables, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  static $wmi_css = 'menu_item';

  $built_menu = array();

  $structure = array();
  $structure[$item['item']->weight] = array($item['item']->id => array());

  $settings = array();
  $settings[$item['item']->id] = array();
  $settings[$item['item']->id]['type'] = '';
  $settings[$item['item']->id]['expand'] = 'expand_auto';
  $settings[$item['item']->id]['label'] = check_plain($item['item']->human_name);
  $settings[$item['item']->id]['attributes'] = array();
  $settings[$item['item']->id]['attributes']['id'][] = $wmi_css . '-menu_' . $menu->id . '-item_' . $item['item']->id;
  $settings[$item['item']->id]['attributes']['class'] = array();
  $settings[$item['item']->id]['prefix'] = '';
  $settings[$item['item']->id]['postfix'] = '';
  $settings[$item['item']->id]['outside_link'] = FALSE;
  $settings[$item['item']->id]['top_link'] = FALSE;
  $settings[$item['item']->id]['active_path'] = '';
  $settings[$item['item']->id]['breadcrumbs'] = array();

  $process_children = TRUE;

  foreach ($item['item']->item_type as &$type) {
    $settings[$item['item']->id]['type'] = $type->machine_name;
    $settings[$item['item']->id]['attributes']['class'][] = $wmi_css . '-type-' . $type->machine_name;
    break;
  }

  foreach ($item['item']->expand as &$expand) {
    $settings[$item['item']->id]['expand'] = $expand->machine_name;
    $settings[$item['item']->id]['attributes']['class'][] = $wmi_css . '-expand-' . $expand->machine_name;
    break;
  }

  $active_path = $item['item']->active_path;

  $alter_settings = array();
  $alter_settings['menu'] = clone($menu);
  $alter_settings['item'] = $item;
  $alter_settings['settings'] = &$settings[$item['item']->id];
  $alter_settings['active_path'] = $active_path;
  $alter_settings['variables'] = &$variables;

  // menu item menus are other menus embedded inside the current menu.
  if ($settings[$item['item']->id]['type'] == 'item_menu') {
    if ($menu->access_id == $item['item']->properties['menu'] || array_key_exists($item['item']->properties['menu'], $variables['menus_processed'])) {
      return array('structure' => array(), 'settings' => array());
    }

    $item_menus = (array) workbench_menu_get_menus(array('access_id' => $item['item']->properties['menu']), 'id', $function_history);
    $item_menu = array_pop($item_menus);

    // @todo handle error case where menu is not found.

    $variables['menus_processed'][$item_menu->access_id] = NULL;

    $breadcrumbs_temporary = FALSE;
    $built_menus = workbench_menu_build_menus($item_menu->path, $variables['menus_processed'], $breadcrumbs_temporary, $function_history);
    $data = array();
    $data['structure'] = $built_menus['structure'][$item_menu->weight][$item_menu->id]['structure'];
    $data['settings'] = $built_menus['structure'][$item_menu->weight][$item_menu->id]['settings'];

    if ($settings[$item['item']->id]['expand'] != "expand_auto") {
      foreach ($data['structure'] as $row_key => &$row_value) {
        foreach ($row_value as $key => &$value){
          $data['settings'][$key]['expand'] = $settings[$item['item']->id]['expand'];
        }
      }
    }

    return $data;
  }

  // menu item menu items are parts of another menu embeded inside of the current menu.
  if ($settings[$item['item']->id]['type'] == 'item_menu_item') {
    $item_menus = (array) workbench_menu_get_menus(array('id' => $item['item']->properties['menu']), 'id', $function_history);
    $item_menu = array_pop($item_menus);
    $item_menu_item = NULL;

    // @todo handle error case where menu or item is not found.

    $process_children = FALSE;

    $item_menu_item_variables = array();
    $item_menu_item_variables['menus_processed'] = $variables['menus_processed'];
    $item_menu_item_variables['parent_path'] = $item_menu->path;
    $item_menu_item_variables['menu_path'] = $item_menu->path;

    if (empty($menu->breadcrumb_name)) {
      $item_menu_item_variables['breadcrumbs'] = array(l($item_menu->taxonomy->name, $item_menu->path));
    }
    else {
      $item_menu_item_variables['breadcrumbs'] = array(l($item_menu->breadcrumb_name, $item_menu->path));
    }

    if ($variables['breadcrumbs_all'] === FALSE){
      $item_menu_item_variables['breadcrumbs_all'] = FALSE;
    }
    else {
      $item_menu_item_variables['breadcrumbs_all'] = &$breadcrumbs;
    }

    $history_stack = array();
    $current_stack = array_reverse($item_menu->items['nested'], TRUE);

    while (!empty($current_stack)) {
      $nested_item = array_pop($current_stack);

      if ($nested_item['item']->id == $item['item']->properties['menu_item']) {
        $item_menu_item = &$nested_item;
        array_push($item_menu->items['nested'], $nested_item);
        break;
      }

      if (!empty($nested_item['children'])) {
        array_push($history_stack, $current_stack);

        $current_stack = array_reverse($nested_item['children'], TRUE);
        continue;
      }

      if (empty($current_stack) && !empty($history_stack)) {
        $current_stack = array_pop($history_stack);
      }
    }

    unset($history_stack);
    unset($current_stack);

    if (is_null($item_menu_item)) {
      drupal_alter(__FUNCTION__, $alter_settings);
      return array('structure' => array(), 'settings' => $settings);
    }

    $data = workbench_menu_build_menu_item($item_menu, $item_menu_item, $item_menu_item_variables, $function_history);

    // @todo handle error case where menu item is not found.

    $structure[$item['item']->weight][$item['item']->id] = $data['structure'][$item_menu_item['item']->weight][$item_menu_item['item']->id];

    $settings[$item['item']->id]['label'] = $data['settings'][$item_menu_item['item']->id]['label'];
    $settings[$item['item']->id]['prefix'] = $data['settings'][$item_menu_item['item']->id]['prefix'];
    $settings[$item['item']->id]['postfix'] = $data['settings'][$item_menu_item['item']->id]['postfix'];
    $settings[$item['item']->id]['outside_link'] = $data['settings'][$item_menu_item['item']->id]['outside_link'];
    $settings[$item['item']->id]['top_link'] = $data['settings'][$item_menu_item['item']->id]['top_link'];
    $settings[$item['item']->id]['active_path'] = $data['settings'][$item_menu_item['item']->id]['active_path'];

    foreach ($data['settings'][$item_menu_item['item']->id]['attributes'] as $attribute => &$value) {
      if ($attribute == 'id' || $attribute == 'class') continue;
      $settings[$item['item']->id]['attributes'][$attribute] = $value;
    }

    $settings[$item['item']->id]['attributes']['class'][] = $wmi_css . '-type-' . $data['settings'][$item_menu_item['item']->id]['type'];

    unset($data['settings'][$item_menu_item['item']->id]);

    foreach ($data['settings'] as $child_id => &$child_settings) {
      $settings[$child_id] = $child_settings;
    }

    $built_menu['structure'] = $structure;
    $built_menu['settings'] = $settings;
    return $built_menu;
  }

  // menu item labels are parts of a menu that do not link to anything.
  if ($settings[$item['item']->id]['type'] == 'item_label') {
    if (isset($item['item']->properties['disabled']) && $item['item']->properties['disabled']) {
      $settings[$item['item']->id]['attributes']['class'][] = 'disabled';
    }
  }

  // menu item links are parts of a menu that link to some url, file, or id (local or remote).
  if ($settings[$item['item']->id]['type'] == 'item_link') {
    $link_path = '';

    $matches = array();
    $matched = preg_match('@^/node/(\d+)(/.*|$|\?.*|#.*)@', $item['item']->properties['url'], $matches);

    if ($matched > 0) {
      $path_alias = drupal_get_path_alias('node/' . $matches[1] . $matches[2]);
      $parsed_url = parse_url($path_alias);

      if (!empty($parsed_url['path'])) {
        $link_path = '/' . $parsed_url['path'];
        $active_path = $parsed_url['path'];
      }

      if (!empty($parsed_url['query'])) {
        $link_path .= '?' . $parsed_url['query'];
      }

      if (!empty($parsed_url['fragment'])) {
        $link_path .= '#' . $parsed_url['fragment'];
      }
    }

    if (empty($link_path)) {
      if ($item['item']->properties['url'] == '<top>') {
        $settings[$item['item']->id]['attributes']['class'][] = $wmi_css . '-menu_top';
        $settings[$item['item']->id]['top_link'] = TRUE;

        $link_path = '/' . $menu->path;
        $active_path = $menu->path;
      }
      else {
        $link_path = $item['item']->properties['url'];

        if (valid_url($link_path, TRUE)) {
          $parsed_url = parse_url($link_path);
          $remote_url = check_plain($parsed_url['host']);

          $settings[$item['item']->id]['prefix'] .= '<div class="' . $wmi_css . '-icon ' . $wmi_css . '-icon_external"></div>';
          $settings[$item['item']->id]['attributes']['title'] = array(t("This links to the external website: !remote_url.", array('!remote_url' => $remote_url)));
        }
        else {
          $matches = array();

          if (preg_match('/^mailto:(.*)/', $link_path, $matches) > 0) {
            $settings[$item['item']->id]['prefix'] .= '<div class="' . $wmi_css . '-icon ' . $wmi_css . '-icon_mail"></div>';
            $settings[$item['item']->id]['attributes']['title'] = array(t("Send an e-mail to: !email_address.", array('!email_address' => check_plain($matches[1]))));
          }
          else if (preg_match('@^(/|#)@', $link_path) === 0) {
            $link_path = '/' . $menu->path . '/' . $link_path;
          }
        }
      }
    }

    $settings[$item['item']->id]['attributes']['href'] = array(check_url($link_path));
    $settings[$item['item']->id]['outside_link'] = (preg_match('@^' . $menu->path . '/@', $link_path) > 0);

    unset($matches);
    unset($matched);
    unset($link_path);
  }

  if ($settings[$item['item']->id]['type'] == 'item_file') {
    $icon = check_plain($item['item']->properties['file_type']);
    $filename = '';
    $link_path = '';

    $matches = array();
    $matched = preg_match('@^/node/(\d+)(/.*|$|\?.*|#.*)@', $item['item']->properties['file'], $matches);

    if ($matched > 0) {
      $path_alias = drupal_get_path_alias('node/' . $matches[1] . $matches[2]);
      $parsed_url = parse_url($path_alias);

      if (!empty($parsed_url['path'])) {
        $link_path = '/' . $parsed_url['path'];
        $active_path = $parsed_url['path'];

        $path_node = node_load($matches[1]);
        if (is_object($path_node)){
          $filename = $path_node->title;
          unset($path_node);
        }
        else {
          $filename = $data['settings'][$item_menu_item['item']->id]['label'];
        }
      }

      if (!empty($parsed_url['query'])) {
        $link_path .= '?' . $parsed_url['query'];
      }

      if (!empty($parsed_url['fragment'])) {
        $link_path .= '#' . $parsed_url['fragment'];
      }
    }

    if (empty($link_path)) {
      $link_path = $item['item']->properties['file'];
      $filename = check_plain(rawurldecode(basename($link_path)));

      if (valid_url($link_path, TRUE)) {
        $parsed_url = parse_url($link_path);
        $remote_url = check_plain($parsed_url['host']);

        $settings[$item['item']->id]['prefix'] = '<div class="' . $wmi_css . '-icon ' . $wmi_css . '-icon_' . $icon . '"></div>';
        $settings[$item['item']->id]['attributes']['title'] = array(t("Download !filename from the external website: !remote_url.", array('!filename' => $filename, '!remote_url' => $remote_url)));
        $settings[$item['item']->id]['attributes']['class'][] = $wmi_css . '-external_url';
      }
      else {
        $settings[$item['item']->id]['prefix'] .= '<div class="' . $wmi_css . '-icon ' . $wmi_css . '-icon_' . $icon . '"></div>';
        $settings[$item['item']->id]['attributes']['title'] = array(t("Download !filename.", array('!filename' => $filename)));
      }
    }
    else {
      $settings[$item['item']->id]['prefix'] .= '<div class="' . $wmi_css . '-icon ' . $wmi_css . '-icon_' . $icon . '"></div>';
      $settings[$item['item']->id]['attributes']['title'] = array(t("View or Download: !filename.", array('!filename' => $filename)));
    }

    $settings[$item['item']->id]['attributes']['href'] = array(check_url($link_path));
    $settings[$item['item']->id]['postfix'] = '';

    unset($icon);
    unset($filename);
    unset($matches);
    unset($matched);
    unset($link_path);
  }

  if ($item['item']->active_path == '<top>') {
    $active_path = $variables['menu_path'];
  }
  else if (empty($settings[$item['item']->id]['active_path']) && !empty($item['item']->active_path)) {
    if (preg_match('@^/@', $item['item']->active_path) == 0) {
      $active_path = $variables['parent_path'] . '/' . $item['item']->active_path;
    }
    else {
      $active_path = $variables['menu_path'] . $item['item']->active_path;
    }
  }

  if (!empty($active_path)) {
    $settings[$item['item']->id]['active_path'] = $active_path;

    if ($active_path != $variables['menu_path']) {
      $variables['breadcrumbs'][] = l($settings[$item['item']->id]['label'], $active_path);
    }

    if ($variables['breadcrumbs_all'] !== FALSE){
      if (preg_match('@^' . $variables['parent_path'] . '/@', $active_path) > 0) {
        $variables['breadcrumbs_all'][$active_path] = $variables['breadcrumbs'];
      }
    }
  }
  else {
    $variables['breadcrumbs'][] = $settings[$item['item']->id]['label'];
  }

  if ($variables['breadcrumbs_all'] === FALSE){
    unset($settings[$item['item']->id]['breadcrumbs']);
  }
  else {
    $settings[$item['item']->id]['breadcrumbs'] = $variables['breadcrumbs'];
  }

  if ($process_children && !empty($item['children'])) {
    foreach ($item['children'] as &$child) {
      $child_variables = array();
      $child_variables['menus_processed'] = &$variables['menus_processed'];
      $child_variables['parent_path'] = $variables['parent_path'];
      $child_variables['menu_path'] = $variables['menu_path'];
      $child_variables['breadcrumbs'] = $variables['breadcrumbs'];

      if ($variables['breadcrumbs_all'] === FALSE){
        $child_variables['breadcrumbs_all'] = FALSE;
      }
      else {
        $child_variables['breadcrumbs_all'] = &$variables['breadcrumbs_all'];
      }

      if (!empty($active_path)) {
        $child_variables['parent_path'] = $active_path;
      }

      $data = workbench_menu_build_menu_item($menu, $child, $child_variables, $function_history);

      foreach ($data['structure'] as $structure_id => &$structure_data) {
        foreach ($structure_data as $structure_data_id => $structure_data_data) {
          $structure[$item['item']->weight][$item['item']->id][$structure_id][$structure_data_id] = $structure_data_data;
        }
      }

      foreach ($data['settings'] as $child_id => &$child_settings) {
        $settings[$child_id] = $child_settings;
      }
    }
  }

  // @todo: write the api for this alter function
  drupal_alter(__FUNCTION__, $alter_settings);

  $built_menu['structure'] = $structure;
  $built_menu['settings'] = $settings;
  return $built_menu;
}

/**
 * Render the contents of a pre-built menu into a html menus.
 *
 * @param array $built_menu
 *   An array with the following structure:
 *   - weight: A nested array containing the weights and item ids.
 *   - settings: A flat array containing the properties of each item.
 * @param string $path_current
 *   A string containing the complete url path that is currently
 *   active.
 * @param bool $show_parents
 *   A boolean representing whether or not the parent menus should be
 *   renderred.
 *   This is populated after renderring the given menu to tell the
 *   caller if it is okay to or not to render the parent menus.
 * @param array $function_history
 *   (optional) An array of function names,
 *   ie: array('0' => 'my_function_name').
 *
 * @return array
 *   An array with the following structure:
 *   - markup: A string of the renderred html markup.
 *   - breadcrumb: An array as of breadcrumb data as needed by
 *   drupal_set_breadcrumb().
 *
 * @see workbench_menu_build_menus()
 * @see drupal_set_breadcrumb()
 */
function workbench_menu_render_menus($built_menus, $path_current, &$show_parents, $menu_depth, array $function_history = array()) {
  $even_menu = TRUE;
  $count_menu = 0;
  $rendered = array();

  foreach ($built_menus['structure'] as $built_menus_weight => &$menus) {
    $rendered[$built_menus_weight] = '';

    foreach ($menus as $menu_id => &$menu_data) {
      $even_menu = !$even_menu;
      $count_menu++;

      $list = array();

      $list['attributes'] = array();
      $list['attributes']['id'] = array('workbench_menu-' . $menu_id);
      $list['attributes']['class'] = array();
      $list['attributes']['class'][] = 'menu';
      $list['attributes']['class'][] = 'workbench_menu';
      $list['attributes']['class'][] = 'workbench_menu-weight_' . $built_menus_weight;
      $list['attributes']['class'][] = 'workbench_menu-count_' . $count_menu;
      $list['attributes']['class'][] = 'workbench_menu-depth_' . $menu_depth;

      if (!$menu_data['show_parents']) $show_parents = FALSE;

      $variables = array();
      $variables['menu_id'] = &$menu_id;
      $variables['even_menu'] = &$even_menu;
      $variables['count_menu'] = &$count_menu;
      $variables['settings'] = &$menu_data['settings'];
      $variables['even_item'] = TRUE;
      $variables['count_item'] = 0;
      $variables['even_item_local'] = TRUE;
      $variables['count_item_local'] = 0;
      $variables['depth'] = 0;
      $variables['trail_is_active'] = FALSE;

      foreach ($menu_data['structure'] as $weight => &$items) {
        foreach ($items as $id => &$children) {
          $variables['id'] = &$id;
          $variables['children'] = &$children;

          $list['items'][] = workbench_menu_render_menu_item($variables, $path_current, $function_history);
        }
      }

      $rendered[$built_menus_weight] .= theme('item_list', $list);
    }
  }

  return $rendered;
}

/**
 * Render the contents of a pre-built menu item into html menu items.
 *
 * This function is recursive.
 *
 * @param array $variables
 *   An array containing the following keys:
 *   - 'menu_id': The id of the menu in which an item belongs to.
 *   - 'even_menu': A boolean representing whether or not the item's
 *   menu is even or odd.
 *   - 'count_menu': An auto-incremented number assigned to the menu.
 *   - 'settings': An array containing all settings associated with
 *   the menu item.
 *   - 'even_item': A boolean representing whether or not this item
 *   is even or odd.
 *   - 'count_item': An auto-incremented number assigned to the item.
 *   - 'even_item_local': An auto-incremented number assigned to the
 *   item that is reset between recursive calls.
 *   - 'count_item_local':
 *   - 'depth': An auto-incremented number that is incremented each
 *   time this function recurses.
 *   - 'trail_is_active': A boolean representing whether or not the
 *   item or its children is active and thus the trail is active.
 *   - 'invalid_trail_active': A boolean representing that the trail
 *   is active but there is no actual active item because the path
 *   is invalid (or has no item associated with it).
 * @param string $path_current
 *   A string containing the complete url path that is currently
 *   active.
 * @param array $path_parts
 *   An array of sub-strings derived from the $path_current variable.
 *   This is normally done via explode('/', $path_current).
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @return array
 *   A list structured in such a way that it can be directly passed
 *   to theme_item_list().
 *
 * @see workbench_menu_render_menus()
 * @see theme_item_list()
 */
function workbench_menu_render_menu_item(&$variables, $path_current, array $function_history = array()) {
  static $wmm_css = 'menu';
  static $wmi_css = 'menu_item';

  $variables['even_item'] = !$variables['even_item'];
  $variables['count_item']++;
  $variables['even_item_local'] = !$variables['even_item_local'];
  $variables['count_item_local']++;
  $variables['trail_is_active'] = FALSE;
  $variables['invalid_trail_active'] = FALSE;

  $list = array();
  $list['id'] = array();
  $list['data'] = array();
  $list['class'] = array();
  $list['children'] = array();

  $alter_settings = array();
  $alter_settings['variables'] = $variables;

  if ($variables['settings'][$variables['id']]['active_path'] == $path_current) {
    $variables['trail_is_active'] = TRUE;
    $variables['settings'][$variables['id']]['attributes']['class'][] = 'active';
  }
  else {
    if (preg_match('@' . $variables['settings'][$variables['id']]['active_path'] . '@', $path_current) > 0) {
      $path_current_parts = explode('/', $path_current);

      while (!empty($path_current_parts)) {
        if (implode('/', $path_current_parts) == $variables['settings'][$variables['id']]['active_path']) {
          $variables['invalid_trail_active'] = TRUE;
          $variables['trail_is_active'] = TRUE;
          $variables['settings'][$variables['id']]['attributes']['class'][] = 'invalid_active';
          break;
        }

        array_pop($path_current_parts);
      }
    }
  }

  if ($variables['trail_is_active'] && isset($variables['settings'][$variables['id']]['breadcrumbs'])) {
    $bc = $variables['settings'][$variables['id']]['breadcrumbs'];

    // always show the topmost breadcrumb even when on the top-level path.
    // (this is different from normal-breadcrumb behavior and is intentional.)
    // @todo: look into providing an option for users to control this behavior.
    if (count($bc) > 1 && !$variables['invalid_trail_active']) {
      array_pop($bc);
    }

    drupal_set_breadcrumb($bc);
  }

  if (empty($variables['children'])) {
    $variables['settings'][$variables['id']]['attributes']['class'][] = 'leaf';
  }
  else {
    $child_variables = array();
    $child_variables['menu_id'] = &$variables['menu_id'];
    $child_variables['even_menu'] = &$variables['even_menu'];
    $child_variables['count_menu'] = &$variables['count_menu'];
    $child_variables['settings'] = &$variables['settings'];
    $child_variables['even_item'] = &$variables['even_item'];
    $child_variables['count_item'] = &$variables['count_item'];
    $child_variables['even_item_local'] = TRUE;
    $child_variables['count_item_local'] = 0;
    $child_variables['depth'] = $variables['depth'] + 1;
    $child_variables['trail_is_active'] = FALSE;
    $child_variables['invalid_trail_active'] = FALSE;

    $child_list = array();

    foreach ($variables['children'] as $weight => &$items) {
      foreach ($items as $id => &$children) {
        $child_variables['id'] = &$id;
        $child_variables['children'] = &$children;

        $item = workbench_menu_render_menu_item($child_variables, $path_current, $function_history);

        $child_list[] = $item;

        if ($child_variables['trail_is_active']) {
          $variables['trail_is_active'] = TRUE;

          if ($child_variables['invalid_trail_active']) {
            $variables['invalid_trail_active'] = TRUE;
          }
        }
      }
    }

    if ($variables['trail_is_active']) {
      if ($variables['settings'][$variables['id']]['expand'] == 'expand_always' || $variables['settings'][$variables['id']]['expand'] == 'expand_auto') {
        $variables['settings'][$variables['id']]['attributes']['class'][] = 'expanded';
        $list['children'] = &$child_list;
      }
      else if ($variables['settings'][$variables['id']]['expand'] == 'expand_never') {
        $variables['settings'][$variables['id']]['attributes']['class'][] = 'collapsed';

        if ($variables['invalid_trail_active']) {
          $variables['settings'][$variables['id']]['attributes']['class'][] = 'invalid_active';
        }
        else {
          $variables['settings'][$variables['id']]['attributes']['class'][] = 'active';
        }
      }
    }
    else {
      if ($variables['settings'][$variables['id']]['expand'] == 'expand_always') {
        $variables['settings'][$variables['id']]['attributes']['class'][] = 'expanded';
        $list['children'] = &$child_list;
      }
      else if ($variables['settings'][$variables['id']]['expand'] == 'expand_never' || $variables['settings'][$variables['id']]['expand'] == 'expand_auto') {
        $variables['settings'][$variables['id']]['attributes']['class'][] = 'collapsed';
      }
    }
  }

  if ($variables['trail_is_active'] || preg_match('@^' . $variables['settings'][$variables['id']]['active_path'] . '/@', $path_current) > 0) {
    $variables['settings'][$variables['id']]['attributes']['class'][] = 'active-trail';
  }

  $variables['settings'][$variables['id']]['attributes']['class'][] = ($variables['even_menu'] ? 'menu_even' : 'menu_odd') ;
  $variables['settings'][$variables['id']]['attributes']['class'][] = ($variables['even_item'] ? 'even' : 'odd') ;
  $variables['settings'][$variables['id']]['attributes']['class'][] = ($variables['even_item_local'] ? 'local_even' : 'local_odd') ;
  $variables['settings'][$variables['id']]['attributes']['class'][] = 'menu_' . $variables['count_menu'];
  $variables['settings'][$variables['id']]['attributes']['class'][] = 'row_' . $variables['count_item'];
  $variables['settings'][$variables['id']]['attributes']['class'][] = 'local_row_' . $variables['count_item_local'];
  $variables['settings'][$variables['id']]['attributes']['class'][] = 'depth_' . $variables['depth'];

  $variables['count_item']++;
  $variables['even_item_local'] = !$variables['even_item_local'];
  $variables['count_item_local']++;

  if (empty($list['children'])) unset($list['children']);

  // @todo: write the api for this alter function
  drupal_alter(__FUNCTION__, $alter_settings);

  $id = implode(' ', $variables['settings'][$variables['id']]['attributes']['id']);
  $list['id'] = array('id' => $id . '-container');

  $class = implode(' ', $variables['settings'][$variables['id']]['attributes']['class']);
  $list['class'] = array('class' => $wmi_css . '-container ' . $class);

  $list['data'] = $variables['settings'][$variables['id']]['prefix'];

  $attributes = '';
  if (!empty($variables['settings'][$variables['id']]['attributes'])) {
    foreach ($variables['settings'][$variables['id']]['attributes'] as $attribute => &$values) {
      $attributes .= $attribute . '="';

      if ($attribute == 'class') {
        $attributes .= $wmi_css . ' ';
      }

      $attributes .= implode(' ', $values);
      $attributes .=  '" ';
    }
  }

  if (!empty($variables['settings'][$variables['id']]['attributes']['href'])) {
    $list['data'] .= '<div id="' . $id . '-wrapper" class="' . $wmi_css . '-wrapper ' . $class . '"><a ' . $attributes . '>' . $variables['settings'][$variables['id']]['label'] . '</a></div>';
  }
  else {
    $list['data'] .= '<div id="' . $id . '-wrapper" class="' . $wmi_css . '-wrapper ' . $class . '"><span ' . $attributes . '>' . $variables['settings'][$variables['id']]['label'] . '</span></div>';
  }

  $list['data'] .= $variables['settings'][$variables['id']]['postfix'];

  return $list;
}

/**
 * Get an array of supported options for a given option type.
 *
 * @param string $type
 *   A string representing the type of option to load.
 *   Known types are:
 *   - expand
 *   - position
 *   - item_type
 * @param int|string|null $option
 *   (optional) Providing a valid numeric id or machine name string
 *   will cause the return value to only contain the option that
 *   matches this string or numeric id.
 * @param array $function_history
 *   (optional)An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @return array
 *   An array of supported options.
 *   The array keys are the machine names for each option.
 */
function workbench_menu_get_options($type, $option = NULL, array $function_history = array()) {
  $options = &drupal_static(__FUNCTION__, NULL);

  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_string($type)) {
    cf_error_not_string($function_history, 'type');
    return array();
  }

  if (!is_null($option) && !is_string($option)) {
    cf_error_not_string($function_history, 'option');
    return array();
  }

  if (isset($options[$type])) {
    if (!is_null($option)) {
      if (is_numeric($option)) {
        foreach ($options[$type] as $key => &$value) {
          if ($value->id == $option) {
            return $options[$type][$key];
          }
        }
      }
      else {
        if (isset($options[$type][$option])) {
          return $options[$type][$option];
        }
      }

      return array();
    }

    return $options[$type];
  }

  // $type is turned into a database table name, so only allow lowercase characters and underscores
  if (preg_match('/^(\w|_)+$/', $type) == 0) {
    return array();
  }

  $type = strtolower($type);

  $table = 'workbench_menu_options_' . $type;

  $query = db_select($table, 'wmot');

  $query->fields('wmot');
  $query->orderBy('wmot.id', 'ASC');

  try {
    $records = $query->execute()->fetchAll();
  }
  catch (Exception $e) {
    cf_error_on_query_execution($function_history, $e);

    return array();
  }

  $options[$type] = array();

  foreach ($records as &$record) {
    if (!is_object($record)) continue;

    $options[$type][$record->machine_name] = &$record;
  }

  if (!is_null($option)) {
    if (is_numeric($option)) {
      foreach ($options[$type] as $key => &$value) {
        if ($value->id == $option) {
          return $options[$type][$key];
        }
      }
    }
    else {
      if (isset($options[$type][$option])) {
        return $options[$type][$option];
      }
    }

    return array();
  }


  return $options[$type];
}

/**
 * Returns a list of options.
 *
 * This is only a list of the machine_name and human_name of the
 * select lists.
 * Use this for populating select lists, radio buttons, and check
 * boxes.
 *
 * @param string $type
 *   A string representing the type of option to load.
 *   Known types are:
 *   - expand
 *   - position
 *   - item_type
 * @param array|null $option
 *   (optional) Providing a valid array of options as returned by
 *   workbench_menu_get_options() and it will be properly converted
 *   into a options list.
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @return
 *  An array of supported options.
 *  The array keys are the standard machine name and the array value
 *  is the human name.
 *
 * @see workbench_menu_get_options()
 */
function workbench_menu_get_options_list($type, $options = NULL, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (isset($options_list[$type])) {
    return $options_list[$type];
  }

  if (is_null($options)) {
    $options = workbench_menu_get_options($type, NULL, $function_history);
  }

  if (!is_array($options_list)) {
    $options_list = array();
  }

  $options_list[$type] = array();

  foreach ($options as $machine_name => $value) {
    if (!is_object($value)) continue;

    $options_list[$type][$value->machine_name] = $value->human_name;
  }

  return $options_list[$type];
}

/**
 * Obtain a list of available menus.
 *
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @return array
 *  An array of options with the menus taxonomy id as the key and the
 *  taxonomy human name as the value.
 */
function workbench_menu_get_menus_options_list(array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (isset($options_list)) {
    return $options_list;
  }

  $tree = workbench_access_get_active_tree();
  $options_list = array();

  foreach ($tree['active'] as $key => &$active) {
    if (!is_numeric($key)) unset($tree['active'][$key]);
  }

  $terms = taxonomy_term_load_multiple(array_keys($tree['active']));

  foreach ($terms as &$term) {
    $options_list[$term->tid] = $term->name;
  }

  asort($options_list);

  return $options_list;
}

/**
 * Obtains the menus associated with a given path or paths.
 *
 * This matches against the menus that are the depest-level children
 * of a given path.
 * That is, if there exist menus at /a/, /a/b/, and /a/b/c/ and the
 * current path is /a/b/d, then only the menu at path /a/b/ is
 * returned.
 *
 * @param string|array $paths
 *   A path string or an array of path strings.
 *   If a string is passed, the string will be broken down into an
 *   array of parts like this: '/a/b/c/d' -> array('a', 'a/b',
 *   'a/b/c', 'a/b/c/d').
 *   If an array is passed, the strings will be used as is without
 *   being broken down.
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @return array
 *   An array of menu objects for the given path.
 */
function workbench_menu_get_menus_at_paths($paths, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  if (is_string($paths)) {
    $parts = explode('/', $paths);
    $matches = array();
    $path_string = '';

    foreach ($parts as &$part) {
      $path_string .= $part;
      $matches[] = $path_string;
      $path_string .= '/';
    }
  }
  else if (is_array($paths)) {
    $matches = &$paths;
  }
  else {
    cf_error_invalid_variable($function_history, 'paths', "Must be a string or an array of strings.");
    return array();
  }

  return (array) workbench_menu_get_menus(array('path' => $matches), 'id', $function_history);
}

/**
 * Obtains the menus associated with a given node or node id.
 *
 * @param $node_or_nid
 *   A node or a node id.
 *
 * @return
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_menus_at_node($node_or_nid, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_object($node_or_nid) && !is_numeric($node_or_nid)) {
    cf_error_invalid_variable($function_history, 'node_or_nid', "Must be either a node object or a number");
    return array();
  }

  if (is_numeric($node_or_nid)) {
    $node = node_load($node_or_nid);
  }
  else {
    $node = &$node_or_nid;
  }

  if (!property_exists($node, 'workbench_access') || empty($node->workbench_access)) {
    return array();
  }

  $path_node = 'node/' . $node->nid;
  $path_alias = drupal_get_path_alias($path_node);

  if ($path_alias == $path_node) {
    $menus = (array) workbench_menu_get_menus(array('access_id' => $node->workbench_access), 'id', $function_history);

    return $menus;
  }

  return workbench_menu_get_menus_at_paths($path_alias, $function_history);
}

/**
 * Obtains the menus for the given menu ids.
 *
 * @param array $conditions
 *   (optional) An array with the following possible keys:
 *   - id: A unique id representing a specific menu or an array of
 *   ids.
 *   - access_id: A unique access id representing a specific
 *   workbench access group or an array of access ids.
 *   - path: A path string associated with a given meny or an array
 *   of path strings.
 * @param string|null $keyed
 *   (optional) A string matching one of the following: 'id',
 *   'access_id'
 *   When this is NULL, the default behavior is to return the array
 *   exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array
 *   will use the specified key name.
 *
 * @return array
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_menus($conditions = array(), $keyed = NULL, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_array($conditions)) {
    cf_error_invalid_array($function_history, 'conditions');
    return array();
  }

  $query = db_select('workbench_menus', 'wm');
  $query->innerjoin('workbench_access', 'wa', 'wm.access_id = wa.access_id');
  $query->fields('wm');

  $query->orderBy('weight', 'ASC');
  $query->orderBy('id', 'ASC');

  $and = db_and();
  $and->condition('wa.access_type', 'taxonomy');

  if (isset($conditions['id'])) {
    if (is_numeric($conditions['id'])) {
      $and->condition('id', $conditions['id']);
    }
    else if (is_array($conditions['id']) && !empty($conditions['id'])) {
      $and->condition('id', $conditions['id'], 'IN');
    }
  }

  if (isset($conditions['access_id'])) {
    if (is_numeric($conditions['access_id'])) {
      $and->condition('wm.access_id', $conditions['access_id']);
    }
    else if (is_array($conditions['access_id']) && !empty($conditions['access_id'])) {
      $and->condition('wm.access_id', $conditions['access_id'], 'IN');
    }
  }

  if (isset($conditions['path'])) {
    if (is_string($conditions['path'])) {
      $and->condition('path', $conditions['path']);
    }
    else if (is_array($conditions['path']) && !empty($conditions['path'])) {
      $and->condition('path', $conditions['path'], 'IN');
    }
  }

  $query->condition($and);
  $menus = array();

  if ($keyed == 'id' || $keyed == 'access_id') {
    try {
      $records = $query->execute();
    }
    catch (Exception $e) {
      cf_error_on_query_execution($function_history, $e);
      return array();
    }

    foreach ($records as $record) {
      if (!is_object($record)) continue;

      $menus[$record->$keyed] = $record;
    }
  }
  else {
    try {
      $menus = (array) $query->execute()->fetchAll();
    }
    catch (Exception $e) {
      cf_error_on_query_execution($function_history, $e);
    }
  }

  // load all menu additional menu data
  if (!empty($menus)) {
    $static_menus = &drupal_static(__FUNCTION__, NULL);

    if (is_null($static_menus)) {
      $static_menus = array('menu' => array(), 'access_id' => array());
    }

    foreach ($menus as &$menu) {
      if (isset($static_menus['menu'][$menu->id])) {
        $menu = $static_menus['menu'][$menu->id];
        continue;
      }
      else {
        $static_menus['menu'][$menu->id] = &$menu;
      }

      $menu->items = (array) workbench_menu_get_load_menu_items(array('menu_id' => $menu->id), 'id', $function_history);
      $menu->taxonomy = taxonomy_term_load($menu->access_id);

      $static_menus['menu'][$menu->id] = $menu;
      $static_menus['access_id'][$menu->access_id] = $menu->id;
    }
  }

  return $menus;
}

/**
 * Save the settings for one or more menus.
 *
 * This function clears the workbench_menu menu cache.
 *
 * @param array $item_ids
 *   An array of menu setting arrays with the following keys:
 *   - 'id': (optional) This is the primary key for a specific row in
 *   the workbench_menu table.
 *   - 'access_id': This is the unique access_id that represents the
 *   workbench access group to save.
 *   - 'path': This is the url path string of the menu.
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function workbench_menu_save_menus($menus, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_array($menus)) {
    cf_error_invalid_array($function_history, 'menus');
    return FALSE;
  }

  if (empty($menus)) {
    return TRUE;
  }

  $static_menus = &drupal_static('workbench_menu_get_menus', NULL);
  $transaction = db_transaction();

  try {
    foreach ($menus as $key => &$menu) {
      if (!is_array($menu)) {
        cf_error_invalid_array($function_history, 'menus[' . $key . ']');
        continue;
      }

      $query = db_select('workbench_menus', 'wm');
      $query->fields('wm');

      $record = array();
      $record['path'] = $menu['path'];
      $record['weight'] = $menu['weight'];
      $record['show_parents'] = $menu['show_parents'];
      $record['breadcrumb_name'] = $menu['breadcrumb_name'];

      if (isset($menu['id'])) {
        $record['id'] = $menu['id'];

        $query->condition('id', $menu['id']);

        $existing = (array) $query->execute()->fetchAll();

        if (empty($existing)) {
          unset($record['id']);
        }

        unset($query);
      }
      else if (isset($menu['access_id'])) {
        $record['access_id'] = $menu['access_id'];

        $query->condition('access_id', $menu['access_id']);

        $existing = (array) $query->execute()->fetchAll();

        if (!empty($existing)) {
          $row = array_pop($existing);
          $record['id'] = $row->id;
        }

        unset($query);
      }

      if (isset($record['id'])) {
        $rx = drupal_write_record('workbench_menus', $record, array('id'));
      }
      else {
        drupal_write_record('workbench_menus', $record);
      }

      foreach ($menu['items'] as &$menu_item) {
        $record = array();

        $record['menu_id'] = $menu_item['menu_id'];
        $record['parent_id'] = $menu_item['parent_id'];
        $record['properties'] = $menu_item['properties'];

        if (property_exists($menu_item, 'id')) {
          $record['id'] = $menu_item['id'];
          drupal_write_record('workbench_menu_items', $record, array('id'));
        }
        else {
          drupal_write_record('workbench_menu_items', $record);
        }
      }

      if (isset($menu['id'])) {
        $static_menus['menu'][$menu['id']] = $menu;
      }
      else if (isset($menu['access_id'])) {
        $query = db_select('workbench_menus', 'wm');
        $query->fields('wm');
        $query->condition('access_id', $menu['access_id']);

        $records = (array) $query->execute()->fetchAll();

        if (!empty($records)) {
          $record = array_pop($records);
          $static_menus['menu'][$record->id] = $menu;
        }
      }
    }

    // enforce transaction execution
    unset($transaction);
  }
  catch (Exception $e) {
    $transaction->rollback();
    cf_error_on_query_execution($function_history, $e);
    return FALSE;
  }

  return TRUE;
}

/**
 * Loads menu items from the database based on the given conditions.
 *
 * @param array $conditions
 *   (optional) An array with the following possible keys:
 *   - 'id' A unique id representing a specific item or an array of
 *   ids.
 *   - 'menu_id' A unique menu id representing a specific menu or an
 *   array of menu ids.
 *   - 'parent_id' A unique parent id representing a specific parent
 *   or an array of parent ids.
 *   - 'human_name' A human name string of a menu item or an array of
 *   human name strings.
 *   - 'weight' A number representing the weight or an array of
 *   weight numbers.
 * @param string|null $keyed
 *   (optional) A string matching one of the following: 'id',
 *   'menu_id'.
 *   When this is NULL, the default behavior is to return the array
 *   exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array
 *   will use the specified key name.
 * @param $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @return array
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_load_menu_items($conditions = array(), $keyed = NULL, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  $sorted_menu_items = array();
  $sorted_menu_items['flat'] = array();
  $sorted_menu_items['nested'] = array();

  if (!is_array($conditions)) {
    cf_error_invalid_array($function_history, 'conditions');
    return $sorted_menu_items;
  }

  $query = db_select('workbench_menu_items', 'wmi');
  $query->fields('wmi');

  $query->orderBy('parent_id', 'ASC');
  $query->orderBy('weight', 'ASC');
  $query->orderBy('human_name', 'ASC');
  $query->orderBy('id', 'ASC');

  $and = db_and();

  if (isset($conditions['id'])) {
    if (is_numeric($conditions['id'])) {
      $and->condition('id', $conditions['id']);
    }
    else if (is_array($conditions['id']) && !empty($conditions['id'])) {
      $and->condition('id', $conditions['id'], 'IN');
    }
  }

  if (isset($conditions['menu_id'])) {
    if (is_numeric($conditions['menu_id'])) {
      $and->condition('menu_id', $conditions['menu_id']);
    }
    else if (is_array($conditions['menu_id']) && !empty($conditions['menu_id'])) {
      $and->condition('menu_id', $conditions['menu_id'], 'IN');
    }
  }

  if (isset($conditions['parent_id'])) {
    if (is_numeric($conditions['parent_id'])) {
      $and->condition('parent_id', $conditions['parent_id']);
    }
    else if (is_array($conditions['parent_id']) && !empty($conditions['parent_id'])) {
      $and->condition('parent_id', $conditions['parent_id'], 'IN');
    }
  }

  if (isset($conditions['weight'])) {
    if (is_numeric($conditions['weight'])) {
      $and->condition('weight', $conditions['weight']);
    }
    else if (is_array($conditions['weight']) && !empty($conditions['weight'])) {
      $and->condition('weight', $conditions['weight'], 'IN');
    }
  }

  if (isset($conditions['human_name'])) {
    if (is_string($conditions['human_name'])) {
      $and->condition('human_name', $conditions['human_name']);
    }
    else if (is_array($conditions['human_name']) && !empty($conditions['human_name'])) {
      $and->condition('human_name', $conditions['human_name'], 'IN');
    }
  }

  $query->condition($and);
  $menu_items = array();

  if ($keyed == 'id' || $keyed == 'menu_id') {
    try {
      $records = $query->execute();
    }
    catch (Exception $e) {
      cf_error_on_query_execution($function_history, $e);
      return $sorted_menu_items;
    }

    foreach ($records as $record) {
      if (!is_object($record)) continue;

      $menu_items[$record->$keyed] = $record;
    }
  }
  else {
    try {
      $menu_items = (array) $query->execute()->fetchAll();
    }
    catch (Exception $e) {
      cf_error_on_query_execution($function_history, $e);
    }
  }

  if (!empty($menu_items)) {
    // use a separate queries to load all many-to-many relationships
    foreach ($menu_items as $menu_item_key => &$menu_item) {
      $id = $menu_item->id;

      if (!isset($sorted_menu_items['flat'][$id])) {
        $sorted_menu_items['flat'][$id] = array();
        $sorted_menu_items['flat'][$id]['children'] = array();
      }

      $sorted_menu_items['flat'][$id]['item'] = $menu_item;

      if ($menu_item->parent_id == 0) {
        $sorted_menu_items['nested'][$id] = &$sorted_menu_items['flat'][$id];
      }
      else {
        if (!isset($sorted_menu_items['flat'][$menu_item->parent_id])) {
          $sorted_menu_items['flat'][$menu_item->parent_id] = array();
          $sorted_menu_items['flat'][$menu_item->parent_id]['children'] = array();
        }

        $sorted_menu_items['flat'][$menu_item->parent_id]['children'][$id] = &$sorted_menu_items['flat'][$id];
      }

      $menu_item->properties = unserialize($menu_item->properties);

      foreach (array('expand', 'item_type') as $name) {
        $results = array();

        $query = db_select('workbench_menu_options_' . $name, 'wmon');
        $query->innerjoin('workbench_menu_' . $name . 's',  'wmn', 'wmon.id = wmn.' . $name . '_id');
        $query->fields('wmon');
        $query->addField('wmn', 'item_id', 'item_id');

        $query->condition('wmn.item_id', $id);

        try {
          $records = $query->execute();

          foreach ($records as $record) {
            $results[$record->id] = $record;
          }
        }
        catch (Exception $e) {
          cf_error_on_query_execution($function_history, $e);
        }

        $menu_item->$name = $results;
      }
    }
  }

  return $sorted_menu_items;
}

/**
 * Obtains a select list of for menu items loaded from the database.
 *
 * @param array $conditions
 *   (optional)An array that is passed directly to
 *   workbench_menu_get_load_menu_items().
 * @param string|null $keyed
 *   (optional) A string that is passed directly to
 *   workbench_menu_get_load_menu_items().
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @return array
 *   A processed array select list of menu objects for the given
 *   node.
 *
 * @see workbench_menu_get_load_menu_items()
 */
function workbench_menu_get_load_menu_items_select_list_options($conditions = array(), $keyed = NULL, array $function_history = array()) {
  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (is_null($options_list)) {
    $items = (array) workbench_menu_get_load_menu_items($conditions, $keyed, $function_history);

    foreach ($items['flat'] as &$i) {
      $available_parents[$i['item']->id] = $i['item']->human_name;
    }

    $data = array();
    $data['options'] = array('0' => "<No Parent>");

    foreach ($items['nested'] as &$nested_item) {
      workbench_menu_get_load_menu_items_select_list_options_recursive_walk($nested_item, $data, $function_history);
    }

    $options_list = $data['options'];
  }

  return $options_list;
}

/**
 * Load menu item children.
 *
 * This function is recursive.
 *
 * @param object $item
 *   The menu item object.
 * @param array $data
 *   An array of data globally shared between the different recursive calls.
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 *
 * @see workbench_menu_get_load_menu_items_select_list_options()
 */
function workbench_menu_get_load_menu_items_select_list_options_recursive_walk(&$item, &$data, array $function_history = array()) {
  cf_error_append_history($function_history, __FUNCTION__);

  if (!isset($data['depth'])) {
    $data['depth'] = 0;
  }

  if ($data['depth'] > 0) {
    $data['options'][$item['item']->id] = str_repeat('- ', $data['depth']) . $item['item']->human_name;
  }
  else {
    $data['options'][$item['item']->id] = $item['item']->human_name;
  }

  if (!empty($item['children'])) {
    $data['depth']++;

    foreach ($item['children'] as &$child) {
      workbench_menu_get_load_menu_items_select_list_options_recursive_walk($child, $data, $function_history);
    }

    $data['depth']--;
  }
}

/**
 * Validate that a user has menu edit access.
 *
 * @param string|null $access_type
 *   The type of access requested (e.g. taxonomy).
 *   If NULL is passed, then this simply returnes whether or not the
 *   user has 'edit workbench menu' access.
 *
 * @param int|null $access_type_id
 *   The access_id to validate against.
 *   If NULL is passed, then this simply returnes whether or not the
 *   user has 'edit workbench menu' access.
 *
 * @see workbench_access_get_access_tree()
 */
function workbench_menu_edit_access($access_type = NULL, $access_type_id = NULL) {
  if ($access_type == NULL || $access_type_id == NULL) return user_access('edit workbench menu');

  if (!user_access('edit workbench menu')) return FALSE;

  if ($access_type == 'taxonomy') {
    $access = workbench_access_get_access_tree();

    if (array_key_exists($access_type_id, $access)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Clears the workbench menu cache for the menu cache for some path.
 *
 * @param string $path
 *   A string representing the path to clear.
 * @param array $function_history
 *   (optional) An array of function names, ie:
 *   array('0' => 'my_function_name').
 */
function workbench_menu_clear_cache_at_path($path, $function_history) {
  cf_error_append_history($function_history, __FUNCTION__);

  $parts = explode('/', $path);
  $menu_cache_id = 'workbench_menu-menus_at-' . $parts[0];
  $breadcrumb_cache_id = 'workbench_menu-breadcrumbs_at-' . $parts[0];

  $cached_menu = cache_get($menu_cache_id, 'cache_menu');
  $cached_breadcrumb = cache_get($breadcrumb_cache_id, 'cache_menu');

  while (!empty($parts)){
    $subpath = implode('/', $parts);
    $part = array_pop($parts);

    if (empty($part)) continue;

    if ($cached_menu) {
      $menus_cached = $cached_menu->data;
      unset($menus_cached[$subpath]);
    }

    if ($cached_breadcrumb) {
      $breadcrumbs_cached = $cached_breadcrumb->data;
      unset($breadcrumbs_cached[$subpath]);
    }
  }

  if ($cached_menu) {
    cache_set($menu_cache_id, $menus_cached, 'cache_menu');
  }

  if ($cached_breadcrumb) {
    cache_set($menu_cache_id, $breadcrumbs_cached, 'cache_menu');
  }
}
