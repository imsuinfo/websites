<?php

/**
 * Implements hook_help().
 */
function quail_api_node_help($path, $arg) {
  $output = '';

  switch ($path) {
    case "admin/help#quail_api_node":
      $output .= '<p>' . t("This module provides accessibilty validation support on node entities.") . '</p>';
      return $output;
  }
}

/**
 * Implements hook_quail_api_permission_alter().
 */
function quail_api_node_quail_api_permission_alter(&$permissions) {
  $permissions = array();

  $permissions['access node accessibility tab'] = array(
    'title' => t("Access Node Accessibility Tab"),
    'description' => t("Grants permissions to access the accessibility tab on node pages."),
  );

  $permissions['perform node accessibility validation'] = array(
    'title' => t("Perform node accessibility validation"),
    'description' => t("Grants permissions to use the perform a manual validation of any given node."),
  );

  // @todo: add node-specific validation permissions or at the very least node_type-specific

  return $permissions;
}


/**
 * Implements hook_action_info().
 */
function quail_api_node_action_info() {
  return array(
    'quail_api_node_validate_action' => array(
      'type' => 'node',
      'label' => t("Accessibility validate content"),
      'configurable' => FALSE,
      'triggers' => array('node_presave', 'node_insert', 'node_update'),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function quail_api_node_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'quail_api_node'),
  );
}

/**
 * Implements hook_menu().
 */
function quail_api_node_menu() {
  $items = array();

  $items['node/%node/accessibility'] = array(
    'title' => "Accessibility",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quail_api_node_accessibility_tab_page', 1),
    'access callback' => 'quail_api_node_access_accessibility_tab',
    'access arguments' => array(1),
    'file' => 'pages.inc',
    'file path' => drupal_get_path('module', 'quail_api_node') . '/includes',
    'weight' => 8,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  return $items;
}

/**
 * Implements hook_menu().
 */
function quail_api_node_admin_paths() {
  $paths = array();

  $paths['node/*/accessibility'] = TRUE;

  return $paths;
}

/**
 * Checks if user can access the
 *
 * @param $node
 *   A node object whose access is to be returned.
 *
 * @return
 *   TRUE if user can make conversions using this type, FALSE otherwise.
 */
function quail_api_node_access_accessibility_tab($node) {
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $access = FALSE;

  if (!is_object($node)){
    cf_error_invalid_object($function_history, 'node');
    return $access;
  }

  if (node_access('view', $node)){
    $access = user_access('access node accessibility tab');

    if ($access && quail_api_node_is_enabled($node->type)){
      $access = TRUE;
    }
    else {
      $access = FALSE;
    }
  }

  return $access;
}

/**
 * Implements hook_form_FORM_ID_alter() for the node type form.
 */
function quail_api_node_form_node_type_form_alter(&$form, &$form_state, $form_id) {
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $node_type_settings_object = FALSE;
  $node_type_settings_array  = array('type' => NULL, 'required' => NULL, 'standards' => NULL);

  $standards = quail_api_get_standards_list(NULL, 'snippet', $function_history);
  $display_levels = quail_api_get_display_levels_list(NULL, $function_history);
  $methods = quail_api_get_validation_methods(NULL, $function_history);
  $methods_list = quail_api_get_validation_methods_list(NULL, $function_history);
  $filter_formats = filter_formats();
  $formats = array();
  $options = array();

  foreach ($filter_formats as $filter_format => $filter_format_settings){
    $formats[$filter_format] = $filter_format_settings->name;
  }

  $default_enabled = 'disabled';
  $default_standards = array();
  $default_method = 'quail_api_method_immediate';
  $default_format = 'full_html';

  if (!empty($form['#node_type']->type)){
    $node_type_settings_objects = quail_api_node_load_node_type_settings(array($form['#node_type']));

    if (!empty($node_type_settings_objects)){
      $node_type_settings_object = $node_type_settings_objects['0'];

      $default_enabled = ($node_type_settings_object->required ? 'required' : 'optional');
      $default_standards = unserialize($node_type_settings_object->standards);
      $default_method = (!empty($node_type_settings_object->method) ? $node_type_settings_object->method : $default_method);
      $default_format = (!empty($node_type_settings_object->format) ? $node_type_settings_object->format : $default_format);
    }
  }

  $form['node_accessibility_validation'] = array(
    '#type' => 'fieldset',
    '#title' => t("Accessiblity Validation"),
    '#description' => t("Provides options for enabled and disabled accessibility validation on text stored in this field."),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE,
    '#group' => 'additional_settings',
  );

  $form['node_accessibility_validation']['quail_enabled'] = array(
    '#type' => 'select',
    '#title' => t("Accessibility Validation"),
    '#default_value' => $default_enabled,
    '#options' => array(
      'disabled' => t("Disabled"),
      'optional' => t("Enabled (optional)"),
      'required' => t("Enabled (required)"),
    ),
    '#description' => t("Choose if accessibility validation should be enabled for this field and if the field is required to pass accessibility validation."),
  );

  $form['node_accessibility_validation']['method'] = array(
    '#type' => 'select',
    '#title' => t("Validation Method"),
    '#default_value' => $default_method,
    '#options' => $methods_list,
    '#description' => t("Choose the way in which validation is performed."),
  );

  // add documentation for each option
  $form['node_accessibility_validation']['method']['#description'] .= '<ul>';
  foreach ($methods as $method => $method_settings){
    $form['node_accessibility_validation']['method']['#description'] .= '<li>' . $method_settings['human_name'] . ': ' . $method_settings['description'] . '</li>';
  }
  $form['node_accessibility_validation']['method']['#description'] .= '</ul>';

  $form['node_accessibility_validation']['format'] = array(
    '#type' => 'select',
    '#title' => t("Markup Format"),
    '#default_value' => $default_format,
    '#options' => $formats,
    '#description' => t("Choose the filter to use when presenting the results of validation checks. This is only used for the html markup associated with the problem or suggestion."),
  );

  $form['node_accessibility_validation']['standards'] = array(
    '#type' => 'checkboxes',
    '#title' => t("Accessibility Standards"),
    '#default_value' => $default_standards,
    '#options' => $standards,
    '#description' => t("Choose which accessiblity standards to validate against. It is strongly suggested that only 1 standard should be used because many of the validation tests are performed by more than one standard."),
  );

  $form['#submit'][] = 'quail_api_node_node_type_form_submit';
}

/**
 * Handles submitting the accessible content specific node type settings into the database.
 *
 * @param $form
 *   A form array
 * @param $form_state
 *   A form state
 */
function quail_api_node_node_type_form_submit($form, &$form_state) {
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (cf_is_empty_or_non_string($function_history, 'form_state[values][type]', $form_state['values']['type'])){
    return;
  }

  $node_type_settings_objects = quail_api_node_load_node_type_settings(array($form_state['values']['type']), $function_history);
  $node_type_settings_object = FALSE;

  if (!empty($node_type_settings_objects)){
    $node_type_settings_object = $node_type_settings_objects['0'];
  }

  $columns = array('enabled', 'required', 'standards', 'method', 'format');
  $record = array();
  $record['type'] = $form_state['values']['type'];
  $record['method'] = isset($form_state['values']['node_accessibility_validation']['method']) ? $form_state['values']['node_accessibility_validation']['method'] : 'quail_api_method_immediate';
  $record['format'] = isset($form_state['values']['node_accessibility_validation']['format']) ? $form_state['values']['node_accessibility_validation']['format'] : 'full_html';

  if (isset($form_state['values']['node_accessibility_validation']['required'])){
    $record['required'] = $form_state['values']['node_accessibility_validation']['required'] === 'disabled';
  }
  else {
    $record['required'] = FALSE;
  }

  if (isset($form_state['values']['node_accessibility_validation']['standards'])){
    foreach($form_state['values']['node_accessibility_validation']['standards'] as $key => $value){
      if ($value == '0'){
        unset($form_state['values']['node_accessibility_validation']['standards'][$key]);
      }
    }
    $record['standards'] = $form_state['values']['node_accessibility_validation']['standards'];
  }
  else {
    $record['standards'] = array();
  }

  if (is_object($node_type_settings_object)){
    $primary_keys = array('type');
    $results = drupal_write_record('quail_api_node_types', $record, $primary_keys);
  }
  else {
    $results = drupal_write_record('quail_api_node_types', $record);
  }
}

/**
 * Implements hook_node_operations().
 */
function quail_api_node_node_operations() {
  $operations = array(
    'quail_api_node_operation_validate' => array(
      'label' => t("Accessibility Validate selected content"),
      'callback' => 'quail_api_node_operation_validate',
    ),
  );

  return $operations;
}

/**
 * Perform validation on any number of nodes.
 * Only nodes that have accessibility enabled will be validated in this way.
 * All other nodes are silently ignored.
 *
 * @param $nids
 *   An array of node ids
 */
function quail_api_node_operation_validate($nids){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $nodes = node_load_multiple($nids);
  $node_type_settings_objects = quail_api_node_load_node_type_settings($nodes, $function_history);
  $node_type_settings_types = array();

  foreach ($node_type_settings_objects as $node_type_settings_object){
    if (is_object($node_type_settings_object)){
      $node_type_settings_types[$node_type_settings_object->type] = $node_type_settings_object;
    }
  }

  unset($node_type_settings_objects);
  $result = TRUE;

  foreach ($nodes as $key => $node){
    if (!is_object($node)) continue;
    if (!array_key_exists($node->type, $node_type_settings_types)) continue;

    $methods = quail_api_get_validation_methods(NULL, $function_history);
    $database = FALSE;
    $node_settings = $node_type_settings_types[$node->type];

    if (!empty($node_settings->method) && is_array($methods) && array_key_exists('database', $methods[$node_settings->method])){
      $database = $methods[$node_settings->method]['database'];
    }

    // @fixme perhaps this is a caching issue, but the node->accessibility settings is not always accurate
    // manually create the accessibility array because it must already be enabled for the code to get this far
    if (!property_exists($node, 'accessibility') || !is_array($node->accessibility)){
      $node->accessibility = array();

      foreach ($node_settings as $key => $value){
        if ($key == 'standards'){
          $node->accessibility[$key] = unserialize($value);
        }
        else {
          $node->accessibility[$key] = $value;
        }
      }
    }

    $results = quail_api_node_perform_validation(array($node), NULL, NULL, $function_history);

    if (isset($results[$node->nid]['report'])){
      $results = $results[$node->nid]['report'];

      if ($database && !empty($results)){
        $no_failures = TRUE;

        foreach($results as $severity => $severity_results){
          if (isset($severity_results['total']) && $severity_results['total'] > 0){
            $no_failures = FALSE;
            break;
          }
        }

        if ($no_failures){
          quail_api_node_delete_node_tests($node->nid, $node->vid);
        }
        else {
          quail_api_node_save_node_tests($node->nid, $node->vid, $results);
        }
      }
    }
    else {
      $result = FALSE;
    }
  }

  if ($result){
    drupal_set_message(t("The validation has been performed."));
  }
  else {
    drupal_set_message(t("Unable to perform the validation, something went wrong."), 'error');
  }
}


/**
 * Performs validation on the given nodes and stores the results in the database.
 *
 * @param $nodes_or_nids
 *   An array of node objects or node ids
 * @param $language (optional)
 *   The language to use during validation
 * @param $display_level (optional)
 *   An array of booleans representing the qual test display levels (defaults to quail_api_create_quail_display_level_array()).
 * @param $function_history
 *   (optional) array of function names, ie: array('0' => 'my_function_name')
 *
 * @return
 *   An array of all test failures, if any.
 */
function quail_api_node_perform_validation($nodes_or_nids, $language = NULL, $display_level = NULL, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_array($nodes_or_nids)){
    cf_error_invalid_array($function_history, 'nodes_or_nids');
    return array();
  }

  if (count($nodes_or_nids) == 0){
    return array();
  }

  $function_history[] = __FUNCTION__;
  $results = array();
  $standards = quail_api_get_standards(NULL, 'snippet', $function_history);

  foreach ($nodes_or_nids as $node_or_nid){
    if (is_object($node_or_nid)){
      $node = $node_or_nid;
    } else {
      $node = node_load($node_or_nid);

      if (!is_object($node)){
        cf_error_invalid_variable($function_history, $node, "Unable to load the node with the following node id: :nid.", array(':nid' => $node_or_nid));
        continue;
      }
    }

    $results[$node->nid] = array();

    if (property_exists($node, 'accessibility') && is_array($node->accessibility)){
      $rendered_node = drupal_render(node_view($node, 'full', $language));

      if (!empty($node->accessibility['standards'])){
        foreach ($node->accessibility['standards'] as $standard_name){
          $results[$node->nid] = array_merge($results[$node->nid], quail_api_validate_markup($rendered_node, $standards[$standard_name], $display_level, $function_history));

          if (module_exists('rules')){
            rules_invoke_event('quail_api_node_after_validating', $node, $results[$node->nid]);
          }
        }
      }
    }
  }

  return $results;
}

/**
 * Implements hook_node_load().
 */
function quail_api_node_node_load($nodes, $types) {
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $all_nodes = array();

  foreach($nodes as &$node){
    $all_nodes[$node->nid] = $node;
    $all_nodes[$node->nid]->accessibility = FALSE;
  }

  $results = quail_api_node_load_node_type_settings($all_nodes, $function_history);

  foreach ($results as $result){
    $all_nodes[$node->nid]->accessibility = array();

    foreach ($result as $key => $value){
      if ($key == 'standards'){
        $all_nodes[$node->nid]->accessibility[$key] = unserialize($value);
      }
      else {
        $all_nodes[$node->nid]->accessibility[$key] = $value;
      }
    }
  }

  return $all_nodes;
}

/**
 * Loads the node type settings table data for the given node type.
 * @todo add caching support to the results of this check.
 *
 * @param $node_types
 *   An array of node type strings or node objects
 * @param $keyed (optional)
 *   A string matching one of the following: 'type'
 *   When this is NULL, the default behavior is to return the array exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array will use the specified key name.
 *
 * @return
 *   A prepared statement object, already executed.
 */
function quail_api_node_load_node_type_settings($node_types, $keyed = NULL){
  if (count($node_types) == 0){
    return array();
  }

  $query = db_select('quail_api_node_types', 'qant');

  $query->fields('qant');
  $query->orderBy('qant.type', 'ASC');

  $or = db_or();

  foreach ($node_types as $node_type){
    if (is_object($node_type)){
      $or->condition('type', $node_type->type, '=');
    }
    else {
      $or->condition('type', $node_type, '=');
    }
  }

  $query->condition($or);

  if ($keyed === 'type'){
    $records = $query->execute();
    $results = array();

    foreach ($records as $record){
      if (!is_object($record)) continue;

      $results[$record->$keyed] = $record;
    }

    return $results;
  }

  return $query->execute()->fetchAll();
}

/**
 * Saves the node report data to the database.
 *
 * @param $nid
 *   The node id of the node associated with the given reports.
 * @param $vid
 *   The node revision id of the node associated with the given reports.
 * @param $reports
 *   The reports array as returned by the quail library quail api reporter.
 *
 * @return
 *   A boolean representing the whether the save
 */
function quail_api_node_save_node_tests($nid, $vid, $reports){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_array($reports)){
    cf_error_invalid_array($function_history, 'reports');
    return FALSE;
  }

  $function_history = $function_history;

  $tests_known = (array) quail_api_load_tests(array(), 'machine_name', $function_history);
  $problems = array();

  foreach ($reports as $severity => $severity_results){
    if ($severity != 'total'){
      foreach ($severity_results as $test_name => $test_results){
        if ($test_name == 'total') continue;

        if (!(array_key_exists($test_name, $tests_known))){
          if (empty($test_results['body']['title']) || empty($test_results['body']['description'])){
            // @todo should this send a watchdog warning?
            continue;
          }

          $test_data = array();
          $test_data['machine_name'] = $test_name;
          $test_data['severity'] = $severity;
          $test_data['human_name'] = $test_results['body']['title'];
          $test_data['description'] = $test_results['body']['description'];

          $results = quail_api_save_test($test_data, $function_history);

          if ($results === FALSE){
            watchdog('quail_api', "Failed to insert :machine_name into quail api tests database table.", array(':machine_name' => $test_name), WATCHDOG_ERROR);
            continue;
          }

          // The row must be loaded from the database so that the id can be retrieved
          $loaded_test = quail_api_load_tests(array('machine_name' => $test_name), NULL, $function_history);

          if (!isset($loaded_test['0']) || !is_object($loaded_test['0'])){
            watchdog('quail_api', "Failed to insert :machine_name problems into quail api tests database table because tests_known[:machine_name] is not a valid object.", array(':machine_name' => $test_name), WATCHDOG_ERROR);
            continue;
          }

          $tests_known[$test_name] = $loaded_test['0'];
        }

        foreach ($test_results['problems'] as $problem_name => $problem) {
          if (empty($problem['line']) || empty($problem['element'])){
            // @todo should this send a watchdog warning?
            continue;
          }

          $problem_data = array();
          $problem_data['nid'] = $nid;
          $problem_data['vid'] = $vid;
          $problem_data['test_id'] = $tests_known[$test_name]->id;
          $problem_data['line'] = $problem['line'];
          $problem_data['element'] = $problem['element'];

          $problems[] = $problem_data;
        }
      }
    }
  }

  if (!empty($problems)){
    $results = quail_api_node_replace_problems($nid, $vid, $problems);

    if ($results === FALSE){
      watchdog('quail_api', "Failed to insert :machine_name problems into quail api node problems database table.", array(':machine_name' => $test_name), WATCHDOG_ERROR);
    }
  }
}

/**
 * Deletes the node report data from the database.
 * This is primarly used to remove data for a node that no longer has any validation failures.
 *
 * @param $nid
 *   The node id of the node associated with the given reports.
 * @param $vid
 *   The node revision id of the node associated with the given reports.
 *
 * @return
 *   A boolean representing the whether the save
 */
function quail_api_node_delete_node_tests($nid, $vid){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_numeric($nid)){
    cf_error_not_numeric($function_history, 'nid');
    return FALSE;
  }

  if (!is_numeric($vid)){
    cf_error_not_numeric($function_history, 'vid');
    return FALSE;
  }

  // @todo when vid support is added, be sure to add a conditional check against vid here
  $query = db_delete('quail_api_node_problems');
  $query->condition('nid', $nid);

  return $query->execute();
}

/**
 * Returns TRUE if accessibility validation functionality is enabled for the given node type.
 * @todo add caching support to the results of this check.
 *
 * @param $node_type
 *   A node type string.
 *
 * @return
 *   The return states of either FALSE, SAVED_NEW, or SAVED_UPDATED.
 */
function quail_api_node_is_enabled($node_type){
  $node_type_settings_objects = quail_api_node_load_node_type_settings(array($node_type));

  if (!empty($node_type_settings_objects) && is_object($node_type_settings_objects['0'])){
    return TRUE;
  }

  return FALSE;
}

/**
 * Returns TRUE if accessibility validation functionality is required for the given node type.
 * @todo add caching support to the results of this check.
 *
 * @param $node_type
 *   A node type string
 *
 * @return
 *   TRUE or FALSE depending on whether or not accessibility validation functionality is required for the given node type.
 *   NULL is returned if accessibility validation functionality is not enabled.
 */
function quail_api_node_is_required($node_type){
  $node_type_settings_objects = quail_api_node_load_node_type_settings(array($node_type));

  if (empty($node_type_settings_objects) || !is_object($node_type_settings_objects['0'])){
    return NULL;
  }

  // @fixme: Is this the propery way? I did this off the top of my mind and I could be doing something wrong here.
  if ($node_type_settings_objects['0']->required == TRUE){
    return TRUE;
  }

  return FALSE;
}

/**
 * Loads the nodes problem data.
 *
 * @param $conditions is an array with the following possible keys:
 *   'id' The unique id representing a specific problem.
 *   'nid' the node id.
 *   'test_id' a numeric value representing the id of the test the problem is associated with.
 *   'line' a numeric value representing the line number in which a problem applies to.
 * @param $keyed (optional)
 *   A string matching one of the following: 'id'
 *   When this is NULL, the default behavior is to return the array exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array will use the specified key name.
 *
 * @return
 *   An array of database results.
 */
function quail_api_node_load_problems($conditions = array(), $keyed = NULL){
  if (!is_array($conditions)){
    cf_error_invalid_array(__FUNCTION__, 'conditions');
    return array();
  }

  $query = db_select('quail_api_node_problems', 'qanp');

  $query->fields('qanp');
  $query->orderBy('qanp.nid', 'ASC');

  $and = NULL;

  if (isset($conditions['id']) && is_numeric($conditions['id'])){
    $and = db_and();
    $and->condition('id', $conditions['id'], '=');
  }

  if (isset($conditions['nid']) && is_numeric($conditions['nid'])){
    if (is_null($and)) $and = db_and();

    $and->condition('nid', $conditions['nid'], '=');
  }

  if (isset($conditions['test_id']) && is_numeric($conditions['test_id'])){
    if (is_null($and)) $and = db_and();

    $and->condition('test_id', $conditions['test_id'], '=');
  }

  if (!empty($conditions['line'])){
    if (is_null($and)) $and = db_and();

    $and->condition('line', $conditions['line'], '=');
  }

  if (is_object($and)) $query->condition($and);

  if ($keyed === 'id'){
    $records = $query->execute();
    $results = array();

    foreach ($records as $record){
      if (!is_object($record)) continue;

      $results[$record->$keyed] = $record;
    }

    return $results;
  }

  return $query->execute()->fetchAll();
}

/**
 * This stores validation problems for a single node to the database.
 * This will delete all pre-existing problems for the given node.
 *
 * @param $nid
 *   The node id.
 * @param $vid
 *   The node revision id.
 * @param $problems
 *   An array of arrays of test data containing the test problems
 *   - each nested array should containt the following keys:
 *     - nid: The node id of the node.
 *     - vid: The node revision id of the node.
 *     - test_id: The id of the problem.
 *     - line: The line number of the problem.
 *     - element: The html markup of the problem.
 *
 * @return
 *   The return states of either FALSE, SAVED_NEW, or SAVED_UPDATED.
 */
function quail_api_node_replace_problems($nid, $vid, $problems){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_numeric($nid)){
    cf_error_not_numeric($function_history, 'nid');
    return FALSE;
  }

  if (!is_numeric($vid)){
    cf_error_not_numeric($function_history, 'vid');
    return FALSE;
  }

  if (!is_array($problems)){
    cf_error_invalid_array($function_history, 'problems');
    return FALSE;
  }

  $result = FALSE;
  $transaction = db_transaction();

  try {
    $query = db_delete('quail_api_node_problems');
    $query->condition('nid', $nid);
    // @todo when vid support is added, be sure to add a conditional check against vid here
    $query->execute();

    foreach ($problems as $problem){
      $result = quail_api_node_save_problem($problem);
      // @todo handle return errors
    }

    // force transaction to execute
    unset($transaction);
  }
  catch (Exception $e){
    $transaction->rollback();
    watchdog_exception('quail_api', $e);
    return FALSE;
  }

  return $result;
}

/**
 * This stores a validation problem for a given node to the database.
 *
 * @param $problem_data
 *   An array of test data with the following keys:
 *   - nid: The node id of the node.
 *   - vid: The node revision id of the node.
 *   - test_id: The id of the problem.
 *   - line: The line number of the problem.
 *   - element: The html markup of the problem.
 *
 * @return
 *   The return states of either FALSE, SAVED_NEW, or SAVED_UPDATED.
 */
function quail_api_node_save_problem($problem_data){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_array($problem_data)){
    cf_error_invalid_array($function_history, 'problem_data');
    return FALSE;
  }

  $result = FALSE;
  $columns = array('nid', 'vid', 'test_id', 'line', 'element');

  foreach ($columns as $key){
    if (empty($problem_data[$key])){
      cf_error_missing_array_key($function_history, 'problem_data', $key);
      return FALSE;
    }
  }

  $data = array();
  $primary_key = array();
  $results = FALSE;

  if (!empty($problem_data['id'])){
    if (!is_numeric($problem_data['id'])){
      cf_error_not_numeric($function_history, 'problem_data');
      return FALSE;
    }

    $results = quail_api_node_load_problems(array('id' => $problem_data['id']));

    if (is_array($results) && !empty($results)){
      $data['id'] = $problem_data['id'];
      $primary_key[] = 'id';
    }
    else {
      // if a specific id is requested but does not exist, then it cannot be updated.
      return FALSE;
    }
  }

  $data['nid'] = $problem_data['nid'];
  $data['vid'] = $problem_data['vid'];
  $data['test_id'] = $problem_data['test_id'];
  $data['line'] = $problem_data['line'];
  $data['element'] = $problem_data['element'];

  $result = drupal_write_record('quail_api_node_problems', $data, $primary_key);

  return $result;
}


/**
 * This restructures an array of problems as returned from database calls into a format that can be processed by the quail api theme functions.
 * @todo when vid support is added, update this function to properly use vid.
 *
 * @param $nid
 *   A node id the results belong to.
 * @param $vid
 *   A node revision id the results belong to.
 * @param $display_levels (optional)
 *   An array of display levels as returned by quail_api_get_display_levels().
 *   If NULL is passed, then this will auto-call quail_api_get_display_levels().
 *
 * @return
 *   An array of database results in a format that can be processed by the quail_api theme functions.
 */
function quail_api_node_restructure_results($nid, $vid, $display_levels = NULL){
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  $problems = (array) quail_api_node_load_problems(array('nid' => $nid));
  $tests = quail_api_load_tests(array(), 'id', $function_history);
  $results = array();

  if (!is_array($display_levels)){
    $display_levels = quail_api_get_display_levels(NULL, $function_history);
  }

  foreach ($display_levels as $key => $value){
    if (empty($value['id'])) continue;

    $results[$value['id']] = array('total' => 0);
  }

  foreach ($problems as $problem_key => $problem_data){
    if (!is_object($problem_data)) continue;

    $test = $tests[$problem_data->test_id];

    if (!isset($results[$test->severity][$test->machine_name])){
      $results[$test->severity][$test->machine_name] = array();
      $results[$test->severity][$test->machine_name]['body'] = array();
      $results[$test->severity][$test->machine_name]['body']['title'] = $test->human_name;
      $results[$test->severity][$test->machine_name]['body']['description'] = $test->description;
      $results[$test->severity][$test->machine_name]['problems'] = array();
    }

    $problem = array();
    $problem['line'] = $problem_data->line;
    $problem['element'] = $problem_data->element;

    $results[$test->severity][$test->machine_name]['problems'][] = $problem;
    $results[$test->severity]['total']++;
  }

  return $results;
}

/**
 * Implements hook_node_type_delete().
 */
function quail_api_node_node_type_delete($info) {
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_object($info)){
    cf_error_invalid_object($function_history, 'info');
    return;
  }

  db_delete('quail_api_node_types')->condition('type', $info->type)->execute();
}

/**
 * Performs accessibility validation on a given node.
 *
 * $param $node
 *   A node object
 *
 * @return
 *   An array containing the validation results or FALSE.
 */
function quail_api_node_validate_action($node) {
  $function_history = array();
  cf_error_append_history($function_history, __FUNCTION__);

  if (!is_object($node)){
    cf_error_invalid_object($function_history, 'node');
    return FALSE;
  }

  $results = quail_api_node_perform_validation(array($node), NULL, NULL, $function_history);

  if (isset($results[$node->nid]['report'])){
    $results = $results[$node->nid]['report'];
    $methods = quail_api_get_validation_methods(NULL, $function_history);
    $database = isset($methods[$node->accessibility['method']]['database']) ? $methods[$node->accessibility['method']]['database'] : FALSE;

    if ($database && !empty($results)){
      $no_failures = TRUE;

      foreach($results as $severity => $severity_results){
        if (isset($severity_results['total']) && $severity_results['total'] > 0){
          $no_failures = FALSE;
          break;
        }
      }

      if ($no_failures){
        quail_api_node_delete_node_tests($node->nid, $node->vid);
      }
      else {
        quail_api_node_save_node_tests($node->nid, $node->vid, $results);
      }
    }
  }

  watchdog('actions', "Accessibility validating node %nid:%vid.", array('%nid' => $node->nid, '%vid' => $node->vid));

  return $results;
}
