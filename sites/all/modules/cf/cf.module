<?php

/**
 * Provide a safe way to get the current user.
 *
 * This protects the user global from coding accidents.
 *
 * Why:
 *   This is to easy to accidentally do: 'if ($user->uid = 1){'
 *
 *   The global $user data may also not have contrib modules data included, so accessing $user directly is generally not a good idea.
 *   This function seems rather waseteful given its simplicity.
 *   It may be better if drupal core would allow $uid to be left empty such that the user_load() function would handle accessing the global $user->id if $uid is empty.
 *
 *   See: http://drupal.org/node/57287
 *   See: http://api.drupal.org/api/drupal/developer--globals.php/global/user/7#comment-7324
 *
 * @param $reset
 *   TRUE to reset the internal cache and load from the database; FALSE (default) to load from the internal cache, if set.
 * @param $function_history
 *   (optional) array of function names, ie: array('0' => 'my_function_name')
 *
 * @return
 *   A copy of the global variable $user.
 *   Changes to this variable will not be retained.
 */
function cf_get_user($reset = FALSE, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  global $user;

  if (!is_object($user) || !property_exists($user, 'uid')){
    cf_error_invalid_object($function_history, 'user', WATCHDOG_CRITICAL);
    return FALSE;
  }

  return user_load($user->uid, $reset);
}

/**
 * Check to see if the variable is an array and then if the given key exists in that array.
 * Returns FALSE when variable is not an array.
 *
 * Why:
 *   According to the PHP documentation: isset() does not return TRUE for array keys that correspond to a NULL value, while array_key_exists() does.
 *   This means that array_key_exists() should be used to guarantee that a key exists as opposed to isset().
 *   The problem here is that PHP throws an error when the variable is not an array.
 *   This means that if (is_array($variable) && array_key_exists($key, $variable)) must be done.
 *
 * @param $key
 *   The key to look for
 * @param $variable
 *   The possible array to search through for the given key
 * @param $function_history
 *   (optional) array of function names, ie: array('0' => 'my_function_name')
 *
 * @return
 *   TRUE if the array key exists.
 *   FALSE if the array key does not exist or a parameter is invalid.
 */
function cf_has_array_key($key, $variable, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  if (cf_is_empty_or_non_string($function_history, 'key', $key, WATCHDOG_ERROR)){
    return FALSE;
  }

  if (is_array($variable)){
    return array_key_exists($key, $variable);
  }

  return FALSE;
}

/**
 * Converts the passed arguments into a single number.
 * The passed arguments are booleans.
 *
 * The returned crud value works in the same way that linux filesystem permissions tend to:
 * create = 1
 * read   = 2
 * update = 4
 * delete = 8
 *
 * Why:
 *   For efficiency reasons it may make more sense to store these boolean values into a single database column similar to how the unix permission umask works.
 *
 * @param $create
 *   boolean that represents whether or not the CREATE flag is set to TRUE or FALSE
 * @param $read
 *   boolean that represents whether or not the READ flag is set to TRUE or FALSE
 * @param $update
 *   boolean that represents whether or not the UPDATE flag is set to TRUE or FALSE
 * @param delete
 *   boolean that represents whether or not the DELETE flag is set to TRUE or FALSE
 * @param $function_history
 *   (optional) array of function names, ie: array('0' => 'my_function_name')
 *
 * @return
 *   A single numerical value that represents all 4 permissions.
 */
function cf_convert_to_crud($create, $read, $update, $delete, array $function_history = array()){
  $crud = 0;

  if ($create){
    $crud += 1;
  }

  if ($read){
    $crud += 2;
  }

  if ($update){
    $crud += 4;
  }

  if ($delete){
    $crud += 8;
  }

  return $crud;
}

/**
 * Converts the passed argument into an array of multiple booleans.
 * An array of booleans is returned whose keys are: create, read, update, and delete
 *
 * Crud works in the same way that linux filesystem permissions tend to:
 * create = 1
 * read   = 2
 * update = 4
 * delete = 8
 *
 * Why:
 *   For efficiency reasons it may make more sense to store these boolean values into a single database column similar to how the unix permission umask works.
 *
 * @param $crud
 *   an integer representing the crud that is to be converted into an array of booleans
 * @param $function_history
 *   (optional) array of function names, ie: array('0' => 'my_function_name')
 *
 * @return
 *   an array containing the following keys:
 *   - create: a boolean representing create permissions
 *   - read: a boolean representing read permissions
 *   - update: a boolean representing update permissions
 *   - delete: a boolean representing delete permissions
 */
function cf_convert_from_crud($crud, array $function_history = array()){
  cf_error_append_history($function_history, __FUNCTION__);

  $uncrud = array();

  $uncrud['create'] = FALSE;
  $uncrud['read']   = FALSE;
  $uncrud['update'] = FALSE;
  $uncrud['delete'] = FALSE;

  if (!isset($crud)){
    cf_error_invalid_variable($function_history, 'crud', 'Not defined', array());

    return $uncrud;
  }

  if (!is_numeric($crud)){
    cf_error_not_numeric($function_history, 'crud');

    return $uncrud;
  }

  if ($crud - 8 >= 0){
    $uncrud['delete'] = TRUE;
    $crud -= 8;
  }

  if ($crud - 4 >= 0){
    $uncrud['update'] = TRUE;
    $crud -= 4;
  }

  if ($crud - 2 >= 0){
    $uncrud['read'] = TRUE;
    $crud -= 2;
  }

  if ($crud - 1 >= 0){
    $uncrud['create'] = TRUE;
  }

  return $uncrud;
}

/**
 * Returns a standard "This page cannot be accessed" message.
 *
 * Why:
 *   The drupal form api core produces problems when anything other than a form array is returned.
 *   See: http://drupal.org/node/979758
 *
 *  @param $form_state
 *    the form state
 *  @param $id
 *    (optional) the form id, generally this should be taken from: $form['#id']
 * @param $function_history
 *   (optional) array of function names, ie: array('0' => 'my_function_name')
 *
 * @return
 *   An array that can be safely as a return statement for a page.
 */
function cf_page_not_accessible(&$form_state, $id = '', array $function_history = array()){
  $form = array();

  drupal_set_title("Unable to access page");

  $form['page_not_accessible'] = array(
    '#type' => 'item',
    '#title' => t("Unable to access page."),
    '#description' => t("This page cannot be presented because there was an error loading the page."),
  );

  $form['#id'] = is_string($id) ? $id : '';
  $form['#validate'] = array();
  $form['#submit'] = array();
  $form['#array_parents'] = array();
  $form['#tree'] = FALSE;

  $form_state['process_input'] = FALSE;

  return $form;
}
